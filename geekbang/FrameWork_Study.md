"------------------------------------------------"

            李运华老师 《从 0 开始学习架构》

"------------------------------------------------"


"""01| 架构到底是指什么"""
    
    系统和子系统、模块和组件、框架和架构。

    1、系统和子系统：
    
        系统：系统泛指有一群有关联的个体组成，根据某种规则运作，
        能完成个别元件不能单独完成的工作的群体。它的意思是“总体”
        “整体”或“联盟”。
            
            a. 关联：
                系统是由一群有关联的个体组成的，每有关联的个体堆在一起也不能成为一个系统。
            
            b. 规则：
                系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。
                规则规定了系统内个体分工和协作的方式。
            
            c. 能力：
                系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。
                
        其实子系统的定义和系统是一样的，只是观察的角度的差异，一个系统可能是另一个更大系统的子系统。
    
    2、模块和组件：
        
        软件模块(Module) 是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。
        现在软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需
        的元素。模块是可能分开被编写的单位。
        
        软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被应用于
        组装应用程序中。
        
        模块和组件都是系统的组合部分，只是从不同角度拆分系统而已。
        从逻辑的角度来拆分系统后，得到的单元就是“模块”；
        从物理的角度来拆分系统后，得到的单元就是“组件”；
        划分模块的主要目的是职责分离；
        划分组件的主要目的是单元复用。
        
    3、框架和架构：
    
        软件框架(Software framework) 通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，
        也指为了实现某个软件组件规范时，提供规范所要求之基本功能的软件产品。
        
        a. 框架是组件规范：例如， MVC就是一种常见的开发规范，还有 MVP、MVVM、J2EE等框架。
        
        b. 框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足MVC的规范，
            还提供了很多基础功能来帮助我们实现功能，包括注解，Spring Security等功能。
            
        
        软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。
        框架关注的是“规范”，
        架构关注的是“结构”。
        框架的英文是 FrameWork
        架构的英文是 Architecture。
        
    4、重新定义架构：
    
        软件架构指软件系统的顶层结构。
        架构需要明确系统包含哪些“个体”
        架构需要明确个体运作和协作的规则。
        
        
    小结:
    
        架构是顶层设计；框架是面向编程或配置的半成品；
        组件是从技术维度上的复用；
        模块是从业务逻辑上职责的划分；
        系统是相互协同可运行的实体。
        
        
"""02| 架构设计的历史背景"""          
            
    想要深入理解一个事务的本质，最好的方式是去追寻这个事物出现的历史背景和推动因素。
    
    1、机器语言(1940年之前)：
        
        太难写、太难读、太难改
      
    2、汇编语言(20 世纪 40 年代)：
        
        汇编语言又叫“符号语言”，用助记符代替机器指令的操作码，
        用地址符号(Symbol) 或标号(Label)代替指令或操作数地址。
        
        汇编语言解决了机器语言读写复杂的问题，但本质上还是面向机器的
        因为写汇编需要我们精确知道计算机底层的知识。
        
    3、高级语言(20 世纪 50 年代)：
    
        高级语言不需要程序员关注机器底层的低级结构和逻辑，
        值需要关注具体的问题和业务即可。
        
        通过编译程序的处理，高级语言可以被编译为适合不同 CPU 指令的机器语言。
        无限根据不同的机器指令重新写个程序。
        
    4、第一软件危机与结构化程序设计(20 实际 60 年代~ 20 实际 70 年代)  
        
        高级语言的出现，解放了程序员，但好景不长，随着软件的规模和复杂度的大大增加，
        20世纪60年代中期开始爆发了第一次软件危机，典型表现有软件质量低下，项目无法
        如期完成，项目严重超支等，因为软件而导致的重大事故时有发生。
        
        "结构化程序设计"作为一种解决软件危机的方案被提出来，
        一个方案是"软件工程"(不能根除，一定程度上缓解)    
        
        结构化程序设计的主要特点设计抛弃 goto 语句，采取“自顶向下，逐步细化，模块化”
        的指导思想，结构化程序设计本质上还是一种面向过程的设计思想，
        通过“自顶向下，逐步细化，模块化”，将软件的复杂度控制在一定范围内，从而整体上
        降低了软件开发的复杂度。结构化程序方法是20世纪70年代的软件开发的潮流。
        
    5、第二次软件危机与面向对象(20世纪 80年代)：
    
        结构化程序的风靡在一定程度上缓解了软件危机，然而随着硬件的快速发展，业务需求
        越来越复杂，以及编程应用领域越来越广泛，第二次软件危机很快就来了。
        
        第二次软件危机的根本原因还是在软件生产力远远跟不上硬件和业务的发展。
        第一次软件危机的根源在于软件的“逻辑”变得非常复杂，而第二次软件危机
        主要体现在软件的“扩展”变得非常复杂。
        结构化程序设计虽然能够解决(缓解更合适)软件逻辑的复杂性，但对于业务变化
        带来的软件扩展却无能为力，软件领域迫切需要找到新的银弹来解决软件危机。
        在这种背景下，面向对象的思想开始流行起来。
        
        面向对象真正开始流行是在 20 世纪 80年代，主要得益于 C++ 的功劳，后来的Java、C#
        把面向对象推向了新的高峰。到目前为止，面向对象已经成为主流开发思想。
        
        但事实证明，和软件工程一样，面向对象也不是银弹，而只是一种新的软件方法而已。
        
    6、软件架构的历史背景：
    
        软件架构从 20世纪90年代开始流行。
        
        只有较大规模的软件系统才会面临软件架构相关的问题，例如：
            系统规模庞大，内部耦合严重，开发效率低；
            系统耦合严重，牵一发懂全身，后续修改和扩展困难；
            系统逻辑复杂，容易出问题，出问题很难排查和修复。
            
        软件架构的出现是历史的必然，第一次软件危机引出了“结构化编程”，创造了“模块”的概念；
        第二次软件危机引出了“面向对象的编程”，创建了“对象”的概念；到了20世纪90年代，
        “软件架构”开始流程，创造了“组件”概念。
        “模块”，“对象”，“组件”本质上都是对一定规模的软件进行拆分，差别只是随着软件的复杂度
        不断增加，拆分的粒度越来越大粗，拆分的层次越来越高。
   
    7、小结：
    
        业务在不断发展、技术在不断演进，没有一劳永逸的办法，需要不断更新迭代。
        
        
"""03| 架构设计的目的"""
    
    架构设计的目的是为了解决软件系统复杂度带来的问题。
    
    
"""04| 复杂度来源：高性能"""   

    对性能孜孜不倦的追求是整个人类技术不断发展的根本驱动力。
    但随着性能越来越高，相应的方法和系统复杂度也是越来越高。
    
    软件系统也存在同样的想象。
    
    当然，技术的发展带来性能的提升，不一定带来复杂度的提升。
    例如，硬盘存储从纸带--> 磁带 --> 磁盘 --> SSD,并没有带来
    系统的复杂度的增加，因为新技术会逐步淘汰旧技术。这种情况我们
    直接考虑新技术即可，不用担心系统复杂度会随之提升。
    只有那些不是用来取代旧技术，而是开辟了一个全新领域的技术，
    才会给软件系统带来复杂度，因为软件系统在设计的时候就需要
    在这些技术之间进行判断选择或者组合。
    
    软件系统中高性能带来的复杂度主要体现在两个方面，
    一方面是单台计算机内部为了高性能带来的复杂度；
    另一方面是多台计算机集群为了高性能带来的复杂度。
    
    1、单机复杂度：
    
        计算机内部最关键的地方就是操作系统。
        计算机性能的发展本质上是由硬件发展驱动的，尤其是 CPU 的性能发展。
        硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身也是跟随
        硬件发展而发展的，操作系统是软件系统的运行环境，操作系统的复杂度
        直接决定了软件系统的复杂度。
        
        操作系统和性能最相关的就是进程和线程。
        
        为了提升CPU的性能，人们发明了“进程”，用进程来对应一个任务，每个
        任务都有自己独立的内存空间，进程间互补相关，有操作系统来进行调度。
        虽然当时 CPU 还没有多核和多线程的概念，为了达到多进程并行运行的目的，
        采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个
        进程中的指令。虽然从操作系统和 CPU 的角度来说还是串行处理，但是由
        于 CPU 的处理速度很快，从用户的角度来看，感觉是很多进程在并行处理。
        
        多进程虽然要求每个任务都有独立的内存空间，进程间互不相关，但从用户的
        角度来看，两个任务之间能够在运行过程中就进行通信，会让任务设计变得
        更加灵活高效，为了解决这个问题，进程间通信的各种方式被设计出来了，
        包括管道、消息队列、信号量、共享内存等。
        
        多进程让多任务能够并行处理任务，但本身还是有缺点的，单个进程内部只能
        串行处理，而实际上很多进程内存的子任务并不要求是严格按照时间顺序来执行的，
        也需要并行处理。为了解决这个问题，人们又发明了线程，线程时进程内部的子任务，
        但这些子任务都共享同一份进程数据。为了保持数据的正确性，又发明了互斥锁机制。
        有了线程后，操作系统调度的最小单位就是线程了，而进程是操作系统分配资源的最小单位。
        
        多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能
        做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时
        执行计算任务，从而实现真正意义上的多任务并行。目前这样的解决方案有 3 中：
        SMP(Symmetric Multi-Processor 对称多处理器结构)、MUMA(Non-Uniform Memory Access
        非一致存储访问结构)、MPP(Massive Parallel Processing, 海量并行处理结构)。
        其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP 方案。
        
        操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑入多进程、多线程
        进程间的通信、多线程并发等技术点，而这些技术并不是最新的就是最好的，也不是非此即彼的选择。
        在做架构的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。
        举个例子：Nginx 可以用多进程也可以多线程，JBoos 采用的是多进程、Redis 采用的是单进程
        Memcache 采用的是多线程，这些系统都实现了高性能，但内部的差异却很大。
        
    2、集群的复杂度：
    
        虽然计算机硬件的性能快速发展，但和业务的发展速度相比，还是小巫见大巫了。
        进入互联网后，业务发展速度远远超过了硬件的发展速度。
        
        由于业务的快速发展，单台计算机远远不能满足业务需求，出现了服务器集群。
        通过大量机器来提升性能，让多台机器配合起来达到高性能的目的，是一个复杂
        的任务，有常见几种方式：
        
        a. 任务分配：
            
            任务分配的意思是指每台机器都可以处理完整个业务，不同的任务分配到不同的机器上执行。
            例如一台服务器变成两台服务器，来讲任务分配的复杂性。
            
            1 台服务器演变成 2 台服务器，架构上明显复杂多了，主要体现在：
                
                需要增加一个任务分配器，这个分配器可能是硬件网络设备(例如：F5，交换机等)
                可能是网络设备(LVS), 也可以是负载均衡软件(例如 Nginx, HAProxy)
                还可能是自己研发的系统。选择合适的任务分配器也是一件复杂的事情，
                需要考虑到性能、成本、可维护性、可用性等各方面的因素。
                
                任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式
                并且对连接进行管理。例如，连接建立，连接检查、连接中断后如何处理。
                
                任务分配器需要增加分配算法。例如是采用轮询算法，还是按权分配，或者按照负载分配。
                如果按照服务器的负载进行分配，则业务服务器还能够上报自己的状态给任务服务器。
                
            多台任务分配器，多台服务器：
            
                这个架构比 2 台业务服务器的架构要复杂，主要体现在：
                
                任务分配器从 1 台变成了多台，这个变化带来的复杂度就是需要将不同的
                用户分配到不同的任务分配器上。常见的方法有 DNS轮询、智能DNS、
                CDN(Content Delivery Network 内容分发网络)、
                GSLB 设备(Global Server Load Balance 全局负载均衡)等。
                
                任务分配器和业务服务器的连接从简单的“1 对多” 变成了“多对多”的网络结构。
                
                机器数量从3台扩展到了30台，状态管理、故障处理复杂度大大增加。
                
        b. 任务分解：
        
            通过任务分配的方式，我们能够突破单台机其处理性能的瓶颈，
            通过增加更多的机器来满足业务的性能需求，但是，如果业务本身
            也越来越复杂，单纯只通过任务分配的方式来扩展性能，收益会越来越低。
            造成这种现象的原因是业务越来越复杂，单台机器处理的性能会越来越低。
            为了能够继续提升性能，我们采取第二种方式，任务分解。
            
            例如：以微信后台为例，微信后台架构从逻辑上讲各个子业务进行了拆分，
            包含：接入、注册登录、消息、LBS、等等。
            通过这种任务分解的方式，能够把原来大一统的复杂的业务系统，拆分
            成小而简单但需要多个系统配合的业务系统。
            
            从业务的角度看，任务分解不会减少代码量（事实上代码量可能增加，因为从代码内部
            调用改为通过服务器之间的接口调用），那么为何任务分解能够提升性能呢？
            
            主要因素：
            
                简单的系统更容易做到高性能：
                
                    系统功能越简单，影响性能的点就越少，就更容易进行针对性的优化。
                    
                可以针对单个任务进行扩展：
                
            虽然系统拆分可能在某种程度上提升业务处理性能，但提升性能也有限的，
            系统拆分的越西，系统直接进行处理消耗的时间越多。
            最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有多大变化下，
            理论上的性能有一个上限，系统拆分能让性能逼近极限，但无法突破。
            任务分解不是越细越好，对于架构来说，如何把握颗粒度非常关键。
            
    3、小结：
    
        第一是单台计算机内部为高性能带来的复杂度(主要是对操作系统的重复利用)
        第二是多台计算机集群为了高性能带来的复杂度(任务分配、任务分解)。
        
              

"""05| 复杂度来源：高可用"""        

    维基百科：
        
        系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。
    
    关键在于无中断，难度也在无中断。
    硬件会出故障，软件会有bug, 硬件会老化，软件系统会越来越复杂和庞大。
    外部环境的不可用更不可避免，不受控制。
    
    所以，系统的高可用方案五花八门，其本质都是通过“冗余”来实现高可用。
    高可用的“冗余”解决方案，单纯从形式上来看，和之前讲的高性能一样，
    都是通过增加更多的机器来到达目的，但其本质区别是：
    高性能增加机器目的在于“扩展”处理性能；
    高可用增加机器目的在于“冗余”处理单元。
    
    
    通过冗余增加了可用性，但同时也带来了复杂性。
    
    1、计算高可用：
        
        这里的“计算”指的是业务的逻辑处理。
        计算有一个特点就是无论在那台机器上进行计算，同样的算法和输入数据，
        产出的结果都是一样的。
        
        从最简单的单机变双机为例：
            
            需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情。
            综合考虑性能等等。
            
            任务分配器和真正的业务处理服务器之间有连接和交互，需要选择合适的
            连接方式，并且对连接进行管理。例如建立连接、连接检测、连接中断后
            如何处理等。
            
            任务分配器需要增加分配算法。例如常见的双机算法有主备、主主、
            主备可以细分为冷备、温备、热备。
            
    2、存储高可用：
    
        存储和计算相比，有一个本质的区别：将数据从一台机器搬到另一台机器，
        需要经过线路进行传输。
        物理上的传输有速度限制，传输线路本身也可能存在问题，传输线路可能
        中断、拥塞、异常等等。
        
        综合分析，无论是正常情况下的传输延迟，还是异常情况下的传输中断，
        都会导致系统的数据在某个时间点上或时间段内不一致，而数据不一致
        又会导致业务问题；但不做冗余，系统的高可用性又无法保证
        所以存储高可用性的难度不做于如何备份数据，而在于如何减少或者
        规避数据不一致性造成的影响。
        
        分布式领域里面有一个著名的 CAP 定理，从理论上论证了存储高可用性的复杂度。
        也就是说，存储高可用不可能同时满足“一致性”、“可用性”、“分区容错性”。
        最多满足其中两个，就需要我们进行取舍。
        
    3、高可用状态决策：
    
        无论是计算高可用还是存储高可用，其基础都是“状态决策”，即系统需要判断
        当前的状态是正常还是异常，如果出现异常就要采取行动来保证高可用。
        如果状态决策出现错误或本身有偏差，那么后续多么完美也没有意义。
        
        但在具体的实践中，恰好有一个矛盾：通过冗余来实现的高可用系统，
        状态决策本质上就不可能做到完全正确。
        下面是几种常见的决策方式：
        
        a. 独裁式：
        
            独裁式决策指的是存在一个独立的决策主体，姑且称为“决策者”，
            负责收集信息后进行决策；所有冗余的个体，我们姑且称为“上报者”
            都是讲状态信息发送给决策者。
            独裁式的决策方式不会出现决策混乱的问题，因为只有一个决策者。
            但问题也正是在于只有一个决策者，当决策者出故障的时候，整个
            系统就无法实现准确的状态决策。如果决策者本身又做一套状态
            决策，那就陷入一个递归死循环。
            
        b. 协商式:
        
            协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策
            最常用的协商决策就是主备决策。
            
            这个架构的基本协商规则可以设计成：
                2台机器启动是备机。
                2台服务器建立连接。
                2台服务交换状态信息。
                某1台服务器做出决策，成为主机，另一台服务器继续保持备机。
            协商式架构不复杂，规则也不复杂，难度是，如果两者的信息交换出现
            问题(主备连接断了)，此时状态决策应该怎么做。    
            
            如果备机在连接中断情况下，认为主机故障，把备机升为主机，
            如果主机没有故障，出现两个主机，与设计初衷(一主一备不符)
            
            如果备机在连接中断后不认为主机故障，但主机真的故障，就没有主机了。
            
            如果为了规避连接中断对状态决策带来影响，增加连接数，这样虽然
            可以减低中断对状态带来的影响，但带来了新的问题，不同线传递信息不同。
             
            综合分析，协商式状态决策在某些场景下总是存在问题的。
        
        c. 民主式：
        
            民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。
            例如ZooKeeper 集群在选举 leader 时就是采取这种方式。
            其基础是独立的个体之间交互信息，每个个体都做出自己决策
            然后按照"多数取胜"的规则来确定最终状态。民主决策更复杂。
            
            民主式决策可能出现脑裂的情况。
            
            综合分析，无论采取怎么的方案，状态决策都不可能在任务场景
            下都没有问题。
            
    4、小结：
    
        计算可用性：
            增加任务分配器
        
        存储可用性
            数据一致性
            
        高可用状态决策方式：
            独裁式
            协商式
            民主式   
            

                
"""06| 复杂度来源：可扩展性"""
    
    可扩展性指系统为了应对将来需求的变化而提供的一种扩展能力，
    当有新需求出现时，系统不需要或者仅需要少量修改就可以支持
    无需整个系统重构或者重建。
    
    由于软件固有的多变性，新的需求总会不断提出，因此可扩展性显得尤其重要。
    在软件开发领域，面向对象思想的提出，就是为了解决可扩展性带来的问题，
    后来的设计模式，更是将可扩展性做到了极致。
    得益于设计模式的巨大影响力，几乎所有的技术人员对于可扩展性都特别重视。
    
    设计具有良好可扩展性的系统，有两个基本的条件：正确预测变化、完美封装变化。
    
    1、预测变化：
    
        软件系统发布后可以不断的修改和演进，这意味着不断有新的需求需要实现。
        预测变化的复杂性在于：
            不能每个设计点都考虑可扩展性。
            不能完全不考虑可扩展性。
            所有的预测都存在出错的可能性。
            
    2、应对变化：
    
        a. 系统需要拆分出变化层和稳定层。
        
        b. 需要设计变化层和稳定层之间的接口。
        
        
        常见应对变化的方案是提炼出一个“抽象层”和一个“实现层”
        抽象层是稳定的，实现层可以根据业务需求定制开发，当加入
        新的功能时，只需要增加新的实现，无需修改抽象层。
    
    3、小结：
    
        《设计模式》
        设计模式的核心就是，封装变化，隔离可变性。
    
    
"""07| 复杂度来源：底成本、安全、规模"""    