"------------------------------------------------"

            李运华老师 《从 0 开始学习架构》

"------------------------------------------------"


"""01| 架构到底是指什么"""
    
    系统和子系统、模块和组件、框架和架构。

    1、系统和子系统：
    
        系统：系统泛指有一群有关联的个体组成，根据某种规则运作，
        能完成个别元件不能单独完成的工作的群体。它的意思是“总体”
        “整体”或“联盟”。
            
            a. 关联：
                系统是由一群有关联的个体组成的，每有关联的个体堆在一起也不能成为一个系统。
            
            b. 规则：
                系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。
                规则规定了系统内个体分工和协作的方式。
            
            c. 能力：
                系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。
                
        其实子系统的定义和系统是一样的，只是观察的角度的差异，一个系统可能是另一个更大系统的子系统。
    
    2、模块和组件：
        
        软件模块(Module) 是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。
        现在软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需
        的元素。模块是可能分开被编写的单位。
        
        软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被应用于
        组装应用程序中。
        
        模块和组件都是系统的组合部分，只是从不同角度拆分系统而已。
        从逻辑的角度来拆分系统后，得到的单元就是“模块”；
        从物理的角度来拆分系统后，得到的单元就是“组件”；
        划分模块的主要目的是职责分离；
        划分组件的主要目的是单元复用。
        
    3、框架和架构：
    
        软件框架(Software framework) 通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，
        也指为了实现某个软件组件规范时，提供规范所要求之基本功能的软件产品。
        
        a. 框架是组件规范：例如， MVC就是一种常见的开发规范，还有 MVP、MVVM、J2EE等框架。
        
        b. 框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足MVC的规范，
            还提供了很多基础功能来帮助我们实现功能，包括注解，Spring Security等功能。
            
        
        软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。
        框架关注的是“规范”，
        架构关注的是“结构”。
        框架的英文是 FrameWork
        架构的英文是 Architecture。
        
    4、重新定义架构：
    
        软件架构指软件系统的顶层结构。
        架构需要明确系统包含哪些“个体”
        架构需要明确个体运作和协作的规则。
        
        
    小结:
    
        架构是顶层设计；框架是面向编程或配置的半成品；
        组件是从技术维度上的复用；
        模块是从业务逻辑上职责的划分；
        系统是相互协同可运行的实体。
        
        
"""02| 架构设计的历史背景"""          
            
    想要深入理解一个事务的本质，最好的方式是去追寻这个事物出现的历史背景和推动因素。
    
    1、机器语言(1940年之前)：
        
        太难写、太难读、太难改
      
    2、汇编语言(20 世纪 40 年代)：
        
        汇编语言又叫“符号语言”，用助记符代替机器指令的操作码，
        用地址符号(Symbol) 或标号(Label)代替指令或操作数地址。
        
        汇编语言解决了机器语言读写复杂的问题，但本质上还是面向机器的
        因为写汇编需要我们精确知道计算机底层的知识。
        
    3、高级语言(20 世纪 50 年代)：
    
        高级语言不需要程序员关注机器底层的低级结构和逻辑，
        值需要关注具体的问题和业务即可。
        
        通过编译程序的处理，高级语言可以被编译为适合不同 CPU 指令的机器语言。
        无限根据不同的机器指令重新写个程序。
        
    4、第一软件危机与结构化程序设计(20 实际 60 年代~ 20 实际 70 年代)  
        
        高级语言的出现，解放了程序员，但好景不长，随着软件的规模和复杂度的大大增加，
        20世纪60年代中期开始爆发了第一次软件危机，典型表现有软件质量低下，项目无法
        如期完成，项目严重超支等，因为软件而导致的重大事故时有发生。
        
        "结构化程序设计"作为一种解决软件危机的方案被提出来，
        一个方案是"软件工程"(不能根除，一定程度上缓解)    
        
        结构化程序设计的主要特点设计抛弃 goto 语句，采取“自顶向下，逐步细化，模块化”
        的指导思想，结构化程序设计本质上还是一种面向过程的设计思想，
        通过“自顶向下，逐步细化，模块化”，将软件的复杂度控制在一定范围内，从而整体上
        降低了软件开发的复杂度。结构化程序方法是20世纪70年代的软件开发的潮流。
        
    5、第二次软件危机与面向对象(20世纪 80年代)：
    
        结构化程序的风靡在一定程度上缓解了软件危机，然而随着硬件的快速发展，业务需求
        越来越复杂，以及编程应用领域越来越广泛，第二次软件危机很快就来了。
        
        第二次软件危机的根本原因还是在软件生产力远远跟不上硬件和业务的发展。
        第一次软件危机的根源在于软件的“逻辑”变得非常复杂，而第二次软件危机
        主要体现在软件的“扩展”变得非常复杂。
        结构化程序设计虽然能够解决(缓解更合适)软件逻辑的复杂性，但对于业务变化
        带来的软件扩展却无能为力，软件领域迫切需要找到新的银弹来解决软件危机。
        在这种背景下，面向对象的思想开始流行起来。
        
        面向对象真正开始流行是在 20 世纪 80年代，主要得益于 C++ 的功劳，后来的Java、C#
        把面向对象推向了新的高峰。到目前为止，面向对象已经成为主流开发思想。
        
        但事实证明，和软件工程一样，面向对象也不是银弹，而只是一种新的软件方法而已。
        
    6、软件架构的历史背景：
    
        软件架构从 20世纪90年代开始流行。
        
        只有较大规模的软件系统才会面临软件架构相关的问题，例如：
            系统规模庞大，内部耦合严重，开发效率低；
            系统耦合严重，牵一发懂全身，后续修改和扩展困难；
            系统逻辑复杂，容易出问题，出问题很难排查和修复。
            
        软件架构的出现是历史的必然，第一次软件危机引出了“结构化编程”，创造了“模块”的概念；
        第二次软件危机引出了“面向对象的编程”，创建了“对象”的概念；到了20世纪90年代，
        “软件架构”开始流程，创造了“组件”概念。
        “模块”，“对象”，“组件”本质上都是对一定规模的软件进行拆分，差别只是随着软件的复杂度
        不断增加，拆分的粒度越来越大粗，拆分的层次越来越高。
   
    7、小结：
    
        业务在不断发展、技术在不断演进，没有一劳永逸的办法，需要不断更新迭代。
        
        
"""03| 架构设计的目的"""
    
    架构设计的目的是为了解决软件系统复杂度带来的问题。
    
    
"""04| 复杂度来源：高性能"""   

    对性能孜孜不倦的追求是整个人类技术不断发展的根本驱动力。
    但随着性能越来越高，相应的方法和系统复杂度也是越来越高。
    
    软件系统也存在同样的想象。
    
    当然，技术的发展带来性能的提升，不一定带来复杂度的提升。
    例如，硬盘存储从纸带--> 磁带 --> 磁盘 --> SSD,并没有带来
    系统的复杂度的增加，因为新技术会逐步淘汰旧技术。这种情况我们
    直接考虑新技术即可，不用担心系统复杂度会随之提升。
    只有那些不是用来取代旧技术，而是开辟了一个全新领域的技术，
    才会给软件系统带来复杂度，因为软件系统在设计的时候就需要
    在这些技术之间进行判断选择或者组合。
    
    软件系统中高性能带来的复杂度主要体现在两个方面，
    一方面是单台计算机内部为了高性能带来的复杂度；
    另一方面是多台计算机集群为了高性能带来的复杂度。
    
    1、单机复杂度：
    
        计算机内部最关键的地方就是操作系统。
        计算机性能的发展本质上是由硬件发展驱动的，尤其是 CPU 的性能发展。
        硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身也是跟随
        硬件发展而发展的，操作系统是软件系统的运行环境，操作系统的复杂度
        直接决定了软件系统的复杂度。
        
        操作系统和性能最相关的就是进程和线程。
        
        为了提升CPU的性能，人们发明了“进程”，用进程来对应一个任务，每个
        任务都有自己独立的内存空间，进程间互补相关，有操作系统来进行调度。
        虽然当时 CPU 还没有多核和多线程的概念，为了达到多进程并行运行的目的，
        采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个
        进程中的指令。虽然从操作系统和 CPU 的角度来说还是串行处理，但是由
        于 CPU 的处理速度很快，从用户的角度来看，感觉是很多进程在并行处理。
        
        多进程虽然要求每个任务都有独立的内存空间，进程间互不相关，但从用户的
        角度来看，两个任务之间能够在运行过程中就进行通信，会让任务设计变得
        更加灵活高效，为了解决这个问题，进程间通信的各种方式被设计出来了，
        包括管道、消息队列、信号量、共享内存等。
        
        多进程让多任务能够并行处理任务，但本身还是有缺点的，单个进程内部只能
        串行处理，而实际上很多进程内存的子任务并不要求是严格按照时间顺序来执行的，
        也需要并行处理。为了解决这个问题，人们又发明了线程，线程时进程内部的子任务，
        但这些子任务都共享同一份进程数据。为了保持数据的正确性，又发明了互斥锁机制。
        有了线程后，操作系统调度的最小单位就是线程了，而进程是操作系统分配资源的最小单位。
        
        多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能
        做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时
        执行计算任务，从而实现真正意义上的多任务并行。目前这样的解决方案有 3 中：
        SMP(Symmetric Multi-Processor 对称多处理器结构)、MUMA(Non-Uniform Memory Access
        非一致存储访问结构)、MPP(Massive Parallel Processing, 海量并行处理结构)。
        其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP 方案。
        
        操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑入多进程、多线程
        进程间的通信、多线程并发等技术点，而这些技术并不是最新的就是最好的，也不是非此即彼的选择。
        在做架构的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。
        举个例子：Nginx 可以用多进程也可以多线程，JBoos 采用的是多进程、Redis 采用的是单进程
        Memcache 采用的是多线程，这些系统都实现了高性能，但内部的差异却很大。
        
    2、集群的复杂度：
    
        虽然计算机硬件的性能快速发展，但和业务的发展速度相比，还是小巫见大巫了。
        进入互联网后，业务发展速度远远超过了硬件的发展速度。
        
        由于业务的快速发展，单台计算机远远不能满足业务需求，出现了服务器集群。
        通过大量机器来提升性能，让多台机器配合起来达到高性能的目的，是一个复杂
        的任务，有常见几种方式：
        
        a. 任务分配：
            
            任务分配的意思是指每台机器都可以处理完整个业务，不同的任务分配到不同的机器上执行。
            例如一台服务器变成两台服务器，来讲任务分配的复杂性。
            
            1 台服务器演变成 2 台服务器，架构上明显复杂多了，主要体现在：
                
                需要增加一个任务分配器，这个分配器可能是硬件网络设备(例如：F5，交换机等)
                可能是网络设备(LVS), 也可以是负载均衡软件(例如 Nginx, HAProxy)
                还可能是自己研发的系统。选择合适的任务分配器也是一件复杂的事情，
                需要考虑到性能、成本、可维护性、可用性等各方面的因素。
                
                任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式
                并且对连接进行管理。例如，连接建立，连接检查、连接中断后如何处理。
                
                任务分配器需要增加分配算法。例如是采用轮询算法，还是按权分配，或者按照负载分配。
                如果按照服务器的负载进行分配，则业务服务器还能够上报自己的状态给任务服务器。
                
                
                
                
              
            
        
        
        b. 任务分解
        
        
            
        
        
    
                     
    
    
                    
                    

"""05| 复杂度来源：高可用"""        
                
"""06| 复杂度来源：可扩展性"""
