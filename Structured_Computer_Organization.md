"-----------------------------------------------------------"

              《计算机组成结构化方法》 学习笔记

                         第一章 概述  

    数字计算机是通过执行人们给指令来完成工作的机器。描述如何完成一个确定的任务的指令序列称为程序。
    每台计算机的电路都只能识别和直接执行有限的简单指令，所有程序都必须在执行前转换成这些指令。
    
    计算机的这些原始指令共同组成了一种可供人和计算机进行交流的语言，我们成为其机器语言。
    原始指令应尽量简单，兼顾考虑计算机的使用要求和性能要求，以降低实现电路的成本和复杂度。
    
    通过对计算机的简单描述，我们可将计算机化为一系列抽象机，每台抽象机都建立在其下层抽象机的基础上。
    这样，计算机的复杂性就在可控制范围内，计算机系统的设计也可在有组织和系统的状态下进行。
    我们把这种方法称为结构化计算机组成。
    
    """1.1 机构化计算机组成"""
    
        正如前面提到的，在方便人们使用和方便计算机实现之间存在着巨大的差距。人们能要做 X,
        而计算机只会做 Y。 这就是问题，本书目的就是解释如何解决这个问题。
        
        1.1.1 语言、层次和虚拟机：
        
            这个问题可从两个途径解决，两者都需要设计一个比内置的机器指令更方便人们使用的新的指令集合。
            这样，新的机器指令集合也构成了一种语言，我们成为 L1,对应的把机器中内置的机器语言指令组成
            的语言叫L0, 两种途径的不同之处在于采取什么办法将只能执行用 L0写出的程序的计算机执行用
            L1写的程序。
                
                一种途径是在执行用 L1 写的程序之前生成一个等价的 L0 指令序列来替换它，生成的程序
                全部由 L0 指令组成。计算机执行等效的 L0 程序来替换原来的 L1 程序，这种技术叫作翻译（translation）
                
                另一种途径是用 L0 写一个程序，将 L1 的程序作为输入数据，按顺序检查它的每条指令，
                然后直接执行等效的 L0 指令序列计算出结果。它不需要事先生成一个 L0 语言的新程序。
                我们把这种方法称为解释（interpretation）,把完成这个过程的 L0 程序称为解释器。
                
            翻译和解释其实是类似的，两种方法中的 L1 的指令最终都通过执行等效的 L0 指令序列来实现。
            区别在于，翻译时整个 L1 程序都先转换为 L0 程序，然后 L1 程序被抛弃。新的 L0 程序被
            装入计算机内存中执行。执行过程中，运行的都是新生产的 L0 程序，控制计算机的也是 L0 程序。
                
            而解释时，每条 L1 指令被检查和解码之后将立即执行，不生成翻译后的程序。这里，控制计算机
            的是解释器。对他来说，L1 程序仅仅只是数据。
                
            比起理解翻译和解释着两种概念，想象存在一种假想的以 L1 为机器语言的计算机或虚拟机。
            让我们把这种虚拟机定义为 M1(相应的，把原来的以 L0 为机器语言的虚拟机定义为 M0),
            如果这种计算机可以足够低廉，那么就不需要 L0这种语言或者是执行L0语言的程序的机器了。
            人们可以简单的用 L1 写程序并让计算机直接执行。即使因为使用 L1 为语言的虚拟机太贵
            或太复杂而不能有电路构成，也可以写 L1 语言的程序，这些程序可以直接用被现有的计算机
            执行的 L0 语言程序翻译或解释。
            换句话说，完全可以像虚拟机真正的存在一样用它们的语言写程序。
                
            为了使翻译或解释实现可行，两种语言 L0 和 L1 的差别不能 “太” 大。
            这条限制意味着，虽然 L1 比 L0 好，但对于多数应用来说还是不理想。
            这也会导致对提出 L1 的最初目的-- 减轻程序员不得不用一种更适合计算机的语言来描述算法的负担
            有些失望。但不应该是绝望。
                
            显然，解决问题的办法是发明一种比 L1 更面向人且少面向机器的指令集来取代它，这种指令集
            形成的语言，我们可以称为 L2(对于的虚拟机为 M2)。人们可以像用 L2 作为机器语言的虚拟机
            真正存在一样用 L2 写程序，然后翻译成 L1 或用 L1 携程的解释器来执行。
                
            这种发明一系列的语言，每一种都比前一种更方便人们使用可以无限的继续下去，直到最后找到
            一种合适的语言。
            每一种语言都以前一种为基础，我们可以把使用这种技术的计算机看出一系列的层，一层在一层之上。
            最底部的语言或层最简单，而最上面的语言或层最复杂。
                
            语言和虚拟机之间存在着重要的对应关系，每种机器都有由它能执行的指令组成的机器语言，
            也就是说，机器定义语言。类似地，语言也定义了机器--即机器要能执行用这种语言写的所有程序。
            
            一般意义上讲，有 n 层的计算机可看成 n 台不同的虚拟机，每一台的机器语言都不相同。
            我们将交替使用术语 “层” 和 “虚拟机” 表示同样的意思。只有用 L0 语言写的程序可以被
            电子电路之直接执行，无须进行中间翻译或解释。用L1、L2、... Ln 写的程序必须经底层
            解释器解释或翻译成对于与底层的另一种语言。
        
        
        1.1.2 现代多层次计算机。
            
            
            第 5 层：面向问题的语言层-->(翻译，编译器)：
            
                第5层通常是提供解决现实问题的应用程序员使用的，这些语言通常称为高级语言。
                比如：c、c++、java、python、perl、php.
                用这些语言写的程序一般先由编译器（compiler）翻译成第 3或第4层语言，
                虽然偶尔也有解释执行的。例如，用java 语言写的程序通常先被翻译成一种
                类似于指令系统层的语言 --java 字节码，然后被解释执行。
            
            
            第 4 层：汇编语言层 --->(翻的译，汇编器)：
                
                第 4 层和第 3 层有着根本的区别，最低的三层并不是为普通程序员设计的，而是主要是为了支持
                高层所需的解释器或翻译器的运行而设计的，这些解释器和翻译器是由专职设计和实现新的虚拟机
                的系统程序员写的。第4层以及上各层才是提供哪些解决应用问题的应用程序使用的。
                
                第4层发生的其他变化是支持上层的方法。第2和3层都是解释，而第4、5层通常是翻译（不全是）。
                
                最低三层与第 4,5以及更高层的其他区别是提供语言本质的变化。
                第1、2、3层提供的机器语言都是数字串、这几层中的程序包含数字的长序、适合机器执行，而
                不容易被人理解。从第4层开始，提供的语言成了能帮助人们理解的单词或助记符。
                
                第4层，汇编语言层，实际上是某种底层语言的符号表示。本层为程序员写第1、2、3层程序提供了
                一种比用虚拟机语言直接写这些程序更舒服的方法。
                用汇编语言写的程序首先被翻译成第3、2、1层的语言，然后又相应的虚拟机或硬件解释执行。
                完成翻译过程的程序称为汇编器（assembler）。
            
            第 3 层：操作系统层 --->(部分解析，操作系统)：
            
                这一层是通常是混合层，大多数指令和 ISA 层相同，另外，这一层有新的指令集，
                不同的存储器结构，有同时运行两个或多个程序的能力，以及其他的一些特性。
                
                第3层增加的新的功能是由运行在第2层的解释器来执行的，那些和第2层相同的指令将直接交给微程序(或硬件)执行。
                有些指令由操作系统解释，而有些由微程序(或硬件)直接解释，这就是“混合层”的含义。
                这层又称为操作系统机器层。
                
            第 2 层：指令系统层 --->(解释（微程序）或直接执行)：
                
                指令系统层或 ISA 层（Instruction Set Architecture level），
                这一层规定了计算机使用的机器的指令集，实际上是由微程序解释或
                硬件执行电路直接执行的指令。
            
            
            第 1 层：微体系结构层 --->(硬件)：
                
                这层我们看到一般由 8 ~ 32个寄存器组成的寄存器组以及名为 ALU(算术逻辑部件)的电路，
                ALU 可以完成以下简单的算术运算。
                这些寄存器和ALU 相连形成数据通路（data path）,供数据在其流动。
                数据通路的基本功能是选择一个或两个寄存器作为 ALU 的操作数（例如，相加），然后将
                结果存回某个寄存器。
                
                一些机器上的数据通路的这些功能是由一个叫做微程序的程序控制的而另外一些机器是直接有硬件控制的。
                微程序可看作是对第 2 层指令的解释器，它通过数据通路逐条对执令进行取值、检查和执行。
                
            第 0 层：数据逻辑层：
                
                最低层--数据逻辑层，我们研究的对象是门（gate）,虽然它们由类似的原件（如晶体管）构成，
                但门可以作为数字设备的精确原型。每个门可以有一个或多个数字输入端（由 0 或 1 表示的信号）。
                可计算出输出这些输入的一些简单逻辑函数（与和或）的结果。门最多有几个晶体管构成，几个
                门可组成 1 位存储器，存放一个 0 或 1.
                1 位存储器可组合成 16、32、64一组，形成寄存器。每个寄存器可存放一个不大于某个最大值的二进制数。
                
            
            总体来说，将计算机设计成一些列的层，每层建立在它的前一层之上，每层表示一个不同的抽象，由不同的对象
            和操作表示。
           
            每层的数据类型、操作和特性构成了该层的体系结构。它解决的是该的层用户能看到的问题。
            计算机体系结构是研究如何设计程序员眼中的计算机系统的学科。
                                
        1.1.3 多层次计算机的演化：
            
            在计算机早期：
                硬件是具体的对象：集成电路、印制电路板、电缆、电源、存储器和打印机等。
                软件是组成程序的指令的集合，而不是记录它们的物理介质。
            
            随着时间推移，计算机层次增加、减少、合并，软硬件界限变得越来越模糊。
                硬件和软件在逻辑上是等同的。
                硬件就是固化的软件。
                任何硬件执行的指令都可由软件来模拟。
    
    1.2 计算机体系结构的里程碑：
    
        第一代电子管计算机 （ENIAC）
        第二代晶体管计算机 （IBM 7094）
        第三代集成电路计算机 （IBM 360）
        第四代个人计算机 （Intel 的 CPU 系列）
        第五代计算机智能手机            
        未来计算机将无处不在，嵌入到任何对象中。
    
    1.3 计算机家族：
    
        计算机行业的发展速度是其他行业无法比拟的，其最主要的原动力是每年增长的在单片芯片中集成更多集体管的能力。
        每片芯片集成的晶体管越多，即芯片中的逻辑门越多，也就意味着更大的内存和更强的处理能力。
         
        Moore定律：每片芯片中集成的晶体管的数量18个月翻一番，也就是说，每年增长 60%。
        Moore 定律不是一条定律，只是对固体物理学家和工艺工程师推动芯片发展工作的观察而得出的经验公式，并预测未来还会保持这个发展速度。
        
        推动技术进步的另一个因素是 Nathan 的软件第一个定律：软件是一种可以膨胀到充满整个容器的气体。
        20世纪80年代字处理软件占用几十K内存，而现在占用几十M内存。软件不断发展的特点对更快的处理器
        跟大的内存、更强的输入/输出 能力提供了持续要求。
        
        一次性计算机： 无线射频识别（Radio Frequency IDentification, RFID）芯片。
        
        微型控制器：嵌入式计算机，又称微型控制器，管理设备并与用户交互。
        
        移动计算机和游戏计算机：对移动计算机一个要求是移动中尽量减少能量消耗。
        
        个人计算机：
        
        服务器：从体系结构上看，单处理器的服务器和单处理器的个人计算机并没有真正的差别，
                仅仅是更快一些，体积大些，硬盘空间大一些，网络快一些。
                
        集群：由于服务器性价比上的持续增长，近年来，系统设计师们开始讲它们连接起来，共同组成集群。
             集群由标准的服务器级别系统通过 Gbps 的网络连接而成，运行特殊的软件使所有的共同解决一个商务、科学、工程问题。 
             通常，大集群被放置在一个专门的房间或者建筑中，称为数据中心。
             
             特定时代下流行的计算模式与当时的技术、经济和可以获得的应用密切相关，当这些要素改变时，计算模式随之改变。
         
             
    1.4 系列计算机举例：
    
        a. x86 体系结构简介(intel)：
            
            x86 架构可以在几乎所有的个人计算机和服务器系统中。
            
            X86架构：
                X86架构（The X86 architecture）是微处理器执行的计算机语言指令集，
                指一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。
                
                X86是由Intel推出的一种复杂指令集，用于控制芯片的运行的程序，现在X86已经广泛运用到了家用PC（
                
            CPU的主频:
                
                即CPU内核工作的时钟频率（CPU Clock Speed）。
                通常所说的某某CPU是多少兆赫的，而这个多少兆赫就是“CPU的主频”。
                主频越高，CPU的运算速度就越快。但主频不等于处理器一秒钟执行的指令条数，因为一条指令的执行可能需要多个时钟周期。
                对于CPU，在有兼容性的前提下，主要看其速度，而主频越高，字节越长，CPU速度就越快。             
            
            
            高速缓存：
                
                用来在 CPU 内部或靠近 CPU 的地方存放最常用的内存字，以避免（或减少）内存访问。

            虽然 Moore 定律与存储器的位数有关，但它同样适用于 CPU 芯片，但是一个问题开始为它
            投上了阴影，即散热问题，时钟频率越高，要求电源电源越高，晶体管的数据少时还可以承受。
            而能耗及散热量与电压的平方成正比，因此，速度越快意味着排出的热量越多。主频越高，问题越严重。
            
            在计算机主频上的无情竞争似乎已经结束，取而代之的是，Intel 设计将两个或更多个 CPU 放到一个芯片上，
            同时还包含大容量的共享高速缓存。
            
            Moore 定律将来保持有效的途径可能是芯片中设计更多的核和更大片的高速缓存，而是不越来越快的时钟速度。
            如何充分发挥多核优势给程序员提出了更大的挑战，现有的编程方法针对复杂的单核微体系结构而提高程序性
            能是有效的，但多核要求程序从全新的角度考虑编程，通过精心设计程序的并行执行、利用线程、信号量、共享内存
            以及令人头疼以及引入错误的技术来提高程序的性能。
        
        b. ARM 体系结构简介(ARM 公司 Advanced RISC Machines, 高级的 RISC 机器)：
            RISC(Reduced Instruction-Set Computer 精简指令集计算机)
            
            ARM 体系结构在移动市场上占据主导地位，大多数智能手机，平板电脑都是基于 ARM 处理器。
            
        c. AVR 体系简介（Atmel 公司）：
        
            主要用于非常低端的嵌入式系统中。
                
    1.5 公制计量单位：
    
        kb : 2^10 字节
        MB : 2^20
        GB : 2^30
        TB : 2^40
    
        1kbps : 通信线的传输速度是1000位/秒 10^3
        10Mbps: 局域网的速度是 10 000 000 位/秒 10^6
        Gbps 10^9  位/秒
        Tbps 10^12 位/秒       
           
    1.6 本书概览:
    
        本书详细讨论 数据逻辑层、微体系结构层、指令系统层和操作系统层。
        
        第二章：介绍计算机组件组成部分--处理器、存储器、输入/输出设备
        
        第三章：数字逻辑层，是真正的计算机
        
        第四章： 微体系结构层及其控制电路
        
        第五章：指令系统层
        
        第六章：操作系统层的一些指令、内存组织和控制机制。
        
        第七章：汇编语言层
        
        第八章：并行计算机
        
        
             
        


"-----------------------------------------------------------"

"-----------------------------------------------------------"

                        第二章 计算机系统组成

"-----------------------------------------------------------"

"-----------------------------------------------------------"
                                
                       第三章 数字逻辑层         

"-----------------------------------------------------------"


"-----------------------------------------------------------"

                      第四章 微体系结构层

"-----------------------------------------------------------"


"-----------------------------------------------------------"

                     第五章 指令系统层
                      
"-----------------------------------------------------------"

"-----------------------------------------------------------"

                    第六章 操作系统层
                    
"-----------------------------------------------------------"


"-----------------------------------------------------------"
                        
                   第七章 汇编语言层     

"-----------------------------------------------------------"

"-----------------------------------------------------------"
                
                    第八章 并行计算机系统结构            
    
"-----------------------------------------------------------"