"----------------------------------------------------------------------"

                本篇是学习极客时间陈皓专栏<左耳听风>学习笔记

"----------------------------------------------------------------------"

"""01: 程序员如何用技术实现变现(上) """

    1、写程序是一门"手艺活"，要不断锤炼自己的本领。
       要去经历大多数人经历不到的，要把学习时间花在那些比较困难的地方

    2、写文章就要写没有人写过的，或是别人写过，但我能写的更好的。

    3、更重要的是，技术和知识完全是可以变现的。

    4、25 ~ 35 是每个人最宝贵的时光，应该用在刀刃上。

    5、技术和技能保持领先，对技术本质和趋势保持敏感度。

"""02: 程序员如何实现技术变现（下）"""

    1、千里之行，积于跬步，功夫下在平时，时刻积累。

    2、关注有价值的东西，关注市场需求(每三个月更新一下简历)，
        关注技术趋势（一年学习一门新语言，将老技术本质吃透）
        学习技术的过程中一定问自己两个问题：
         （1） 这个技术解决什么问题？为什么同类技术做不到。
         （2） 为什么是这样解决问题，有没有更好的方式。
    3、找到能体现自己价值的地方。高速发展的公司或部门

    4、加强动手能力，不要光看，要去动手去实现，去体会其中的奥妙

    5、关注技术付费点：
        （1）一个是，能帮助别人"挣钱"的地方。
        （2）另一个是，能帮助别人"省钱"的地方。

    6、提升自己的能力和经历

    7、找到有价值的信息源
        向比自己高两级的人学习

    8、输出观点和价值观

    9、朋友圈很重要

    会挣钱的人一定是会投资的人，最宝贵的财富不是钱，而是你的时间，时间比钱
    跟宝贵，因为钱不用还在那里，而时间不用就浪费掉了。把你的时间投资在那些
    地方，意味着你未来会走什么样的路。所以，利用好你的时间，做有意义的事情。

"""03、04: 从 Equifax 信息泄露看数据安全 """

    1、数据库泄露攻击：

         (1)利用程序框架或库的已知漏洞，比如这次 Equifax 被攻击，就是通过
         Apache Struts 的已知漏洞。RSA 被攻击，也是利用 Adobe Flash 漏洞。

         (2)暴力破解密码。利用密码字典或已经泄露的密码来"撞库"

         (3)代码注入。通过程序员代码的安全性问题，如 SQL 注入， XSS 攻击，
             CSRF 攻击等取得用户的权限。

         (4) 利用程序日志不小心泄露的信息。

         (5) 社会工程学，员工的安全意识。

    2、数据管理上的问题

        （1）只有一层安全。Equifax 被黑客攻破了管理面板和数据库就造成泄露。

        （2）弱密码，不应该让用户设置如此简单的密码，而且要定期更换，最好
            通过数字证书、
            VPN（Virtual Private Network虛拟私人网络
            是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。
            虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内部网的网络讯息。
            它利用已加密的隧道协议（Tunneling Protocol）来达到保密、发送端认证、
            消息准确性等私人消息安全效果。）

            双因子验证的方式登录（双因子认证（2FA）是指结合密码以及实物（信用卡、SMS手机、令牌或指纹等生物标志）
            两种条件对用户进行认证的方法。）。

        （3）向公网暴露了内部系统。（公司网络管理出现问题）

        （4）对系统及时打安全补丁，监控业内的安全漏洞事件，及时做出响应。

        （5）安全日志被暴露。

        （6）保存了不必要保存的用户数据。（用户的信用卡、有效期、姓名和CVV码
             这些信息足矣让人在网上盗刷信用卡。其实对于临时支付来说，这些信息
             完全不必保存在磁盘上，临时在内存中处理完毕立刻销毁）

        （7） 密码没有合理的散列。散列目前公认为最安全的算法（SHA-2 256）
              二是加一个安全随机数作为盐（salt）

    3、专家建议：

        （1）理解你的软件产品中使用了那些支持性框架和库，它们的版本号，时刻
             跟踪这些产品的版本和安全声明。

        （2）建立一个流程，来快速地部署带有安全补丁的软件产品发布版，这样一旦需要
            因为安全方面的原因更新支持性框架或库，就可以快速发布。
            系统自动化测试机制

        （3）所有复杂的软件都有漏洞。不要基于"支持性软件产品没有安全性漏洞"
            的假设来建立安全策略。

        （4）建立多个安全层。在一个面向公网的表示层后面建立多级安全防护的层次，
            是一种良好的软件工程实践。及时表示层被攻破，后台资源也没有访问权。

        （5）针对公网资源，建立异常访问模式的监控机制。

    4、技术上安全做法：

        一个系统最好安全防范到自己内部员工都能防，把重要数据隔离出来，
        隔离到一个安全级别高的地方，这个地方需要各种安全审计、安全监控、
        安全访问。提供特殊接口，这能在区域操作能操作数据，而并不能把数据
        传出去。

        例如，用户手机号信息，如有外部系统需要手机号，一般是想发个短信，
        那么，这个掌管手机号数据系统就对外提供发短信功能，而外部通过
        UID或是被的抽象字段来调用这个系统的发短信API,信用卡也一样，
        提供信用卡的扣款 API,而不是把卡号返给外部系统。

        如果外部系统必须返回数据，一般来说，最终用户可能需要读取自己的数据
        那么像信用卡这样的安全数据死也不能返回，只能返回一个被"马赛克"的
        数据。

        而用户的加密算法一定采用非对称加密的方式，还要加上秘钥的自动更换。
        如，外部系统调用100次或是一个小时后自动更换秘钥。

        最后关键信息传到外部需要做通知，最后通知用户和管理员，并限制外部系统
        访问数量，超过需要报警或限制访问。

        安全还在于"风控"，把风险限制在一个很小的范围内，如果出现一些数据泄露
        可以通过"风险基金"来做业务补偿。

"""05: 何为技术领导力"""

    1、技术重要吗？

        一个公司或国家基本上可以总结为几个发展阶段
        （1）第一阶段：野蛮开采。资源太多，重业务，轻技术
        （2）第二阶段：资源整合。资源已经被不同的人占据，需要对资源整合优化
             提高利用率，这时通过管理手段就可以实现，重管理。
        （3）第三阶段：精耕自作。对第二阶段的精细化运作，并且通过科技手段达到
        （4）第四阶段：发明创造。资源匮乏，寻找替代资源，采用高科技手段实现。

        尊重技术的公司和不尊重技术的公司在初期还不能显现，而长期来看，差距就
        很明显。

    2、什么是技术领导力？

        技术领导力不仅仅是呈现出来的技术，而是一种可以获得绝对优势的技术能力。

        （1）尊重技术，追求核心基础技术。
        （2）追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。
        （3）解放生产力，追逐人效提高。
        （4）开发抽象和高质量的可以重用的技术组件。
        （4）坚持高于社会主流的技术标准和要求。

    3、如何拥有技术领导力？

        （1）能够发现问题。发现现有方案的问题。
        （2）能够提供解决问题的思路和方案，并能比较这些方案的优缺点
        （3）能够做出正确的技术决定。用什么样的技术，什么解决方案，怎样实现完成一个项目
        （4）能够用更优雅、更简单、更容易的方式来解决问题。
        （5）能够提高代码或软件的扩展性、重用性和可维护性。
        （6）能够用正确的方式管理团队。
        （7）创新能力

        在很多团队中，大多数人是提问题的，只有很少数人在回答这些问题，或提供解决
        问题的思路和方案。
        一句话，总是在提供解决问题的思路和方案的人才是有技术领导力的人。

    4、作为软件工程师，怎么让自己拥有技术领导力，4个方面：

        （1）扎实的基础技术。
        （2）非同一般的学习能力。
        （3）坚持做正确的事。
        （4）不断提高对自己的要求标准。

"""06: 如何才能拥有技术领导力 """

    1、吃透基础技术。基础技术是各种上层技术共同的基础。

       （1）基础知识越扎实，走的越远
       （2）计算机技术太多，你会发现只是表现形式太多，基础技术并不多，
            学好基础技术能让你一通百通。
       （3）很多分布式架构、高可用、高并发的解决方案都基本上都可以在基础
            技术上找到他们的身影，基础技术让你更好掌握高维度的技术。

       那些才是基础技术：具体来说分成两个部分：编程和系统
       很枯燥乏味，一定要克服人性的软点，努力啃完。

       编程部分：
            （1） C 语言：

                更好了解计算机怎么控制底层资源

            （2）编程范式：

                各种编程语言都有他们各自的编程范式，拥有解决各种问题，
                比如面向对象的编程（c++, java）、泛型编程
                （c++, Go, C#）、函数式编程（JavaScript、Python
                Lisp、Haskell、Erlang）

                学好编程范式，有助于你提高抽象思维，同时可以提高编程效率，
                提高程序的结构合理性、可读性和可维护性、降低代码冗余度
                提高代码运行效率。了解各种程序设计语言的功能特性。

            （3）算法和数据结构：

                算法（以及相关的数据结构）是程序设计的有力支撑，适当地应用
                算法，可以有效地抽象问题，提高程序合理性和执行效率。
                算法是编程中最重要的东西，也是计算机科学中最重要的基础。

       系统部分：

            （1）计算机系统原理：

                CPU 的系统结构（指令集[CISC/RISC]、分支预测、缓存结构、总线、
                DMA、中断、陷阱、多任务、虚拟内存、虚拟化等），内存的原理与
                性能特点（SRAM, DRAM, DDR-SDRAM等），磁盘原理（机械硬盘
                [盘面、磁头臂、磁头、启停区、寻道等]、固态硬盘[也映射、块的
                合并和回收算法，TRIM指令等]），GPU的原理等。

                书籍《深入理解计算机系统》（Randal E.Rryant）

            (2) 操作系统原理和基础：

                进程、进程管理、线程、线程调度、多核的缓存一致性、信号量、
                物理内存管理、虚拟内存管理、内存分配、文件系统、磁盘管理等。

                学习操作系统的价值在于理解程序是怎样被管理的，操作系统对应用
                程序提供了怎样的支持，抽象出怎样的编程接口（比如POSIX/Win32 API）
                性能如何，怎样进行进程间通信（如管道、套接字、内存映射等）

                要学习操作系统知识，一是要仔细观察和探索当前使用的操作系统，
                二是要阅读操作系统原理相关图书，三是要阅读API文档（如 man pages
                和 MSDN Library）并编写调用操作系统功能的程序。

                书籍《UNIX 环境高级编程》、《UNIX 网络编程》和《Windows 核心编程》

                学习操作系统基础原理的好处是，这是所有程序运行的物理世界，
                物理是上层像 c/c++ 这样编译成机器码的语言，还是像 Java 这样
                有 JVM 做中间层的语言，或者 Python/PHP/Perl/Node.js这样
                直接在运行时解释的语言，其在底层都逃离不了操作系统这个物理世界
                的"物理定律"

            (3) 网络基础：

                计算机网络是现代计算机不可或缺的一部分。需要了解基本的网络层次
                结构（ISO/OSI模型，TCP/IP协议栈），

                书籍 《TCP/IP 详解》

            (4) 数据库原理：

                数据库管理系统是管理书籍库的利器

                要学习数据库，可以阅读各类数据库图书，并多做数据库操作以及
                数据库编程，多观察数据库运行时的性能。

            (5) 分布式技术架构：

                数据库和应用程序服务器对互联网上数以万计的访问量的时候，需要
                能进行横向扩展，这样才能提高足够高的性能。

                要学习分布式技术架构，包括负载均衡、DNS解析、多子域名、无状态
                应用层、缓存层、数据库分片、容错和恢复机制、Paxos、Map/Reduce操作。
                分布式 SQL 数据库一致性等知识点。

                学习分布式技术的有效途径是参与到分布式项目开发中，并阅读相关论文。

       这些基础知识不可速成，需要在平时不断地体会学习，用一生来实践。

    2、 提高学习能力，所谓的学习能力，就是能够很快地学习新技术，又能在关键技术
        上深入的能力。

        下面是提升学习能力的一些做法：

         （1） 学习的信息源：

            好的信息源就可以更快地获取有价值的信息，提升学习效率。
            Google、Stack Overflow、Quora等社区，图书、API文档、论文、博客。

         （2） 与高手交流

         （3） 举一反三的思考

         （4） 不怕困难的态度

                如果你不怕困难，并可以找到解决困难的方法和路径，时间一长
                你就能够拥有别人不能拥有的能力。

         （4） 开发的心态

                带有开发的心态，不拘泥于一个平台，一种语言，往往能带来更多思考
                也能得到更爱好的结果。

    3、 坚持做正确的事，做正确的事，比用正确的方法做事更重要，因为这样才能始终向
        目的地靠拢。

        那些是正确的事：

        (1) 提高效率的事。

            管理好自己的时间

        (2) 自动化的事。

            编写程序来自动化操作

        (3) 掌握前沿技术的事，

            学习一门技术需要花费不少时间，要根据自己的选择，有的放矢的学习。

        (4) 知识密集型的事。

            知识密集型是相对于劳动密集型来说的

        (5) 技术驱动的事

    4、 高标准要求自己。

        只有不断地高标准，你才可能越走越高，要高标准要求自己，不断反思，
        不断总结和审视自己，提高自己。

        （1）Google 的自我评分卡。

        （2）敏锐的技术嗅觉。

        （3）强调实践，学以致用。

        （4） Lead by Example。

            永远在编程。

"""07：推荐阅读，每个程序员都该知道的知识"""

    1、每个程序员都应该读的书：

        （1） 代码大全

        （2） 程序员修炼之道

        （3） 计算机程序的构造和解释

        （4） 算法导论

        （5）设计模式

        （6）重构

        （7）人月神话

        （8）代码整洁之道

        （9）Effective c++/ More Effective c++

        （10） Unix 编程艺术、Unix 高级编程环境

    2、每个搞计算机专业的学生应有的知识

        （1）要获得一份好工作，学生需要知道什么
        （2）为了一辈子都有工作干，学生需要知道什么
        （3）学生知道什么，才能进入研究生院
        （4）学生需要之道什么，才能对社会有益

        计算机专业人士所需的硬技能：

            工程类数学、Unix哲学和实践、系统管理、程序设计语言、离散数学
            数据结构和算法、计算机体系结构、操作系统、网络、安全、密码学
            软件测试、用户体验、可视化、并行计算、软件工程、形式化方法、
            图形学、机器人、人工智能、机器学习、数据库等。

    3、 LinkedIn 高效的代码复查技巧：

        Code Review 很重要。

        LinkedIn 要求代码签入版本管理系统前，就对其做清晰的说明，以便于复查者
        了解其目的，促进 Review 的进行。
        对提交代码写说明文档。

    4、编程语言和代码质量的研究报告：

        （1） 从查看 bug fix 的 commits 的次数情况来看，C、C++、
              Objective-C、PHP、Python 中的很多很多的 commits 都是
              和 bug fix 相关的。

        （2）函数式编程语言的 bug 明显比大多数其他语言要好很多。

        （3）bug 数和软件的领域没有关系。

        （4）bug 的类型和语言是强相关性


    5、电子书：

        《C++ 软件性能优化》


"""08: Go 语言，Docker 和新技术"""

    1、 问题

        为什么Go 语言和 Docker 会是新一代云计算技术
        作为技术人员，如何识别什么样的新技术会是未来的趋势

    2、go 语言的体会

        （1） 语言简单，上手快

        （2）并行和异步编程几乎无痛点

        （3）Go 语言的lib 库，麻雀虽小，五脏俱全

        （4）C 原因的理念和Python的姿态

            C 原因的理念是信息信任程序员，保持语言的小巧，不屏蔽底层且对底层友好
            关注语言的执行效率和性能
            Python 的姿态是用尽量少的代码完成尽量多的事。

    3、一个技术能不能发展起来，关键看三点：

        （1） 有没有一个比较好的社区

        （2）有没有工业化的标准

        （3）有没有一个或多个杀手级应用

         还有一些影响因素：

         （4） 学习难度是否底，上手是否快

         （5） 有没有一个不错的提高开发效率的开发框架

         （6）是否有一个或多个巨型的技术型公司作为后盾

         （7）有没有解决软件开发中的痛点

    4、用这些标准来衡量 Go 语言

        Go 语言容易上手
        Go 语言解决了并行编程和底层应用开发效率的痛点
        Go 语言有Google 这个世界一流的技术公司在后面
        Go 语言的杀手级应用是 Docker 容器。

        Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到上层如 Java
        业务层的项目。Go语言会吞食一定是 PaaS 上的项目，比如一些消息缓存中间件
        服务发现、服务代理、控制系统、Agent、日志收集等，他们没有复杂的业务场景
        也到不了特别底层（操作系统）的软件项目或工具。而 C 和 C++ 会被打倒
        更底层，Java会被打倒更上的业务层。


    5、Docker：

        Docker 一定会是未来的就技术，Kubernetes 作为服务和容器调度器的关键技术
        一定会是未来的赢家。

    6、PaaS：

        PaaS是Platform-as-a-Service的缩写，
        意思是平台即服务。 把服务器平台作为一种服务提供的商业模式。
        是一个被世界或是被产业严重低估的平台。

        PaaS 层的技术主要能解决下面问题：

        （1）软件生成线问题:
            持续集成和持续发布，以及 DevOps 中的技术必须通过 PaaS

        （2）分布式服务化的问题。

         (3) 提高服务的可用性 SLA

         (4) 软件能力的复用

    这些关键新技术，可以让你提前抢占技术的先机。


"""09: 答疑解惑 渴望、热情和选择"""

    1、三个问题：
        （1） 加班太严重完全没有时间学习，怎么办？
        （2） 为什么你能写出那么多东西？
        （3） 怎么选择自己的人生和职业发展？

    2、没有时间学习的问题

        关键看你对学习有多少的渴望程度，对学习的东西有多大的热情。
        学习是一件反人性的事，反人性的事要付出很多，还要坚持很久。

    3、为什么能够写那么多东西

        第一个阶段，是学习阶段

        第二个阶段，是有利益驱动的阶段

        第三个阶段，是记录自己观点打自己脸的阶段

        第四个阶段，是与他人交换的阶段

    4、怎么选择自己的人生和直接规划

        （1）20 ~ 30 岁 是打基础的阶段

            开阔眼界，把基础打牢固，努力学习和成长

        （2）30 ~ 40 人生的发展阶段

            明确自己的奋斗目标，干有挑战的事，提升自己技术领导力

    5、一些建议：

        （1） 客观的审视自己
              如果你超过身边大多数人，不妨选择的激进一些，否则，还是按部就班的来

        （2） 确定自己想要什么

            所谓"极端"，就是自己不会受到其他东西或其他人的 影响，不会因为这条路上
            有人退出你就开始疑惑或者迷茫，也不会因为别人成功你就羡慕。

        （3） 注重长期的可能性，而不是短期的功利。

        （4） 尽量关注自己会得到的东西，而不是自己会失去的东西

        （5）不要和大众的思维方式一样。

        很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度
        的受到思考问题的出发点、思维方式、格局观、价值观等因素影响。


"""10: 如何成为一个大家愿意追随的 Leader"""

    1、Leader(技术领导者)

       BOSS:             VS    　　Leader

        驱动员工                    指导员工
        制造畏惧                    制造热情
        面对错误喜欢使用人事惩罚     面对错误喜欢寻找解决问题的技术和管理方法
        知道怎么做                  展示怎么做
        用人                        发展人
        从团队收割成绩              给予团队成绩
        喜欢命令和控制              喜欢沟通和协作
        喜欢说"给我上"              喜欢说"跟我上"

    2、如何成为众人愿意追随的 Leader

        (1) 帮人解决问题

        (2) 被人依赖

        (3) Leader 除了技术领导力之外还有其他素质和人格魅力。

        (4) 赢得他人信任

        (5) 开发的心态和倾向性的价值观

        (6) Lead by Example

        (7) 保持热情和冲动

            正视问题，正视不足、正视错误，不怕困难，迎难而上。

        (8) 能够抓住重点，看透实物的本质。

        (9) 描绘令人激动的方向，提供令人向往的环境

        (10) 甘当铺路石，为他人创造机会

"""11:程序中的错误处理：错误返回码和异常捕捉""""

    1、传统的错误检查：
    
        处理错误最直接的方式是通过错误码，这也是传统方式，在过程式语言中通常都是用
        这样的方式处理错误的。比如 c 语言基本上来说，其通过函数返回值标识是否有错，
        然后通过全局的 errno 变量并配合一个 errstr 的数组来告诉你为什么出错。
        
        为什么是这样的设计？道理很简单，除了可以共用一些错误，更重要的时这其实是一种
        妥协。比如 read()、write()、open()这些函数的返回值其实是返回的有业务逻辑的值。
        也就是说，这些函数的返回值有两种含义，一种是成功的值，比如 open() 返回的文件句柄
        指针 FIFE*，或是错误 NULL。这样会导致调用者并不知道是什么原因出错了，需要去检查
        errno 来获取出错的原因，从而可以正确的处理错误。
        
        使用 返回值 + errno 的错误检查方式会有一些问题:
        
            (1) 程序员不小心就会忘记返回值的检查，从而造成代码的Bug;
            (2) 函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。
            
    2、多返回值：
    
        有一些语言通过多返回值的来解决上面的问题，比如 Go 语言。Go 语言的很多函数都返回
        result，err 两个值。于是：
        
            (1) 参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰。
            
            (2) 而且，Go 语言中的错误参数如果要忽略，需要显示的忽略，用 _ 这样的变量来忽略。
            
            (3) 另外，因为返回的 error 是个接口（其中只有一个方法 Error()）,返回一个 string
                所以你可以扩展自定义的错误处理。
                
            但即使像 Go 这样的语言能让错误处理语义更清楚，而且还有可扩展性，也有问题。
            如果写一段 Go 语言，你就会明白其中的痛苦---if err != nil 这样的语句简直
            是写到吐。
    
    3、资源清理：
    
        程序出错时需要对已分配的一些资源做清理，在传统的玩法下，每一步的错误都要去清理前面
        已经分配好的资源，于是就出现了 go to fail 这样的错误处理模式。
        
            # define FREE(P) if (p){free(p); p=NULL}
            mian()
            {
                char *fname = NULL;
                fname = (char *)calloc(20, sizeof(char));
                if(fname == NULL)
                {
                    goto fail;
                }
             
            fail:
                FREE(fname);   
                ReportError(ERR_NO_MEMORY)
            }
            
        这样的处理方式虽然可以，但是会有潜质的问题，主要的一个问题就是你不能在中间的代码中
        有 return 语句，因为你需要清理资源，在维护这样的代码是需要格外的小心，容易造成内容泄露。
        
        于是， C++ 的 RALL(Resource Acquisition Is Initialization) 机制使用面向对象的特性
        可以容易处理这个事情。RALL 其实使用 C++ 类的机制，在构造函数中分配资源，在析构函数中
        释放资源。
        
        在 Go 语言中，使用 defer 关键字也可以做到这样的效果。
        
    4、异常捕获处理：
    
        上面，我们讲了错误检查和程序出错之后资源的清理着两个事，能把这个事做的比较好的其实是
         try -- catch -- finally 这个编程模式。
         
            try {
                    ... // 正常业务代码
            } catch (Exception1 e ){
                    ... // 处理异常 Exception1 的代码
            } catch (Exception2 e){
                    ... // 处理异常 Exception2 的代码
            } finally{
                ... // 资源清理的代码
            }
        
         
         try - catch - finally 这样的异常处理方式有如下的好处：
         
            （1） 函数接口在 input(参数) 和 output(返回值) 以及错误处理的语义是比较清楚的。
            
            （2） 正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。
            
            （3） 异常不能被忽略（如何要忽略也需要 catch 住，这是显示忽略） 
            
            （4） 在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。
            
            （5） 与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。
                            
            当然，你可能觉得异常捕捉对性能有影响，这句话对也不多，原因是这样的。
            
            （1） 异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着 return 了。
                 而程序在执行时需要处理函数栈的上下文，这会导致性能变得很慢，尤其是函数栈比较
                 深的时候。
                 
            （2） 但从另一个方面来说，异常的抛出基本上情况表明程序的错误，程序在绝大多数情况下，应该是
                 在没有异常的情况下运行的，所以，有异常的情况应该是少数情况，不会影响正常处理的性能问题。
            
            总体而言，我还是觉得 try -- catch -- finally 这样的方式很不错，而且比返回错误码有诸多好处。
            但是，它有一个致命的问题，那就是在异步运行的世界里的问题。try 语句块里的函数运行在另外一个
            线程中，其中抛出的异常无法在调用者这个线程中被捕捉。这个问题就比较大。
            
    5、 错误返回码 VS 异常捕获
    
        前面也比较了两者的优缺点，总体而言，似乎异常捕捉的优势更多一些，但是，我觉得应该从场景
        上来讨论这个事才是正确的姿态。
        
        要讨论场景，我们需要把错误分好类别，错误可以分为三个大类：
        
        （1） 资源错误： 
        
            当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的问题，写文件时出现错误，
            发送文件到网络端发现网络故障错误，等等。这一类错误属于程序运行环境的问题。对于这类错误
            有些我们能处理，有些我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源
            不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。 
            
        （2） 程序的错误：
        
            比如：空指针、非法参数等。这类是我们自己程序的错误，我们要记录下来，写入日志，最好
            触发监控系统报警。
            
        （3） 用户的错误：
        
            比如：Bad Request、Bad Format 等这类由用户的API层上出现的问题，比如，解析一个xml或
            Json 文件，或是用户输入的字段不合法之类的。
            
            对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常
            执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。
        
        我们可以看到，这三类错误，有些是我们希望杜绝发生的，比如程序中的 Bug, 有则是我们杜绝不了的
        比如用户输入。而对于程序运行环境的错误，我们希望可以恢复。也就是说，我们希望可以通过重试或者
        妥协的方式来解决这些环境问题，比如重建网络连接，重新打开一个新的文件。
            
            所以，是不是我们可以这样来在逻辑上分类：
            （1）对于我们并不期望会发生的事，我们可以使用异常捕捉。
            （2）对于我们觉得可能会发生的事，使用返回码。
            
            比如，如果你的函数参数输入的对象不应该是一个 null 对象，那么一旦传入 null 对象后，
            函数就可以抛异常，因为我们不期望发生这样的事。
            
            而对于需要检查用户输入信息是否正确的事，比如：电子邮箱的格式，我们用返回码可能比较好一些。
            除了用错误分类来判断是否是使用返回码还是用异常捕捉之外，我们还要从程序设计的角度来考虑
            那种情况下使用异常捕捉更好，那种情况下使用返回码更好。
            
            在某些情况下，你只能使用其中的一个，比如：
            
                （1）在 C++ 重载操作符的情况下，你就很难使用错误返回码，只能抛异常。
                
                （2）异常捕捉只能在同步的情况下使用，在异步模式下，抛异常这事就不行，需要通过检查
                    子进程的退出码或是回调函数来解决。
                    
                （3）在分布式的情况下，调用远程服务只能看错误返回码，比如 HTTP 的返回码。
            
    总之，"报错类型" 和 "错误处理" 是紧密相连的，错误处理方法多种多样，而且会在不同的层面上处理错误。
    使用错误码还是异常捕捉主要还是看我们的错误处理流程以及代码组织怎样写会更清楚。
    
    
"""12: 程序中的错误处理：异常编程以及我的最佳实践"""      

    1、异步编程世界里的错误处理：
        
        在异步编程的世界里，因为被调用的函数是被放到了另外一个线程里运行，这将导致：
            
            （1）无法使用返回码。
                因为函数在"被"异步运行中，所谓的返回只是把处理权交给下一条指令，而是不是
                把函数运行完的结果返回，所以，函数返回的语义完全变了，返回码也没有什么用。
                
            （2）无法使用抛异常的方式。
            
                不同线程中的栈是完全不一样的，所以主线程中的 catch 完全看不到另外一个线程的异常。
                
        对此，在异步编程的世界里，我们也会有好几种处理错误的方法。最常用的就是 callback 方式，
        在做异步请求的时候，注册几个 OnSuccess()、OnFailure() 这样的函数，让另一个线程中运行
        的异步代码来回调过来。
        
    2、 JavaScript 异步编程的处理错误: 
    
        function successCallback(result){
            console.log("It successed with" + result);  
        }
        
        function failureCalllback(error){
        
            console.log("It failed with" + error);
        }
        
        doSomething(successCallback, failureCallback);
        
        通过注册错误处理的回调函数，让异步执行的函数在出错的时候，调用被注册进来的错误处理函数，
        这样的方式比较好地解决了程序的错误处理。而出错的语义从返回码，异常捕捉到了之间耦合错误
        处理函数的样子。
        
        但是，如果我们需要把几个异步函数执行顺序的话，就会出现所谓的 Callback Hell 的问题：
        
            doSomething(function(result)){
                doSomethingEls(result, function(newResult)){
                    doThridThing(newresult,function(finalResult)){
                        console.log('Got the final result:' + finalResult);
                    },failureCallback);
                },failureCallback);
            },failureCallback);
        
        这样层层嵌套中需要注册的错误处理函数也有可能完全不一样，导致代码混乱，难理解，难阅读。
        
    3、一般来说，在异步编程的实践里，我们会用 Promise 模式来处理。如下（箭头表达式）
    
        doSomething()
        .then(result => doSomethingElse(result))
        .then(newResult => doThreadThing(newResult))
        .then(finalResult => {
            console.log(`Got the final result: ${fianlResult}`);
        }).catch(failureCallback);
        
        上面代码中的 then() 和 catch() 方法就是 Promise 对象的方法， then() 方法可以
        把各个异步的函数给串联起来，而catch() 方法则是出错的处理。
        
        上面是级联式的调用方式，这就要我们的doSomething() 函数返回Promise 对象，下面这个
        函数相关代码示例：
        
            function doSomethin(){
                let promise = new Promise();
                let xhr = new XMLHttpRequest();
                xhr.open('GET','http:..',true);
                
                xhr.onload = function(e){
                if (this.status === 200){
                    results = JSON.parse(this.responseText);
                    promise.resolve(result); //成功时，调用 resolve() 方法
                }
                }；
                
                xhr.onerror = function(e){
                    promise.reject(e); //失败时，调用 reject() 方法。
                }; 
                
                xhr.send();
                return promise;
            }    
        
    
    4、错误处理的最佳实践：
    
        （1）统一分类的错误字典：
            无论你是使用错误码，还是异常捕捉，都需要认证统一做好错误分类。如HTTP的4XX表示客户端，5XX表示服务器。
        
        （2）同类的定义最好是可以扩展的。
            方便代码重用
         
        （3）定义错误的严重程度：
            Fatal: 重大错误
            Error: 资源或需求不满足
            Warning: 不一定是错误但是要注意
            Info: 不是错误只是一个信息
            Debug: 内存开发人员用于调试程序的。
            
        （4）错误日志的输出最好使用错误码，而不是错误信息
            打印错误日志的时候，应该使用统一的格式。这样有利于日志分析软件进行监控。
            
        （5）忽略错误最好有日志
        
        （6）对于同一个地方不停的报错，最好不要都打到日志里。
            这样导致其他日志被淹没，也会导致日志文件太大，最好实践是，打出一个错误以及出现的次数。
            
        （7）不要用错误处理逻辑来处理业务逻辑：
            也就是说，不要用异常捕捉这样的方式来处理业务逻辑，而应该用条件判断。
            异常捕捉用来处理不期望发生的事情，而错误码则用来处理可能会发生的事情。
            
        （8）对于同类的错误处理，用一样的模式。
        
        （9）尽可能在错误发生的地方处理错误
        
        （10）向上尽可能地返回原始的错误。
        
        （11）处理错误时，总是要清理已分配的资源
        
        （12）不推荐在循环体里处理错误
                try..catch 放在循环体外
                
        （13）不要把大量的代码放在同一个 try 语句块内
        
        （14）为你的错误定义提供清楚的文档以及每种错误的代码示例
        
        （15）对于异步的方式，推荐使用 Promise 模式处理错误。
        
        （16）对于分布式的系统，推荐使用 APM 相关的软件。
            
           
"""魔数 0x5f3759df"""

    《神雷之锤 3 竞技场》 源代码的一个函数(已经剥离了 C 语言预处理器的指令)
    
        float Q_rsqrt(float number)
        {
            long i;
            float x2, y;
            const float threehalfs = 1.5F;
            
            x2 = number * 0.5F;
            y = number;
            i = *(long *) &y; //evil floating point bit level hacking
            i = 0x5f3759df - (i >> 1); //what the fuck
            y = *(float *) &i;
            y = y *(threehalfs - ( x2 * y * y));
            return y; 
            
        
        }


"""14 推荐阅读：机器学习 101"""

    机器学习分两种方法，监督式学习（Supervised Learning）和非监督（Unsupervised Learning）.
    
    1、监督式学习：
    
        
    2、非监督式学习：
    
    
"""15 时间管理：同扭曲时间的事抗争"""

    1、主动管理：
    
        化被动为主动，你要主动管理的不是你的时间，而是管理你的同事，管理你的信息。
        
        
    2、学会说“不”：
        
        （1）当你面对做不到的需求时，你不能说这个需求做不到，要给出另一个你可以做到的方案，
            而不是把对方的方案直接回绝掉。
        
        （2）当你面对一个过于复杂的需求时，我不说不能完成满足你，但我说我可以部分满足你。
        
        （3）当你面对时间不够的需求时，也不要说不，你可以有三个选择：
            a. 我可以加班加点完成，我不保证质量。
            b. 我可以加班加点完成，保证质量，但需求能不能减少点。
            c. 我可以保质保量完成，但时间能不能多给2周。
            
            我不能说不，但是我要有条件的说，而且，我还有把压力再反过去给你。
            要积极主动的对不合理的事情讨价还价。
            
    3、加班和开会：
    
        开会不要讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。
        
"""16 时间管理：如何利用好自己的时间"""

    1、投资自己的时间：
    
        a. 花时间学习基础知识，花时间读文档。
        
        b. 花时间解放自己生产力的事情上。
        
        c. 花时间在让自己成长的事上。
        
        d. 花时间在建立高效的环境上。
        
    2、规划自己时间：
    
        a. 定义好优先级
        
        b. 最短作业优先
        
        c. 想清楚再做
        
        d. 关注长期利益规划
        
    3、用好自己的时间：
    
        a. 将军赶路不追小兔子
        
        b. 形成习惯
        
        c. 形成正反馈
        
        d. 反思和举一反三
        
"""17: 故障处理最佳实践 应对故障"""

    1、故障源团队通常会有一下几个手段来恢复系统：
    
        a. 重启和限流：
            
            重启和限流主要解决可用性的问题，而不是功能性的问题。
            
        b. 回滚操作：
        
            回滚操作一般说是解决新代码的bug.
            
        c. 降级操作：
        
            需要挂一个停服务的故障公告，主要是不把事态扩大。
            
        d. 紧急更新：
        
        出故障时，最重要的不是 debug 故障，而是尽可能地减少故障影响范围，并尽可能修复问题。
        
    2、故障前的准备工作：
    
        a. 以用户功能为索引的服务和资源的全视图。
        
        b. 为地图中的各个服务指定关键指标，以及一套运维流程和工具，包括应急方案。
        
        c. 设定故障等级
        
        d. 故障演练
        
        e. 灰度发布系统
        
"""18 故障处理最佳实践： 故障改进"""

    1、故障复盘过程：
    
        a. 故障处理的整个过程。
        
            就像log一样，需要详细记录几点几分干了什么事，把故障从发生到解决所有细节记录下来。
        
        b. 故障原因分析。
               
        c. Ask 5 Whys。
        
            需要反思并反问至少 5 个为什么
        
        d. 故障后续整改计划。
            
            需要针对上述的“Ask 5 Why”说明后续如何举一反三从根本解决所有问题。
            
    2、故障整改方法：
    
        a. 优化故障获知和故障定位的时间:
        
            从故障发生到我们知道的时间是否可以优化的更短？
            定位故障的时间是否可以更短？
            有哪些地方可以做到自动化？
            
        b. 优化故障的处理方式:
             
            故障处理时的判断和章法是否科学，是否正确？
            故障处理时的信息是否全透明？
            故障处理时人员是否安排得当？
                        
        c. 优化开发过程中的问题：
        
            Code Review 和测试中的问题和优化点
            软件架构和设计是否可以更好
            对于技术欠债或是相关的隐患问题是否被记录下来，是否有风险计划
        
        d. 优化团队能力：     
        
            如何提高团队的技术能力。
            如果让团队有严谨的工程意识。
            
    3、根除问题的本质：
    
        一个技术问题，后面隐藏的是工程能力问题，工程能力问题的后面隐藏的是管理问题，
        管理问题的后面隐藏的是一个公司文化的问题，公司文化问题后面隐藏的着创始人的问题...
        
        a. 举一反三解决当下的故障。为字节赢得更多的时间。
        
        b. 简化复杂、不合理的技术架构、流程和组织。
            你不可能在一个复杂的环境下根据地解决问题。
            
        c. 全面改善和优化整个系统、包括组织。
            解决问题的根本方法是改善和调整整个结构。而只有简单优雅的东西才有被改善和优化的可能。
            
            
"""19 答疑解惑：我们应该能够识别的表象和本质"""

    1、 关于兴趣和投入：
    
        兴趣是学习的助燃剂，对一件事有兴趣是是否愿意对这件事投入更多时间或者资源的前提条件。
        a. 一方面，兴趣是需要保持的
        b. 另一方面，兴趣其实也是可以培养出来的。
        
        兴趣只是开始，而能让人不断投入时间和精力的则是正反馈，是成就感。
        
        你需要找到让自己能够更有成就感的事情，兴趣总是可以培养出来的。
        
    2、关于学习和工作：
    
        本质上来说，并不是只有找到了相应的工作我们才可以学好一项技术，而是，我们在通过解决实际问题
        在与他人讨论，获得高手帮助的环境中，才能更快更有效的学习和成长。工作不过是提供了一个能够解决
        实际问题、能够与人讨论，有高手帮助的环境。
        
        总之，找到学习的方法，提升自己对新事物学习的能力，才是学习和成长的关键。
        
    3、关于技术和价值：
    
        要用技术解决什么样的问题，场景非常重要；
        如何降低技术的学习成本，提高易用性，从而可以让技术更普及。
        
        基础技术总是枯燥和有价值的。数学、算法、网络和存储等基础知识吃得越透，就越容易服务上层的各种衍生技术或产品。
        支持规模化的技术也是有价值的，在软件行业中，也就是 PaaS 的相关技术。
        
        
"""20 Git 协同工作流，你该怎么选"""

    1、Git:
  
        Git 是一个分布式版本管理工具，而且可以是单机版的，Git 衍生出来的 GitHub/GitLab 可以
        帮助你很好的管理编程工作。GitHub/GitLab 这样工具的出现，让我们的工作可以呈现在一个工作
        平台上，并以此来规范整个团队的工作。
        
        注意：Git 是一个分布式的代码管理器，所以，是分布式就会出现数据不一致的情况，因此，我们需要
        一个协同工作流来让工作变得高效，同时可以有效的让代码具有更好的一致性。
        
    2、中心式协同工作流：
    
        首先，Git 是可以像 SVN 这样的中心工作流一样工作的。这个过程一般是下面这个样子：
        
            a. 从服务器上做 git pull origin master 把代码同步下来。
            
            b. 改完之后，git commit 到本地仓库中。
            
            c. 然后 git push origin master 到远程仓库中，这样其他同学就可以得到你的代码了。
            
        如果 push 失败，发现别人已经提交了，那么你需要先把服务器上的代码 pull 下来，为了避免
        有 merge 动作，你可以使用 Git pull --rebase。 这样就可以把服务器上的提交直接合并到
        你的代码中，对此，Git 的操作是这样的：
        
            a. 先把你本地提交的代码放到一边。
            
            b. 然后把服务器上的改动下载下来。
            
            c. 然后在本地把你之前的改动再从新一个一个地做commit,直到全部成功。
                
    3、功能分支协同工作流：
    
        上面那种方式有一个问题，就是大家都在一个主干上开发程序，对于小团队或是小项目可以这么做，
        但是较大的项目或是人比较多的团队，这样做就会有很多问题。
        
        最大的问题就是代码可能干扰太严重，这时，我们不想让各功能开发人员都在 Master 分支上共享
        他们的代码。我们就需要协调这种方式：同时开发一个功能的开发人员可以分享各自的代码，但是不能
        把代码分享给开发其他功能的开发人员，直到整个功能开发完毕后，才会分享给其他的开发人员（也就是进入主干分支）。
        
        因此，我们引入“功能分支”。这个协调工作流的开发过程如下：
        
            a. 首先使用 git checkout -b new-featrure 创建 “new-feature”分支。
            
            b. 然后共同开发这个功能的程序员在这个分支上工作，进行 add、commit 等操作。
            
            c. 然后通过 git push -u origin new-feature 把分支代码 push 到服务器上。
            
            d. 其他程序员可以通过 git pull --rebase 来拿到最新的这个分支的代码。
            
            e. 最后通过 Pull Request 的方式做完 Code Review 后合并到 Master 分支上。
            
        其实，这种开发也是以服务器未中心的开发，还不是 Git 分布式开发，它只不过是用分支来完成代码改动的隔离。
        
        为什么叫“功能分支”，而不是“项目分支”，因为 git 的最佳实践希望大家在开发过程中，快速提交，快速合并，
        快速完成。这样可以减少很多冲突的事，所以叫功能分支。
        
    4、GitFlow 协同工作流：
    
        在真实的生成过程中，前面的协同工作流还是不能满足工作的要求，主要是因为我们的生产过程是比较复杂的，
        软件生成中会有各式各样的问题，并面对不同的环境，我们要不停的开发新代码的同时，维护线上代码，于是，
        就有了下面这些需求：
        
            a. 希望有一个分支是非常干净的，上面的可以发布的代码，上面的改动永远都是可以发布到生产
                环境中的。这个分支不能有中间开发过程中不可以上生产线的代码提交。
                
            b. 希望当代码达到可以上线的状态时，也就是在 alpha/beta release 时，在测试和交付的过程中，
                依然可以开发下一个版本的代码。
                
            c. 最后，对于已经发布的代码，也会有一些 bug-fix 改动，不会将正在开发的代码提交到生产线上去。
            
        为了解决这个问题，GitFlow 协同工作流就出来了，这个协同工作流的核心思想如下：    
        整个代码库中一共有五种分支：
            
            a. Master 分支，也就是主干分支，用作发布环境，上面的每一次提交都是可以发布的。
            
            b. Feature 分支， 也就是功能分支，用于开发功能，对应的是开发环境。
            
            c. Developer 分支，一旦功能开发完成，就像 Developer 分支合并，合并完成之后，
                删除功能分支，这个分支对应的是集成测试环境。
                
            d. Release 分支，当 Developer 分支测试达到可以发布的状态时，开出一个 Release 分支来，
                然后做发布前的准备工作。这个分支对应的是预发布环境。之所以需要这个 Release 分支，是
                我们的开发可以继续向前，不会因为要发布而被 block 住而不能提交。
                
                一旦 Release 分支上的代码达到可以上线的状态，那么需要把 Release 分支向 Master 分支和
                Developer 分支同时合并，以保证代码的一致性。然后再把 Release 分支删除。
                
            e. Hotfix 分支。是用于处理生产线上代码的 Bug-fix，每个线上的代码的 Bug- fix 都需要开一个Hotfix分支
                完成后，向Developer 分支和 Master 分支上合并，合并完成之后，删除 Hotfix 分支。
                
        这样就是整个 GitFlow 协同工作流的工作过程，我们可以看到：
        
            a. 我们需要长期维护 Master 和 Developer 两个分支。
            
            b. 这其中的方式还是有一定的复杂度的，尤其是 Release 和 Hotfix 分支需要同时向两个分支做合并。
                如果没有好的工具来支撑，我们可能会忘记了一些操作而导致代码不一致。
                
            c. GitFlow 协同虽然工作比较重，但是它几乎可以应对所有公司的各种开发流程，包括瀑布模型和快速迭代模型。
            
        对于 Gitflow 工作流来说，虽然可以解决问题，但是也有很多问题，其中有个问题就是因为分支太多，出现
        git log 混乱局面。具体来说，主要是gitflow 使用了git merge --no-ff 来合并分支，在git-flow 这样
        多分支的环境下让你的分支管理的log 边得很难看。
        
        所谓的 --no-ff 参数意思是--no fast forward 的意思。也就是说，合并的方法不要把这个分支的提交
        以前置合并的方式，而是留下一个 merge 的提交。
        
    5、GitHub Flow:
    
        所谓的 GitHub Flow, 其实也叫 Forking flow， 也就是 GitHub 上的那个开发方式。 
            
            a. 所有的开发人员都把 “官方库” 的代码 fork 到自己代码创库中。
            
            b. 然后，开发人员在自己的代码仓库中做开发，想干啥干啥。
            
            c. 因此，开发人员的代码库中，需要配两个远程创库，一个是自己的库，一个是官方库
                （用户的库用于提交代码改动，官方库用于同步代码）。
                
            d. 然后在本机建 “功能分支”，在这个分支上做代码开发。
            
            e. 这个功能分支被 push 到开发人员自己的代码创库中。
            
            f. 然后，向“官方库”发起 pull request，并做 Code Reivew.
            
            g. 一旦通过，就向官方库进行合并。
           
        这就是 GitHub 的工作流程。
       
    6、GitLab Flow：
        
        GitHub Flow 这种玩法依然有很多问题，因为其虽然变得很简单，但是没有把我们的代码和我们
        的运行环境给联系在一起。所以，GitLab 提出了几点优化点。
        
        其中一个是引入环境分支，其包含了预发布（Pre-Production）和生产（Production）分支。
        而又时候，我们还会有不同版本的发布，所以还需要有各种 release 的分支。
        
        这样也就解决了两个问题：
        
            环境和代码分支对应的问题
            版本和代码分支对应的问题        
    
    7、协同工作流的本质：
        
        团队协同工作的本质不外乎几个事：
            
            a. 不同的团队能够尽可能地并行开发。
            
            b. 不同软件版本和代码的一致性
            
            c. 不同环境和代码的一致性
            
            d. 代码总是会在稳定和不稳定间交替，我们希望生产线上的代码总是能对应到稳定的代码上来。
            
        协同的工作本质并不是怎样玩好创库的分支策略，而是玩好我们软件架构和软件开发流程。
        
        与其花时间在 Git 协同工作流上，还不如把时间花在调整软件架构和自动化软件生成和运维流程上来，
        这才是真正简化协同工作流程的根本。


"""21 分布式系统架构的冰与火"""

    1、使用分布式系统主要有两个方面的原因：
    
        a. 增大系统容量：
            
            一台机器性能无法满足，需要多台机器应对大规模应用场景。
            我们需要垂直或是水平拆分业务系统，让其变成一个分布式的架构。
            
        b. 加强系统可用：
            
            业务越来越重要，需要提高整个系统架构的可用性，不能存在单点故障，
            需要通过分布式架构来冗余系统以消除单点故障，从而提高系统的可用性。
        
        c. 分布式系统一下其他优势：
            
            因为模块化，所以系统模块重用度更高
            因为软件服务模块被拆分，开发和发布速度可以并行而变得更快。
            系统扩展性更高
            团队协作流程也会得到改善    
            等等。。。
        
    2、分布式系统存在的一些问题：
    
        a. 架构设计变得复杂（尤其是其中的分布式事务）。
        
        b. 部署单个服务会比较快，但是如果一次部署需要多个服务，流程会变得复杂。
        
        c. 系统的吞吐量会变大，但是响应时间会变长。    
        
        d. 运维复杂度会因为服务变多而变得很复杂
        
        e. 架构复杂导致学习曲线变大
        
        f. 测试和排错的复杂度增大
        
        g. 技术多元化，带来维护和运维的复杂度。
        
        h. 管理分布式系统中的服务和调度变得困难和复杂。
        
        也就是说，分布式架构的难点在于系统设计，以及管理和运维。
        
    2、分布式系统的发展：
        
        20 世纪 70 年代 模块化编程
        20 世纪 80 年代 面向事件设计
        20 世纪 90 年代 基于接口/架构设计。
        慢慢演化出了 SOA -- 基于服务的架构。 
            
        SOA 架构是构造分布式计算应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。
        它采用开发标准与软件资源进行交互，并采用标准的表达方式。
        
        开发、维护和使用 SOA 要遵循一下几条基本原则：
            a. 可重用，粒度合适、模块化、可组合、构件化以及有互操作性。
    
            b. 符合开放标准（通用的或行业的）
            
            c. 服务的识别和分类，提供和发布，监控和跟踪。
            
    3、面向服务的架构：
    
        面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，
        并通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，
        它应该独立于实现服务的硬件平台、操作系统和编程语言。
        这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。
    
        面向服务的架构有以下三个阶段：
        
            20世纪90年代前是单体架构，软件模块高度耦合。
            
            2000年左右出现了比较松耦合的 SOA 架构，这个结构需要一个标准的协议或是中间件来联动与他相关的服务。
            服务间并不相互依赖，而是通过中间件的标准协议或通讯框架相互依赖。其实就是IoC（控制反转）和 DIP(依赖导致原则)
            设计思想和架构中的实践。
            
            2010年后出现了微服务架构，这个架构更加松耦合，每个服务都能够独立完整的运行（所谓的自包含），
            后端单体的数据库也被微服务这样的架构分散到不同的服务中。
            它和传统的 SOA 的差别在于，服务间的整合需要一个服务编排或是服务整合引擎。就像交响乐需要一个指挥
            把所有乐器编排和组织在一起。
            
        一般来说，这个编排和组织引擎可以是工作流引擎，也可以是网关。当然，还需要辅助与像容器化调度这样的技术方式如Kubernetes。
    
    4、微服务：
        
        微服务的出现使得开发速度变得更快、部署快、隔离性高、系统扩展性也很好、但是在集成测试、运维和服务管理
        等方面就比较麻烦。所以需要一个比较好的微服务 PaaS（Platform-as-a-Service：平台即服务）平台。
        就像 Spring Cloud 一样需要提供各种配置服务、服务发现、智能路由、控制总线。。还有像Kubernetes 提供
        各式各样的部署和调度方式。
        
        没有这些 PaaS 层的支撑，微服务很难被管理和运维的。    
        
        
        
"""22 :从亚马逊的实践，谈分布式系统的难点"""                 
    
    分布式系统中需要注意的问题：
        
        1、异构系统的不标准问题：
            主要表现在：
                软件和应用不标准
                通讯协议不标准
                数据格式不标准
                开发和运维的过程和方法不标准
                
        2、系统架构中的服务依赖性问题：
        
            a. 如果非关键业务被关键业务所依赖，会导致非关键业务变成一个关键业务。
            b. 服务依赖中，出现“木桶短板效应”---整个 SLA 由最差的安格服务所决定。
            
        3、故障发生的概率更大
        
            a. 出现故障不可怕，故障恢复时间过长才可怕
            b. 出现故障不可怕，故障影响面过大才可怕
            
        4、多层架构的运维复杂度更大
        
            我们可以把系统分成四层：基础层、平台层、应用层、接入层 
            
            a. 基础层就是我们的机器、网络和存储设备等。
            b. 平台层就是我们的中间件层，Tomcat、MySQL、Reids、Kafka 之类的软件。
            c. 应用层就是我们的业务软件，比如，各种功能的服务。
            d. 接入层就是接入用户请求的网关、负载均衡或CDN、DNS 这样的东西。
            
            对于四层：
            
                任何一层的问题都会导致整体的问题
                没有统一的视图和管理，导致运维被割裂开来，造成更大的复杂度。
                
                
"""23: 分布式系统的技术栈"""                   
    
    1、技术栈：
        IT术语，某项工作或某个职位需要掌握的一系列技能组合的统称。
        technology stack 技术栈一般来说是指将N种技术互相组合在一起(N>1)，
        作为一个有机的整体来实现某种目的。也可以指掌握这些技术以及配合使用的经验。    
            
        现在流行一个说法，是Full Stack （全栈），简单地说是万金油，说得体面一点就是前端、后台、存储、架构等都懂。
        这里的栈就是英文的stack的意思（一些东西堆在一起）掌握不同种类技术更有逼格的一种说法。
    
    2、构建分布式系统的目是增加系统容量，提供系统可用性，转换成技术也就是完成下面两件事：
        
        a. 大量流量处理。通过集群技术把大规模并发请求的负载分散到不同的机器上。
        
        b. 关键业务保护。提供后台服务可用性，把故障隔离起来阻止多米诺骨牌效应（雪崩效应）
            如果流量过大，需要对业务降级，以保护关键业务流转。
            
        说白就是干两件事：一提供整个架构的吞吐量，服务更多的并发和流量。
                        二是为了提供系统的稳定性，让系统的可用性更高。
    
    3、提高架构的性能：
    
        提高系统性能的常用技术：缓存、负载均衡、异步调用、数据镜像、数据分区
        
        a. 缓存系统。缓存分区、缓存更新、缓存命中：
        
            加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器、到网络、再到后端服务，
            底层的数据库、文件系统、硬盘和cpu，全都有缓存，这是提高快速访问能力的有效手段。
            对于分布式下的缓存系统，需要的是一个缓存集群。其中需要一个 Proxy 来做缓存的分片和路由。
            
        b. 负载均衡系统（网关系统）。负载均衡、服务路由、服务发现：
        
            负载均衡系统是水平扩展的关键技术，它可以使用多台机器共同分担一部分流量请求。
            
        c. 异步调用。 消息队列、消息持久、异步事务：
            
            异步系统主要通过休息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，
            而后端通过自己能够处理的速度来处理请求。
            这样可以增加系统的吞吐量，但是时效性很差，同时，还会引入消息丢失的问题，所以要对
            消息做持久化，这会造成“有状态”的结点，从而增加服务调用的难度。
      
        d. 数据镜像（数据同步、读写分离、数据一致性：）和数据分区（分区策略、数据访问层、数据一致性） 
            
            数据分区按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。
            这需要一个数据路由的中间件，会导致库的 Join 和夸库的事务非常复杂。
            
            数据镜像把一个数据库镜像分成多份一样的数据，这样就不需要数据路由的中间件了，你可以
            在任意结点上读写，内部会自动同步数据，然而数据镜像最大的问题是数据的一致性问题。
            对于一般公司来说，初期使用读写分离的数据镜像方式，后期采用分库分表的方式。
    
    4、提高架构的稳定性：
    
        提高系统稳定性的一些技术：服务拆分、服务冗余、限流降级、高可用架构、高可用运维。
        
        a. 服务拆分。 服务治理（服务调用、服务依赖、服务分离）
        
            服务拆分主要两个目的：为了隔离故障、为了重用服务模块。
            但是服务拆分完之后，会引入服务调用间的依赖问题。
            
        b. 服务冗余。服务调度（弹性伸缩、故障迁移、服务发信）
            
            服务冗余是为了去除单点故障，并可以支持服务的弹性伸缩，以及故障迁移。
            然而，对于一些有状态的服务来说，冗余这些有状态的服务带来更高的复杂性。
            
            其中弹性伸缩时，需要考虑数据的复制或是重新分片，迁移的时候还要迁移数据到其他机器上。    
       
        d. 限流降级。（异步队列、降级控制、服务熔断）
        
            当系统实在扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分服务，或是拒绝一部分用户，
            保证整个系统不会挂掉。这些技术属于包含措施。
            
        e. 高可用架构。（多租户系统、灾备多活、高可用服务）
            
            通常来说，高可用架构是从冗余架构的角度来保障可用性。              
             
        f. 高可用运维。（全栈监控、DevOps、自动化运维）
            
            DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，
            用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。
            
            它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。
            透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。
           
            它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作
            
            高可用运维指的是 DevOps 中的 CI/CD（持续集成/持续部署）。
            一个良好的运维应该是一条很流畅的软件发布管线，其中做了自动化测试，相应的灰度发布，以及线上系统
            的自动化控制。
             
    5、分布式系统的关键技术：
    
        a. 服务治理：
        
            服务治理的最大意义是把服务间的依赖关系、服务调用链、以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。
        
        b. 架构软件管理：
        
            服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要由架构版本管理、整体架构的生命周期管理，
            以及服务的编排、聚合、事务处理等服务调度功能。
        
        c. DevOps:
            
            环境构建、持续集成、持续部署
        
        d. 自动化运维：
            
        e. 资源调度管理：
        
        f. 整体架构监控：
        
        g. 流量控制：    
        
        我们应该庆幸生活在一个不错的年代，有一种技术叫---Docker,通过 Docker 以及衍生出来的 Kubernetes 之类
        的软件或解决方案，大大地降低做上面很多事情的门槛。
        
    6、分布式系统的“纲”：
    
        分布式系统的五种技术：
        
        a. 全栈系统监控：
        
            基础层监控：
                os、主机、网络。。。
            
            中间件层监控：
                消息队列、缓存、数据库、应用容器、网关、RPC框架（Remote Procedure Call Protocol 远程过程调用协议）、JVM。。。
            
            应用层监控：
                API 请求、吞吐量、响应时间、错误码、SQL语句、调用链路、函数调用栈、业务指标...
        
        b. 服务/资源调度
        
            计算机资源调度：
                cpu、内存、磁盘、网络...
            
            服务调度:
                服务编排、服务复本、服务容量伸缩、故障服务迁移、服务声明周期....
            
            架构调度：
                架构部署、运行、更新、架构版本控制...
        
        c. 流量调度:
        
            服务治理：
                服务发现、服务路由、服务降级、服务熔断、服务保护...
            
            流量控制：
                负载均衡、流量分配、流量控制、异地灾备...
            
            流量管理：
                协议转换、请求校验、数据缓存、数据计算...
        
        d. 状态/数据调度:
        
            数据可用性：
                多副本保存
            
            数据一致性：
                读写一致性策略
                
            数据分布式：
                数据索引、分片    
        
        e. 开发和运维的自动化                 
                
"""24:分布式系统关键技术：全栈监控"""

    全栈监控是我们的眼镜，有了它我们就知道系统到的发生了什么，没有好的监控系统，我们无法进行自动化运维和资源调度。
    
    1、监控系统需要完成的功能为：
        a. 全栈监控
        
        b. 关联分析
        
        c. 跨系统调用的串联
        
        d. 实时报警和自动处置
        
        e. 系统性能分析
        
    2、多层体系的监控：
    
        所谓全栈监控，其实就是三层监控。
            
        基础层监控：监控主机和底层资源
           cpu使用率、内存使用率、网络吞吐、硬盘 I/O、硬盘使用率等
            
        中间件层监控：
        
            网关（Nginx）、缓存服务（Redis）、消息队列（Kafka）、数据库（MySql）、Java容器（TomCat）等
           
        应用层监控：
            HTTP(请求访问)、Java服务（性能监控）、JDBC（性能监控）、外部服务（调用性能）、移动端（性能监控）
           
        还需要一些监控的标准化：
        
            日志数据结构化
            监控数据格式标准化
            统一的监控平台
            统一的日志分析
            
    3、什么才是好的监控系统：
    
        现在有很多监控系统做的不好，主要有两个很大的问题：
        
            a. 监控数据是隔离开来的：
                开发、应用运维、系统运维各管个的，完全串联不起来。
            
            b. 监控数据项太多：     
                信息太多等于没有信息，抓不住重点才是这个样子。
                    
        好的监控系统应该有下面几个特征：
        
            a. 关注于整体应用的 SLA（SLA：Service-Level Agreement的缩写，意思是服务等级协议。）.
                
                主要从为用户服务的 API 来监控这个系统。   
                
            b. 关联指标聚合：
            
                把有关联的系统以及指标聚合展示。 
                服务有可能运行在Docker中，有可能运行在微服务平台的多个 JVM 中，也可能运行在 Tomcat 中。
                总之，无论运行在哪里，都要把服务具体的实例和主机关联在一起，否则，对于一个分布式系统来说，
                定位问题犹如大海捞针。
                
            c. 快速故障定位：
                
                快速定位问题需要对整个分布式系统做一个用户请求跟踪的 trace 监控，我们需要监控到所有的
                请求在分布式系统中的调用链。
                
        换句话说，一个好的监控系统主要为一下两个场景所设计的：
        
            体检：
            
                容量管理。提供一个全局的系统运行时数据的展示，可以让工程师知道是否需要增加机器或其他资源。
                
                性能管理。找到系统瓶颈，并针对的优化系统或代码
                
            急诊：
            
                定位问题。快速的暴露并找到问题的发生点
                性能分析。
                
    4、如何做出一个好的监控系统：
        
        一个好的监控系统应该实现的功能
        
        a. 服务调用链跟踪：
        
            从外部的 API 调用开始，然后将后台的实际服务给关联起来知道最好一个服务（MySQL 或 redis）
            把整个系统全部串联起来，整个事情最佳实践是 Google Dapper 系统，对应开源实现是 Zipkin
            
        b. 服务调用时长分布：
        
        c. 服务的 TOP N 视图：
            
            TOP N 视图就是一个系统的请求排名情况。
            
        d. 数据库操作关联：
            
            对于 java 应用，可以通过 javaAgent 字节注入技术拿到 JDBC 执行数据库操作的执行时间。
            
        e. 服务资源跟踪：
       
            我们需要把服务运行的机器节点上是数据（CPU、MEM、I/O、DISK、NETWORK）关联起来。
       
            
"""25 分布式系统关键技术：服务调度""" 
    
    服务调度设计一下节点：
        服务关键程度
        服务依赖关系
        服务发现
        整个架构的版本管理
        服务应用声明周期管理
        
    1、服务关键程度和服务的依赖关系：
    
        服务关键程度：主要是梳理和定义服务的重要程度，它需要细致地管理对业务的理解，才能定义处架构中服务的重要程度。
        服务依赖关系：服务的依赖关系可以通过技术手段发现的，Zipkin 是一个不错的服务调用跟踪系统，这个工具可以帮助
                    你梳理服务的依赖关系，以及了解各个服务的性能。
        
        在梳理完服务的重要程度和服务依赖关系之后，我们就相当于知道整个架构的全局，我们将相当于有一个一张城市地图
        在地图上可以看到城市的关键设施、城市主干道。
                   
    2、服务状态和生命周期的管理：
    
        我们有上面地图之后，还需要一个服务发现的中间件，这个中间件非常关键，
        我们需要一个注册中心来知道下面几件事：
            
            整个架构有多少中服务？
            这些服务的版本是什么样的？
            每个服务的实例个数是多少个，他们的状态是什么样的？
            每个服务的状态是什么样的，是在部署中、运行中、故障中、升级中、还是回滚中、伸缩中、下线中。。。
            
        有了这些服务的状态和运行情况之后，就需要对服务的生命周期进行管理了，服务的生命周期通常会有下面几种状态：
            
            Provision, 代表一个新的服务
            Ready, 表示启动成功了
            Run, 表示通过了服务健康检查
            Update, 表示在升级中
            Rollback， 表示在回滚中
            Scale，表示在伸缩中（可以有 Scale-in 和 Scale-out 两种）
            Destory, 表示在销毁中
            Failed, 表示失败的状态。
            
    3、整个架构的版本管理：
    
        亚马逊有这 VersionSet，也是有一堆服务的版本集所形成的整个架构的版本控制。
        
        你需要一个架构的 manifest，一个服务清单，这个服务清单定义了所有服务的版本运行环境，包括但不限于：
            
            服务软件的版本。
            服务的运行环境--环境变量、cpu、内存、可以运行的结点、文件系统等。
            服务运行的最大最小实例数。
            
    4、资源/服务调度：
    
        服务和资源调度有点像操作系统，主要有一些关键技术：
        
        a. 服务状态的维持和拟合:
            
            服务运行过程中，状态会有变化，这种变化有两种：
                一种不可预期的变化。比如服务运行故障导致一些服务挂掉。
                另一种是预期的变化。比如发布新版本，需要伸缩，回滚。
            
            对于分布式系统的服务管理来说，当需要把一个状态变成另一个状态，需要对集群进行一系列操作。
            比如对集群进行 Scale 的时候，我们需要：
            
                先扩展出几个节点。
                再往上部署服务。
                然后启动服务。
                再检查服务的健康情况。
                最后把新扩展出来的服务实例加入服务发现中提供服务。            
                
        b. 服务的弹性伸缩和故障迁移：
        
            对于弹性伸缩，其中涉及到：
                底层资源的伸缩
                服务的自动化部署
                服务的健康检查
                服务发现的注册
                服务流量的调度
            
            对于故障迁移，也就是服务中某个实例出现问题，我们需要恢复它，对于服务来说
            有两种模式，一种是宠物模式，一种是奶牛模式：
                宠物模式：一定要救活，主要对于 stateful 的服务。
                奶牛模式：不救活了，重新生成一个实例。
                
        c.  服务工作流和编排：
        
            一个好的操作系统能够通过一定的机制把一堆独立的工作的进程协同起来，在分别是服务调度中，
            这个工作叫做 Orchestration ,国内把这个词翻译成“编排”。
            
            Orchestration 的意思是，一个服务像大脑一样来告大家应该怎么交互，更乐队的指挥一样。
            
            
"""26 分布式系统关键技术：流量与数据调度"""            
    
    1、流量调度的主要功能：
    
        a. 依据系统运行情况，自动地进行调度，无需人工干预，提升系统稳定性。
        
        b. 让系统应对爆品等突发事件时，在弹性计算扩缩容的较长时间窗口内或底层资源消耗殆尽的情况下，保护系统平稳运行。
        
        此外，流量调度还可以完成以下几个方面的事情：
        
            服务流控。服务发现、服务路由、服务降级、服务熔断、服务保护等。
            流量工作。负载均衡、流量分配、流量控制、异地灾备（多活）等。
            流量管理。协议转换、请求校验、数据缓存、数据计算等。
        
        所有的这些应该是一个 API Gateway 应该做的事
            
    2、流量调度的关键技术：
    
        a. 高性能。
        
        b. 抗流量。
        
        c. 业务逻辑
        
        d. 服务化。
      
    3、状态数据调度：
    
        对于服务调度，最难办的就是有状态的服务了，这里的状态是 State, 也就是说，有些服务会保存一些数据，
        而这些数据不能丢失的，所以这些数据是需要随服务一起调度的。
        
        一般来说，我们通过“转移问题”的方法来让服务变成“无状态服务”。也就是说，会把这些有状态的东西存储到
        第三方服务上，比如 Redis、MySql、ZooKeeper、或是 NFS、Ceph 的文件系统中。
        
    4、分布式事务一致性的问题：
    
        要解决数据不丢失的问题，只能通过数据冗余的方法，就是数据分区，每个区也需要进行数据冗余处理。
        这就是数据副本。当某个节点的数据丢失，可以从副本读到。数据副本是分布式系统解决数据丢失异常
        的唯一手段。
        
        在解决数据副本间的一致性问题时，我们有一些技术方案：
        
            Master-Slave 方案。
            Master-Master 方案
            两个阶段和三阶段提交方案
            Paxos 方案。
            
    5、数据结点的分布式方案：
    
        真正解决数据结点调度的方案应该是底层的数据结点。就像阿里的用分库分表的数据库中间件 TDDL。
    
"""27 洞悉 PaaS 平台的本质 """
            
"""28 推荐阅读：分布式系统架构经典资料"""            
            
"""29 推荐阅读：分布式数据调度相关论文"""
            


"""30 编程范式游记（1）-- 起源"""
    
    1、编程范式：
        
        编程范式的英语是 Programming paradigm, 范即模范之意，范式即模式、方法，是一类典型的编程风格。
        是指从事软件工程的一类典型的风格。
        
        编程语言发展到今天，出现了好多不同的代码编写方式（泛型编程、函数式编程、面向对象编程）
        不同的方式解决的都是同一个问题，那就是如何写出更为通用、更具有重用性的代码或模块。
        
        
    2、先从 C 语言开始：
    
        现在看到的几乎所有编程语言都以 C 语言为基础来拓展来的，
        不管是 C++、java、C#、GO、Python、PHP、Perl、JavaScript、Lua 还是 shell。
        
        C 语言由那些特征：
        
            a. C 语言是一个静态弱类型语言， 在使用变量时需要声明变量类型，但是类型间可以有隐式转换；
            
            b. 不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；
            
            c. C 语言可以使用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；
            
            d. C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；
            
            e. C 语言传递参数一般是以值传递，也可以传递指针；
            
            f. 通过指针， C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度。
            
            g. 编译预处理让 C 语言的编译更具有弹性，比如跨平台。
            
        C 语言的这些特性，可以让程序员在微观层面写出非常精细和精确的编程操作，让程序员可以在底层
        和系统细节上非常自由，灵活和精准地控制代码。
        
        然而，在代码组织和功能编程上，C 语言的这些特性，就不那么美妙了。
    
    3、 从 C 语言的一个简单例子说起：
    
        C 语言最简单的交换两个变量的 swap 函数说起：
        
            void swap(int * x, int * y)
            {
                int temp = *x;
                *x = *y;
                *y = temp;
            }
            
        这里为什么要传指针？
            
            因为如果你不传指针的话，那么参数变成传值，即函数的形参是调用实参的一个拷贝，函数里面对形参的修改
            无法影响到实参的结果，为了达到调用函数后，实参内容修改，必须把实参的地址传递过来，也就是指针。
            这样在函数里做交换，实际变量的值也就被交换了。
            
            然而，这个函数最大的问题是它只能给 int 值用，这个世界上还有其他类型，duble、float 这就是静态
            语言最糟糕的一个问题。
            
    4、数据类型和现实世界的类比：
    
        与现实世界类比一下，数据类型好像螺帽一样，有多种接口方式：平口的、十字的、六角的等等，
        而螺丝刀就像是函数或是操作这些螺丝帽的算法或代码。我们发现不同类型的螺丝帽（数据类型）
        需要适配一堆不同的螺丝刀（函数）。
        而且它们还有不同的尺寸（尺寸就是代表它的单字节的，还是多字节，比如整型的int、long,浮点数的 float、double）
        这样复杂度一下子就提高了，最终导致电工(程序员)工作时候要带一大堆工具。
        你应该见过经过优化的螺丝刀，上面的手柄是一样的，拧螺丝的动作也是一样的，只是接口不一样。
    
        无论是传统世界，还是编程世界，我们都在干一件事情，那就是通过使用一种更为通用的方式，
        用另外的话说就是抽象和隔离，让复杂的“世界”变得简单一些。
        
        然而，要做到抽象，对于 C 语言这样的类型语言来说，首当其冲的就是抽象类型，这就是所谓的--泛型编程。
            
        另外，对于 C 语言的类型转换，会出很多问题，比如 传给我一个数组，这个数组本来是 double的，或者是 long 64位的，
        但是如果把函数类型强转成 int，那么会出现很多问题，因为这会导致程序遍历数组的步长不一样。
        
        比如一个 double a[10] 的数组，a[2] 意味着 a + sizeof(double)*2，如果你把 a 强转换成 int,
        那么 a[2] 就意味着 a + sizeof(int)*2， 我们知道 sizeof(double) 是 8，而sizeof(int)是 4.
        于是访问到不同的地址和内存空间，导致程序出现严重的问题。
        
    5、 C 语言的泛型：
    
        一个泛型示例 --- swap 函数：
        C 语言是如何泛型的。C 语言的类型泛型基本上来说就是使用 void * 关键字或是使用宏定义。
        下面是一个使用 void *泛型版本的 swap 函数。
        
            void swap(void *x, void *y, size_t size)
            {
                char tmp[size];
                memcpy(tmp, y, size);
                memcpy(y,x, size);
                memcpy(x, tmp, size);
            }    
        
        上面这个函数几乎完全改变了 int 版的函数的实现方式，这个实现方式有三个重点：
        
            a. 函数接口中增加了一个 size 参数。
                为什么要这么干呢？因为，用了 void * 后，类型被“抽象”掉了，编译器不能通过类型得到类型
                的尺寸了，所以，需要我们手动地加上一个类型长度的标识。
                
            b. 函数的实现中使用了 memcpy() 函数。
                为什么要这样干呢？是因为类型被“抽象”掉了，所以不能用赋值表达式了，很有可能传进来的参数类型
                还是一个结构体，因此，为了要交换这些复杂类型的值，我们只有使用内存复制的方法了。
            
            c. 函数的实现中使用了一个temp[size]数组。     
            
                这就是交换数据时需要用 buffer， 用 buffer 来做临时的空间存储。
                        
        于是，新增的 size 参数，使用的 memcpy 内存拷贝以及一个 buffer, 这增加了编程的复杂度。
        这就是 C 语言的类型抽象所带来的的复杂度提升。
        
        在提升复杂度的同时，发现还有问题，比如，我们想交换两个字符串的数组，类型是：char *，那么，
        我们的 swap() 函数的 x 和 y 参数是不是要用 void ** 了，这样一来，接口就没办法定义了。
        
        除了使用 void * 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：
        
            #define swap(x, y, size){\
                char temp[size];\
                memcpy(temp,&y,size);\
                memcpy(&y,&x,size);\
                memcpy(&x,temp,size);\                
            }  
            
        但是用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出执行文件比较大。
        不过对于 swap 这个简单的函数来说，用 void * 和宏替换来说都可以达到泛型。
        
        但是，如果我们不是 swap, 而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。比如，下面的
        这个宏：
            
            # define min(x, y) ((x) > (y) ? (y) : (x))
            
        其中一个最大的问题，就是有可能会有重复执行的问题，如：
            
            min(i++, j++)  对于这个案例来说，我们本意是比较完后，对变量做累加，但是，由于宏替换的缘故，这会导致
            变量 i 或 j 被累加两次。
            
            min(foo(), bar()) 对于这个案例来说，我们的本意是比较 foo() 和 bar() 函数的返回值，然而，经过宏替换后
            foo() 或 bar() 会被调用两次，这会带来很多问题。
            
        另外，不管哪种方式，这种“泛型”是不是太宽松了，完全不做类型检查，就是在内存上拷贝，直接操作内存是不是比较危险。
        
        从上面两个例子，我们可以发现，无论哪种方式，接口都会变得复杂--加入了 size。
        而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 sizeof(x) 这样的方式得到 size。
        但是如果类型是 char *， 那么，使用 sizeof 方式只能得到指针类型的size, 而不是值的 size。
        另外，对于不同的类型，比如说double 和 int, 那么该用谁的 size 呢？是不是先转一下类型，这些都是问题。
        
        于是，这种泛型，让我们根本没办法检查传入参数的 size, 导致我们只能增加接口复杂度，加入一个 size 参数，
        然后，把这个问题抛给调用者。
      
      
        一个更为复杂的泛型示例 -- Search 函数：
        
        如果我们把这个事情变得更复杂，写个 search 函数，再传一个 int 数组，然后想搜索 target，搜到返回数组下标，搜不到返回-1。
        
            int search(int *a, size_t size, int target){
                
                for(int i=0; i<size; i++){
                    if(a[i] == target){
                        return i;
                    }
                }
                return -1;
            }
        
        上面这个函数的类型是 int 版本的，如果我们要把这个函数变成泛型的应该怎么变？
        就像上面的 swap() 函数那样，如果要把它变成泛型，我们需要变更复杂化函数接口。
            
            a. 我们需要在函数接口中增加一个 element size, 也就是数组里的每一个元素的size.
                这样我们在遍历的时候，就可以通过这个size正确移动指针到下一个数组元素。
                
            b. 我们还需要加个 cmpFn. 因为我们要去比较数组里的每个元素和traget是否相等。
                因为不同是数据类型的比较实现不一样，比如整型比较用==就好了，但是如果是一个
                字符串数组，那你比较久需要用 strcmp 这类函数。而如果你传一个结构体数组
                那么两个数据对象是否一样就比较复杂了。所以，必须自定义一个比较函数。
                
            int search(void *a, size_t size, void * target, size_t elem_size, int(*cmpEn)(void *, void *))
            {
                for(int i=0; i<size; i++){
                    
                    if(cmpEn((unsigned char *)a + elem_size*i, target) == 0){
                        return i;
                    }
                    
                }
                return -1;
            }      
            
            上面的代码里没有使用 memcmp()函数，因为，如果这个数组是一个指针数组，或是这个数组是一个结构体数组，
            而结构体数组里有指针成员。我们相比较是指针指向的内容，而不是指针这个变量。所以用memcmp()会导致我们
            在比较指针（内存地址），而不是指针所执行的值。
            
            而调用者需要提供如下的比较函数“
            
                int int_cmp(int *x , int * y)
                {
                    return *x - *y
                }
                
                int string_cmp(char *x, char * y){
                    return strcmp(x, y)
                }
                
            如果面对有业务类型的结构体，可能会是这样的比较函数：
            
                typedef struct_account{
                    char name[10];
                    char id[20];
                }Account;
                
                int account_cmp(Account* x, Account *y){
                    int n = strcmp(x->name, y->name);
                    if(n != 0) return n;
                    return strcmp(x->id, y->id)
                }
                
        C 语言泛型干成这个样子，看上去还行，但是上面的search 函数只能用于顺序型的数据容器。
        如果这个search函数能支持一些非顺序型的数据容器比如栈、堆、哈希表、树、图。
        那么 C 语言基本干不下去，数据结构的自适应会把这个事的复杂度搞上几个数量级。
        
    6、小结：
    
        如果说，程序 = 算法 + 数据，C 语言会有这几个问题：
        
        a. 一个通用的算法，需要对所处理的数据的数据类型进行适配，但是在适配数据类型的过程中
            C 语言只能使用 void * 或 宏替换的方式，这两种方式导致了类型过于宽松，并带来
            很多其他问题。
            
        b. 适配数据类型，需要 C 语言在泛型中加入一个类型的 size, 这是因为我们识别不了被泛型后的数据类型
            而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。
            
        c. 算法其实是在操作数据结构，而数据则是放到数据结构中。所以，真正的泛型除了适配数据类型外，
            还有适配数据结构。最后这个事情导致泛型算法的复杂度急剧上升。
            
        d. 最后，在实现泛型算法的时候，你会发现自己在纠结那些东西应该抛给调用者处理，那些又是可以封装起来。
            如何平衡好选择，并没有定论，也不好解决。
            
        
        总体来说，C 语言设计目标是提供一种能以简易的方式编程、处理底层内存、产生少量的机器码以及
        不需要任何运行环境支持便能运行的编程语言。 C 语言也很适合搭配汇编语言来使用。C 语言把非常
        底层的控制权交个程序员，它设计理念是：
        
            a. 相信程序员
            b. 不会阻止程序员做任何底层的事
            c. 保持语言的最小和最简特性
            d. 保证 C 语言的最快的运行速度，那怕牺牲移植性
        
        从某种角度上来说， C 语言的伟大之处在于--使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制。    
        这是 C 语言的强大和优雅之处，也有人说，C 语言是高级语言中的汇编语言。
        
        不过，这只是在针对底层指令控制和过程时的编程方式。而对于更高阶更为抽象的编程模型来说
        C 语言这种基于过程和底层的初衷设计就会成为它的短板。因为，在编程这个世界里，更多的编程
        工作是解决业务上我问题，而不是计算机的问题，所以，我们更需要更为贴近业务更为抽象的语言。
        
        C 语言诞生于 1972 年，在它之后， C++, java，C# 等语言前扑后继，一浪高过一浪，都在试图
        解决那个时代的那个特定的问题，我们不能去否定某个语言，但可以肯定，随着历史发展，每一门
        语言都还在默默迭代，不断优化更新。同时，有很多新的编程语言带着新的闪耀的特性出现在我们面前。
        
        编程范式其实就是程序的指导思想，它也代表了这门语言的设计方向，我们不能说那种范式更为超前
        只能说各有千秋。
        
        比如 C 语言就是过程式语言，像 C 语言这样的过程式编程语言优点是底层灵活而且高效，特别适合
        开发运行较快且对系统资源利用率要求较高的程序，但是上面的问题它在后来也没有试图去解决。
        因为编程范式的选择基本已经决定了它的“命运”。
        
        
"""31 | 编程范式游记（2）- 泛型编程 """

    C++ 语言是如何通过泛型来解决 C 语言遇到的问题的？
    
    随着认知升级，面向过程的 C 语言无法满足更高层次的编程的需要，于是，C++ 出现了。    
    
    1、 C++ 语言：
    
        1980 年， AT&T 贝尔实验室的Bjarne Stroustrup 创建了 C++ 语言横空出世，它既可以全面兼容 C 语言，
        又巧妙的柔和了一些面向对象的编程理念。
        
        从语言角度来说，实际上早期 C++ 的许多工作是对 C 的强化和净化，并把完全兼容 C 作为强制性要求
        （这也是 C++ 复杂晦涩的原因，这点 java 就干的比 C++ 彻底的多）。在 C89、C99 这两个 C 语言
        的标准中，有许多改进都是从 C++ 中引进的。
        
        可见，c++ 对 c 语言的恭喜非常大，是的，因为 C++ 很大程度上就是用来解决 C 语言中的各种问题
        和各种不方便的。比如：
        
            a. 用引用来解决指针的问题.
            
            b. 用 namespace 来解决名字空间冲突的问题。
            
            c. 通过 try-catch 来解决检查返回值编程的问题。
            
            d. 用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。
            
            e. 通过重载操作符来达到操作上的泛型。
                比如，消除上篇提到的比较函数cmpFn, 再比如用 >> 操作符消除 printf() 的数据类型不够泛型的问题。
                
            f. 通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。
            
            g. 用 RALL、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的非常 ugly 也很容易出错的代码的问题。
            
            h. 用 STL（Standard Template Library，标准模板库) 解决了 C 语言中算法和数据结构的 N 多种坑。
            
            
    2、 C++ 泛型编程
    
        C++ 是支持编程方式最多的一门语言，它虽然解决很多 C 语言问题，它最大的意义是解决了 C 语言泛型编程的问题。
        我们可以看到 C++ 的标准规格说明书里，有一半以上都是在说明 STL 的标准规格应该是什么样的，这说明泛型编程
        是 C++ 重点中的重点。
        
        在理想情况下，算法应该是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。
        算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用
        算法，那么对数据类型的最小需求又是什么呢？
        
        C++ 是如何有效解决程序泛型问题的，我认为有三点：
        
            第一，它通过类的方式来解决。
                
                a. 类里面会有构造函数，析构函数表示这个类的分配和释放。
                
                b. 还有它的拷贝构造函数，表示了对内存的复制。
                
                c. 还有重载操作符，像我们要去比较大于、等于、不等于。
                
                这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。
            
            
            第二，通过模板达到类型和算法的妥协。
            
                a. 模板有点像 DSL, 模板的特化会根据使用者的类型在编译时期生成那个模板的代码。
                
                b. 模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。
                
                模板很好地取代了 C 时代宏定义带来的问题。
                
            第三，通过虚函数和运行时类型识别。
            
                a. 虚函数带来的多态在语义上可以支持“同一类”的类型泛型。
                
                b. 运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。
                
                这样一来，就可以写出基于抽象接口的泛型。
                
        拥有了这些 C++ 引入的技术，我们可以做到 C 语言很难做到的泛型编程了。
        正如前面所说的，一个良好的泛型编程需要解决如下几个泛型编程的问题：
        
            a. 算法的泛型。
            b. 类型的泛型。
            c. 数据结构（数据容器）的泛型。
            
    3、 C++ 泛型编程的示例 - Search 函数：
    
        就像前面的 search() 函数，里面的 for(int i=0; i<len; i++) 这样的遍历方式，
        只适用于顺序型的数据结构的方式迭代，如：array、set、queue、list 和 link 等
        并不适用非顺序型的数据结构。如：hash table、binary tree、graph 等这样数据
        不是按顺序存放的数据结构（数据容器）。所以，如果找不到一种泛型的数据结构的操作方式
        （如遍历、查找、增加、删除、修改...），那么任何的算法或是程序都不可能做到真正意义上的泛型。
        
        除了 search() 函数的 “遍历操作” 之外，还有 search 函数的返回值，是一个整型的索引下标。
        这个整型的下标对于“对于顺序的数据结构”是没有问题的，但是对于“非顺序的数据结构”在语义上存在问题。
        比如，我们要在一个 hash table 中查找一个 key,返回什么呢？一定不是返回“索引下标”，因为在hash table
        这样的数据结构中，数据的存放位置不是顺序表，而且还会因为容量不够的问题被 hash 后改变，所以
        返回下标是没有意义的。
        
        对此，我们要把这个事做得泛型和通用一些。如果找到，返回找到的这个元素的一个指针(地址)会更靠谱一些。
        所以，为了解决泛型的问题，我们需要动用以下几个 C++ 的技术。
        
            a. 使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）
            
            b. 使用一个迭代器来遍历或是操作数据结构内的元素。 
        
        重温一下 C 语言版的代码：
        
            int search(void *a, size_t size, void * target, size_t elem_size, int(*cmpFn)(void *, void *))
            {
                for(int i=0; i< size; i++){
                    if(cmpFn(a+elem_size*i, target) == 0){
                        return i;
                    }
                }
                return -1;
            }
            
        再看一下 C++ 泛型版本的代码：
        
            template<typename T, typename Iter>
            Iter search(Iter pStart, Iter pEnd, T target)
            {
                for(Iter p = pStart; p != pEnd; p++){
                    if(*p == target)
                        reutrn p;
                }
                return NULL;
            }               
        
        在 C++ 的泛型版本中，我们可以看到：
        
            a. 使用 typename T 抽象了数据结构中存储数据的类型。
            
            b. 使用 typename Iter，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了不同类型的数据结构。
            
            c. 然后，我们对数据容器的遍历使用了 Iter 中的 ++方法，这是数据容器需要重载的操作符，这样通过操作符重载
                也就泛型掉了遍历。
                
            d. 在函数的入参上使用了 pStart 和 pEnd 来表示遍历的起止。
            
            e. 使用 *Iter 来取得这个“指针”的内容。这也是通过重载 * 取值操作来达到泛型。
            
            当然，你可能会问，为什么我们不用标准接口 Iter.Next() 取代 ++, 用Iter.GetValue() 来取代*，
            其实这样做是为了兼容原有 C 语言的编程习惯。
                               
            说明一下，所谓的 Iter, 在实际代码中，就是像 vector<int>::iterator 或 map<int,string>::iterator 这样的东西。
            这是由相应的数据容器来实现和提供的。           
                    
        注：下面是 C++ STL 中的 find() 函数的代码。
        
            template<class InputIterator, class T>
            InputIterator find(InputIterator first, InputIterator last, const T& val)
            {
                while(first != last){
                    if (*first == val)return first++;
                    ++first;
                }
                return last;
            }    
        
        也许，你觉得到这一步，我们的泛型设计就完成了，其实还远远不够， search 函数只是一个开始，
        我们还要很多别的算法会让问题变的更为复杂。
                       
    4、 C++ 泛型编程示例 - Sum 函数：
        
        
        
        C 语言版本：
            
            long sum(int *a, size_t size){
                long result = 0;
                for(int i=0; i<size; i++){
                    result += a[i];
                }
                return result;
                
            }
        
        再看一下 C++ 泛型版本：
        
            template<typename T, typename Iter>
            T sum(Iter pStart, Iter pEnd){
                T result = 0;
                for(Iter p = pStart; p != pEnd; p++){
                    result += *p;
                }
                return result;
            }
        
        这个代码中最大的问题是  T result = 0; 这条语句：
            那个 0 假设了类型是 int;
            那个 T 假设了Inter 中出来的类型是 T.
            
        这样的假设是有问题的，如果类型不一样，就会导致转型的问题，这会带来非常 buggy 的代码。
        那么该怎么解决呢？
        
    5、C++ 泛型编码的重要技术 - 迭代器
    
        我们知道 Iter 在实际调用者那会是一个具体的像 vector<int>::iterator 这样的东西。
        在这个声明中， int 已经被传入 Iter 中了。所以，定义 result 的 T 应该可以从 Iter 中来。
        这样就可以保证类型是一样的，而且不会有被转型的问题。                 
                        
        所以，我们需要一个精心的实现一个“迭代器”。下面是一个简化版的：
        
            template <class T>
            class container{
            public:
                    class iterator{
                    public:
                            typedef iterator self_type;
                            typedef T value_type;
                            typedef T* pointer;
                            typedef T& reference;
                            
                            reference operator*();
                            pointer operator->();
                            bool operator==(const self_type& rhs);
                            bool operator!=(const self_type& rhs);
                            self_type operator++() {self_type i = *this; ptr_++; return i;}
                            self_type operator++(int junk){ptr_++;return *this;}
                            ...
                            ...
                    private:
                            pointer +ptr;                    
                    };        
                    
                    iterator begin();
                    iterator end();
                    ...
                    ...
            };     
            
        上面迭代器代码只是写出来基本思路，这里有几个关键点：
        
            a. 首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。
            
            b. 它需要重载一些操作符。比如：取值操作 *、成员操作->、比较操作 == 和 !=,还有遍历等等。
            
            c. 然后，还要 typedef 一些类型，比如 value_type，告诉我们容器内的数据的实际类型是什么样子。
            
            e. 还有一些，如 begin() 和 end() 的基本操作
            
            f. 我们还可以看到其中有一个 pointer _ptr 的内部指针来指向当前的数据（注意，pointer 就是 T*）
        
        好了，有了迭代器后，我们还要解决 T result = 0 后面这个 0 的问题，这个事，算法没有办法搞定，最好由
        用户传入。于是出现了最终的 sum() 版本函数。
        
            template<class Iter>
            typename Iter::value_type
            sum(Iter start, Iter end, T init){
                typename Iter::value_type result== init;
                while(start != end){
                    result = result + *start;
                    start++;
                }
                return result;
            }            
                  
        我们看到 typename Iter::value_type result = init 这条语句是关键。我们解决了所有问题。
        我们如下使用：
        
            container<int> c;
            container<int>::iterator it = c.begin();
            sum(c.begin(), c.end(), 0);
        
        这就是整个 STL 的泛型方法，其中包括：
        
            泛型的数据容器。
            泛型数据容器的迭代器。
            然后泛型的算法就很容易写了。
        
    6、需要更多的抽象：
    
        更为复杂的需求:
        
            还能不能做到更为泛型呢？比如：如果我们有这样一个数据结构 Employee, 里面有 vacation（休假天数），以及工资。
            
            struct Employee{
                string naem;
                string id;
                int vacation;
                double salary;
            }
            
            现在我们想计算员工的总薪水，或是总休假天数。
            
                vector<Employee> staff;
                sum(staff.begin(), staff.end(),0);
            
            我们的 sum 完全不知道怎么搞了，因为要累加的 Employee 类中的不同字段，即便我们的 Employee 中重载了 + 操作
            也不知道要加哪个字段。
            
            另外，我们可以还会有：平均值average, 求最小值 min, 求最大值 max, 求中位数 mean 等等。
            你会发现，算法写出了基本都是一样的，只有其中“累加”操作变成了另外一个操作。
            面对这么多需求，我们是否可以泛型一些呢？怎样解决这些问题呢？
        
       
        更高维度的抽象：
        
            要解决这个问题，我们希望我的这个算法只管遍历，具体要干什么，那是业务逻辑，
            有外面的定义就好了和我无关，这样一来，代码的重用高了。
            
            下面一个抽象度更高的版本，这个版本再叫 sum 就不太合适。这个版本应该是 reduce
            用于把一个数组 reduce 成一个值。
            
            template<class Iter, class T, class Op>
            T reduce(Iter start, Iter end, I init, Op op){
                T result = init;
                while(start != end){
                    result = op(result, *start);
                    start++;
                }
                return result;
            }    
            
            上面的代码中，我们需要传递一个函数进来。在 STL 中，它是个函数对象，我们还是这套算法，
            但是 result 不是像前面那样去加，是把整个迭代器值给你一个 operation, 然后有它来做。
            
            在 C++ STL 中，与这个 reduce 函数对应的函数名叫 accumulate()， 其实际代码有两个版本。
            
            第一个版本就是上面的版本，只不过是用 for 语句而不是 while。
                
                template<class InputIt, class T>
                T accumulate(InputIt first, InputIt last, T init)
                {
                    for(;first != last; ++first){
                        init = init + *first;
                    }
                    return init;
                }
            
            第二个版本，更为抽象，因为需要传入一个“二元操作函数” -- BinaryOperation op 来做 accumulate。
            accumulate 的语义比 sum 更抽象了。
            
                template<class InputIt, class T, class BinaryOperation>
                T accumulate(InputIt first, InputIt last, T init, BinaryOperation op)
                {
                    for(; first != last; ++first){
                        init = op(init, *first);
                    }
                    return init;
                }
                
            来看看外面在使用中是什么样子：
            
                double sum_salaries = reduce(staff.begin(), staff.end(), 0.0, {return s + e.salary;});
                double max_salary = reduce(staff.begin(), staff.end(), 0.0, {return s > e.salary?s:e.salary;});
                    
        Reduce 函数：
        
            我们来看看如何使用 reduce 和其它函数完成一个更为复杂的功能。
            
            下面示例中，我们定义了一个函数对象 counter. 这个函数对象需要一个 Cond 的函数对象，它是个条件判断函数，
            如果满足条件则加 1，否则加 0.
            
                template<class T, class Cond>
                struct counter{
                    size_t operator()(size_t c, T t)const{
                        return c + (Cond(t)?1:0)
                    }
                }        
               
            然后，用上面的 counter 函数对象和reduce 函数共同打造一个 counter_if 算法：
            
                template<class Iter, class Cond>
                size_t coint_if(Iter begin, Iter end, Cond c){
                    return reduce(begin, end, 0, counter<Iter::value_type, Cond>(c));
                }
            
            至于是什么样的条件，这个属于业务逻辑，不是流程控制。
            
            当我们需要统计薪资超过 1 万元的员工的数据时，一行代码就够了。
            
                size_t cnt = count_if(staff.begin(), staff.end(),{return e.salary > 10000;});
            
            Reduce 时可以只对结构体中某些值做 Reduce, 比如说只对 salary > 10000 的人做，只选出这个
            里面的值，它用 Reduce 就可以达到这步，只要传不同的方式给它，你就可以造成一个新的东西出来。
            
            说着说着，就到了函数式编程，函数式编程里，我们可以用很多像 reduce 这样的函数来完成更多
            的像 STL 里面的 count_if() 这样有具体意义是函数。
                    
    7、小结：
    
        从 C 到 C++ 的演进这一过程带来的编程方式的变化，你可以看到，在静态类型语言方面解决泛型编程
        的一些技术和方法，从而感受其中的奥妙和原理。
        
        因为形式是多样的，但是原理是相通的。所以，这个过程会非常有助于你更深刻了解更多的编程范式。
    
        
"""32| 编程范式游记（3） - 类型系统和泛型的本质"""        
    
    我们讨论了从 C 到 C++ 的泛型编程方法，并且初探了更为抽象的函数式编程。
    泛型编程的方式并不知有 C++ 这一种类型，我们只是通过这个过程了解一下，
    底层静态类型语言的泛型编程原理。              
            
    是的，除了 C++ 那样的泛型，如果你了解其他的编程语言一定会发现，在动态类型语言或是
    某些有语法糖支持的语言中，那个 swap() 或 search() 函数的泛型其实可以很简单地就实现了。
    
    比如，你甚至可以把 swap() 函数简单地写成下面这个样子：
        
        b, a = a, b
        
    在编程世界中，我们需要处理好两件事：
    
        第一件事是编程语言中的类型问题。
        
        第二件事是对真实世界中业务代码的抽象、重用和拼装。
        
    下面我们探讨一下编程语言中的类型系统和泛型编程的本质。                   
    
    1、类型系统：
    
        在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，
        以及如何操作这些类型，还有这些类型如何互相作用，类型可以确定一个值或者一组值具有特定的意义和目的。
        
        一般来说，编程语言会有两种类型：
            
            一种是内建类型，如 int、float 和 char 等，
            
            一种是抽象类型，如 struct、class 和 function 等。抽象类型在程序运行中，可能不表示为值。
            类型系统在各个语言之间有非常大的不同，也许，最主要的差异存在于编译时期的语法，
            以及运行时期的操作实现方式。
            
        编译器可能使用值的静态类型以最优化所需的存储区，并选取对数值运算时的最佳算法。
        例如，在许多 C 编译器中，“浮点数” 数据类型是以 32 比特表示、与IEEE 754 规格一致的单精度浮点数。
        因此，在数值运算上，C 应用了浮点数规范（浮点数加法、乘法等）
        
        类型的约束程度以及评估方法，影响了语言的类型。进一步，编程语言可能就类型多态性部分，
        对每一个类型都对应了一个针对这个类型的算法运算。
        类型理论研究类型系统，尽管实际的编程语言类型系统，起源于计算机架构的实际问题、编译器实现，以及语言设计。
        
        程序语言的类型系统主要提供如下的功能：
        
            a. 程序语言的安全性：
            
                使用类型可以让编译器侦测到一些代码错误。例如：可以识别一个错误无效的表达式。
                如：“Hello, world” + 3 这样的不同数据类型间操作的问题，强制型语言提供更多的安全性，
                但是并不能保证绝对的安全。
                
            b. 利于编程器的优化：
            
                静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器可以利用这一信息
                做很多代码优化工作。例如，我们指定一个类型是 int, 那么编译就知道，这个类型会以 4 个字节
                的倍数进行对齐，编译器就可以非常高效的利用更有效率的机器指令。
            
            c. 代码的可读性：
            
                有类型的编程语言，可以让代码更已读和更易维护。
                
            d. 抽象化：
            
                类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的底层次实现。
                例如：我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层字节的数组。
                从高层来说，类型可以用来定义不同模块间的交互协议，比如，函数的入参类型和返回类型，从而可以让接口更有
                语义，而且不同的模块数据交换更为直观和易懂。
                
        但是，正如前面所说的，类型带来的问题就是我们作用于不同类型的代码，虽然长的非常相似，但是由于类型的问题需要根据不同的版本写出
        不同的算法，如果要做到泛型，就需要设计比底层的玩法。
                     
        对此，这个世界出现了两类语言，一类是静态类型语言。如 C、C++、Java, 一种是动态类型语言：如Python、PHP、JavaScript等。
        
        看一下，一段动态类型语言的代码：
        
            x = 5
            x = "hello world"
            
        在这个示例中，我们可以看到变量 x 一开始好像是整型，然后又变成了字符串型。
        如果是在静态类型的语言中写成这样的代码，那么就会在编译期出错。
        而在动态类型的语言中，会以类型标记维持程序多有数值的“标记”，并在运算任何数值之前检查标记。
        所以，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态和底层的计算机指令或
        内存布局对应起来。
        
        看一下，对于 JavaScript 这样的动态语言来说，可以定义处下面这样的数据结构，这在静态语言中很难做到：
        
            var a = new Array()
            a[0] = 2017;
            a[1] = "hello";
            a[2] = {name:"Hao Chen"};
            
        其实这并不是一个数组，而是一个 key:value。因为动态语言的类型是动态的，所以，key 和 value 的类型
        都可以随意。比如对于 a 这个数据结构，还可以写成：a["key"] = "value" 这样的方式。
        
        在弱类型或是动态类型的语言中，下面的d代码执行会有不确定的结果：
        
            x = 5;
            y = "37";
            z = x + y;
            
        有的像 Visual Basic 语言给出的结果是 42；系统将字符串"37"转换成数字 37，以匹配运算上的直觉。
        而像 JavaScript 语言给出的结果是 "537" 系统将数字 5 转换成字符串 "5" 并把两者串联起来。
        像 Python 这样的语言则会产生一个运行时错误。
        
        但是，我们需要知道，无论哪种程序语言，都避免不了一个特定的类型系统。哪怕是可以随意改变变量
        类型的动态类型的语言。
        
        所以，每个语言都需要一个类型检查系统：
        
            静态类型检查是在编译器进行语义分析时进行的。如果一个语言强制实行类型规则
            （即通常只允许以不丢失信息为前提的自动类型转换），那么称此处理为强类型，
            反之称为弱类型。
            
            动态类型检查系统更多的是在运行时期做动态类型标记和相关检查。所以动态类型的语言必须要给出
            一堆诸如：is_array(), is_int(), is_string() 或是 typeof() 这样的运行时类型检函数。
            
        总之，类型有时候是一个有用的事，有时候又是一件很讨厌的事情。因为，类型对底层内存布局是一个抽象，
        会让我们的代码关注于这些非常业务逻辑上的东西。而且，我们的代码需要在不同类型的数据间做处理。
        但是如果程序语言类型检查得过于严格，那么，我们写出来的代码就不能那么随意。
        
        所以，对于静态类型的语言也开了些“小后门”：比如，类型转换，还有 C++， Java 运行时期的类型测试。
        这些小后门也会带来相当讨厌的问题，比如下面这个 C 语言的示例：
        
            int x = 5;
            char y[] = "37";
            char * z = x + y;
        
        上面的例子，结果可能和你想的完全不一样。由于 C 语言的底层特性，这个例子中的 z 会指向一个超过
        y 地址 5 个字节的内存地址，相当于指向 y 字符串的指针之后的两个空字符处。
        
        任何语言都有类型系统，只是动态类型语言在运行时做类型检查。动态语言的代码复杂度比较低，并可以更
        容易地关注业务，在某些场景下是对的，但有些情况下却并不见得。
        
        比如，在 JavaScript 中，我们需要做一个变量转型的函数，可能是下面这个样子：
        
            functon ToNumber(x){
                swith(typeof x){
                    case "number":return x;
                    case "undefinde":return NaN;
                    case "boolean":return x?1:0;
                    case "string":return Number(x);
                    case "object":return NaN;
                    case "function":return NaN;
                }    
            }    
        
        动态语言中代码中你可以看到大量类似 typeof 这样的类型检查代码。是的，这是动态类型带来的另一个问题，
        就是运行时识别（这个是比较耗性能的）。
    
    2、泛型的本质：
    
        a. 类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。
        
        b. 不同的类型，有不同的操作，所以，对于特定的类型，也有特定的一组操作。
        
        所以，要做到泛型，我们需要做下面的事情：
        
            a. 标准化掉类型的内存分配，释放和访问。
        
            b. 标准化掉类型的操作。比如：比较操作、I/O 操作、复制操作...
        
            c. 标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法...
        
            d. 标准化掉类型上特有的操作，需要由标准化的接口来回调不同类型的具体操作...
        
        所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标。
        
            a. 通过类中的构造、析构、拷贝构造、重载赋值操作符、标准化(隐藏)了类型的内存分配、释放和复制的操作。
            
            b. 通过重载运算符，可以标准化类型的比较等操作。
            
            c. 通过 iostream, 标准化了类型的输入输出控制。
            
            d. 通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。
            
            e. 通过迭代器的标准化数据容器的遍历操作。
            
            f. 通过面向对象的接口依赖(虚函数技术)，来标准化了特定类型在特定算法上的操作。
            
            g. 通过函数式（函数对象），来标准化对于不同类型的特定操作。
            
        本质就是- 屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中
        处理不同的数据类型。
        
    3、小结：
    
        在编程语言中，类型系统的出现主要是对容许混乱的操作加上了严格的限制，以避免代码以无效的数据使用方式编译或运行。
        例如，在整数运算不可用于字符串，指针操作不可用于整数上，等等，但是，类型的生产和限制，虽然对底层代码来说是安全的，
        但是，对于更高层次的抽象产生了负面因素。比如，C++ 语言中，为了同时满足静态类型和抽象，就导致了模板技术的出现，
        带来了语言的复杂性。
        
        我们需要清楚的明白，编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注业务逻辑代码，
        但是因为，编程语言作为机器代码和业务代逻辑的结合层，是在程序员可以控制更多底层的灵活性，还是屏蔽底层
        细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。
        
        所以，不同的语言在设计上都会做相应的取舍，比如：C 语言偏向于让程序员可以控制更多底层细节。
        而java 和 python 则让程序员更多关注于业务功能的实现。而 C++ 则是两者都想要，导致语言在设计上非常复杂。
        
        强制类型和动态类型是两码事，前者是判断不同的类型是否可以互转，后者是变量的类型可以动态调整。
        
        
"""33| 编程范式游记(4) - 函数式编程"""             
                    
     C++ 很多程度上解决了 C 语言中的各种问题和不便，尤其是通过 类、模板、虚函数和运行时识别等解决了 C 语言的
     泛型编程问题。然而，如何做更为抽象的泛型呢？答案就是函数式编程（Function Programming）
                   
     1、起源：
        
        相对计算机的历史而言，函数式编程其实是一个非常古老的概念。函数式编程的基础模型来源于 λ 演算，
        而 λ 演算并没有设计在计算机上执行。它是由 Alonzo Church 和 Stephen ColeKleene 在 20 世纪
        30 年代引入的一套用于研究函数定义、函数应用和递归的形式系统。
        
        如 Alonzo 所说，像 booleans、integers 或者其他的数据结构都是可以被函数取代掉。
        我们来看一下函数式编程，它的理念就是来自于数学中的代数。
        
            f(x) = 5x^2 + 4x + 3
            g(x) = 2f(x) + 5 = 10x^2 + 8x + 11
            h(x) = f(x) + g(x) = 15x^2 + 12x + 14
            
        假设 f(x) 是一个函数， g(x) 是第二个函数，把 f(x) 这个函数套下来，并展开。
        然后，还可以定义一个由两个一元函数组成的二元函数，还可以做递归，下面这个函数定义就是斐波那契数列。
        
            f(x) = f(x - 1) + f(x - 2)
            
        对于函数式编程来说，它只关心定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射(mapping)
        输入的数据和输出的数据关系是什么样的，是用函数来定义的。
        
     2、函数式编程有一下特点：
        
        特征：
        
            stateless: 函数不维持任何状态。函数式编程的核心精神是 stateless，简而言之就是它不能存在状态，
                        打个比方，你给我数据我处理完扔出去，里面的数据是不变的。
                        
            immutable: 输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。
            
        优势：
        
            a. 没有状态就没有伤害。
            
            b. 并行执行无伤害。
            
            c. Copy-Paste 重构代码无伤害。
            
            d. 函数的执行没有顺序上的问题。
            
        函数式编程还带来了以下以下好处：
            
            a. 惰性求值：
                
                这需要编译器的支持，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。
                也就是说，语句如 x:=expression;(把一个表达式的结果赋值给一个变量)显示的调用这个表达式被
                计算并把结果放置到 x 中，但是先不管实际在 x 中的是什么，直到通过后面的表达式中到 x 的引
                用而又了对它的值的需求的时候，而后面表达式自身的求值也可以被延迟，最终为了生成让外界看到的
                某个符号而计算这个快速增长的依赖树。
                
            b. 确定性：
            
                所谓的确定性，就是像在数学中那样，f(x) = y 这个函数无论在什么场景了、都会得到同样的结果。
                而不是像程序中的很多函数那样，同一个参数，在不同的场景下会计算出不同的结果，这个就是我们
                称之为函数的确定性。所谓的不同场景，就是我们的函数会根据运行中的状态信息的不同而发生变化。
                
        我们知道，因为状态，在并行执行和 copy-paste 时引发 bug 的概率是非常高的，所以没有状态就没有伤害，
        就像没有依赖就没有伤害一样，并行执行无伤害，copy 代码无伤害，因为没有状态，代码怎样拷都行。
        
        劣势：
        
            数据复制比较严重：
            
                注：有一些人可能会觉得这会对性能造成影响。其实，这个劣势不见得会导致性能不好。
                因为没有状态，代码根本不需要锁，所以可以拼命地并发，反而可以让性能很不错。
                
            对于纯函数（也就是完全没有状态的函数）的编程来说，各个语言支持的程序如下：
            
                完全纯函数式：Haskell
                容易写纯函数：F#、Ocaml, Clojure, Scala
                纯函数需要花点精力：C#、Java、JavaScript
        
        很多人不习惯函数式编程，因为函数式编程和过程式编程的思维方式完全不一样。过程式编程是在把具体的流程描述出来
        而函数式编程的抽象更大，在实现方式上，函数套函数、函数返回函数，函数里定义函数....把人搞的很糊涂。
           
           
     3、函数式编程用到的技术：
        
        a. first class function (头等函数)
            
            这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建、修改
            并当成变量一样传递、返回，或是在函数中嵌套函数。
            
        b. tail recursion optimization (尾递归优化)
            
            我们知道递归的害处，那就是如果递归很深的话，stack 受不了，并会导致性能大幅下降。
            因此，我们使用尾递归优化技术--每次递归都会重用stack,这样能提升性能。
            当然，这需要语言或编译器的支持，python 就不支持。
            
        c. map & reduce:
            
            函数式编程最常见的技术就是对一个集合做 Map 和 Reduce 操作。
            这比起过程式的语言来说，在代码上更容易阅读。这个很像 C++ STL 中
            foreache、find_if、count_if 等函数的玩法。
            
        d. pipeline(管道)：
        
            这个技术的意思是，将函数实例成一个一个的action, 然后将一组 action 放到一个数组或是
            列表中，再把数据传给这个 action list, 数据就像一个 pipeline 一样顺序地被各个函数
            所操作，最终得到我们想要的结果。
            
        e. recursing(递归)：
            
            递归最大的好处就是简化代码，它可以把一个复杂的问题用很简单的代码描述出来。
            注意，递归的精髓是描述问题，而这正是函数式编程的精髓。          
                  
        f. currying(柯里化)：
        
            将一个函数的多个参数分解成多个函数，然后将函数多层封装起来，每层函数都返回一个函数去
            接收下一个参数，这可以简化函数的多个参数。在 c++ 中，这很像 STL 中的 bind1st或是bind2nd。
            
        g. higher order function(高阶函数)：
        
            所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。
            现象上就是函数传进传出，就像面向对象对象满天飞一样。
            
        上面这些技术太抽象了，我们从一个简单的例子开始：
        
            非函数，不是 pure function, 有状态：
            int cnt;
            void increment(){
                cnt++;
            }         
               
        这里有个全局变量，调用这个全局函数变量 ++, 这里面是有状态的，这个状态在外部。
        所以，如果是多线程的话，这里面的代码是不安全的。
        
        如果写成纯函数，应该是下面这个样子：
        
            函数式，pure function, 无状态
            int increment(int cnt){
                return cnt+1;
            }                
            
        代码随便拷贝，而且与线程无关，代码在并行时候不用锁，因为是复制了原有的数据，并返回了新的数据。
        
        再看一个例子：
        
            def inc(x):
                def incx(y):
                    return x + y
                return incx
                
            inc2 = inc(2)
            inc5 = inc(5)
            
            print intc2(5) # 输出 7 
            print intc4(5) # 输出 10
            
        把函数当成变量来用，关注描述问题而不是怎么实现，这样可以让代码更易懂。
        因为函数返回里面的这个函数，所以函数关注的是表达式，关注的是描述这个问题，而不是怎么实现这个事情。
        
                  
     4、Lisp 语言简介：
     
        要说函数式语言，不可避免地要说一下 Lisp。
        下面，我们来看看 Scheme 语言（Lisp 的一个方言）的函数式玩法。在 Scheme 里，所有的的操作都是函数，
        包括加减乘除这样的东西。所以，一个表达式是这样的形式---（函数名  参数 1 参数 1）
        
            (define (plus x y) (+ x y))
            (define (times x y) (* x y))
            (define (square x) (times x x ))
            
        上面三个函数：
        
            用内置的 + 函数定义了一个新的 plus 函数。
            用内置的 * 函数定义了一个新的 times 函数。
            用这前的 times 函数定义了一个 square 函数。
            
        下面是这个函数定义了：f(x) = 5 * x^2 + 10
            
            (define (f1 x) ;;; f(x) = 5 * x^2 + 10 (plus 10 (times 5 (square x))))
            
        也可以使用 lambda 匿名函数：
        
            (define f2
                (lambda (x)
                    (define plus
                        (lambda (a b) (+ a b)))
                    (define times
                        (lambda (a b) (* a b)))
                    (plus 10 (times 5 (times x x)))
                )
            )                          
                
        在上面的代码中，我们使用 lambda 来定义函数 f2, 然后同样用 lambda 定义了两个函数 -- plus 和 times.
        最后， 由（plus 10 (times 5(times x x))）定义了 f2。
        
        我们看一个阶乘的示例：
        
            ;;; recursion  注释
            (define factoral (lambda (x)
                (if (<= x 1) 1
                    (* x (factoral (- x 1)))))
            (newline)
            (display(factoral 6))
            
        下面是另一个版本，使用尾递归。
        
            ;;; another version of recursion  注释
            (define (factoral_x n)
                (fefine (iter product counter)
                    (if (< counter n)
                        product
                        (iter (* counter product) (+ (iter 1 1))))))
                        
            (newline)
            (display(factoral_x 5))
            
            
     5、函数式编程的思维方法：
     
        函数式编程关注的是： describe what to do, rather than how to do it。
        于是，我们把过程式编程范式叫做 Imperative Programming -- 指令式编程
        而把函数式编程范式叫做 Declarative Programming -- 声明式编程。
        
        传统方式的写法：
        
            比如，我们有 3 辆车比赛，简单起见，我们分别给这 3 辆车 70% 的概率让它们可以往前走一步，
            一种有 5 次机会，然后打出第一次这 3 量车的前行状态。
            
            Imperative Programming 代码如下：   
            
            from random import random
            
            time = 5
            car_positions = [1, 1, 1]
            
            while time:
                time -= 1
                print ''
                for i in range(len(car_positions)):
                    #move car
                    if random() > 0.3:
                        car_positons[i] += 1
                    
                    # draw car
                    print '_' * car_positions[i]
                                               
            我们可以把两重循环变成一些函数模块，这样有利于更容易的阅读代码：
            
            from random import random
            
            def move_cars():
                for i, _ in enumerate(car_positions):
                    if random() > 0.3：
                        car_positions[i] += 1
            
            def draw_car(car_position):
                print '_'*car_position 
            
            def run_step_of_race():
                global time
                time -= 1
                move_cars()
                
            def draw():
                pirnt ''
                for car_position in car_positions:
                    draw_car(car_position)
                    
            time = 5
            car_positions = [1, 1, 1]
            
            while time:
                run_step_of_race()
                draw()
                
            你会发现，封装成函数后，这些函数都会依赖于共享的变量来同步其状态，于是，在读代码的过程中，
            每当我们进入到函数里，读到访问了一个外部的变量时，我们马上要去查看这个变量的上下文，然后
            还要在大脑里推演这个变量的状态，才能知道程序的真正逻辑。也就说，这些函数必须知道器它函数
            是怎么修改它们之间的共享变量的，所以，这些函数是有状态的。
        
        函数式的写法：
            
            我们知道，有状态并不是一件很好的事情，无论是对代码重用和是并行处理，都有副作用。
            因此，我们想个办法把这些状态搞掉，于是就出现了函数式编程的编程范式。
            下面我们看看，这个函数式的方法应该怎么写？
            
            from random import random
            
            def move_cars(car_position):
                return map(lambda x:x + 1 if random() > 0.3 else x, car_position)
                
            def output_car(car_position):
                return '_'*car_position
                
            def run_step_of_rance(state):
                return {'time':state['time'] - 1,'car_positions':move_cars(state['car_positions'])}
                
            def draw(state):
                print ''
                print '\n'.join(map(output_car,state['car_positions']))
                
            def race(state):
                draw(state)
                if state['time']:
                    race(run_step_of_race(state))
                    
            race({'time':5,'car_positions':[1,1,1]})                        
                
            上面的这些函数间通过参数和函数值来传递数据，在函数里没有临时变量。    
            
            
     6、函数式语言里的三套件：
     
        函数式语言里的三套件：Map、Reduce 和 Filter
        
        我们想把一个字符串数组中的字符串够转换成小写。
        
            用常规的面向过程的方式：
                
                #传统非正式：
                upname = ['HAO','CHEN','COOLSHELL']
                lowname = []
                for i in range(len(upname)):
                    lowname.append(upname[i].lower())
                    
            如果写成函数式，用 map() 函数，是下面这个样子：
            
                #函数式
                def toUpper(item):
                    return item.upper()
                    
                upper_name = map(toUpper, ['hao','chen','coolshell'])
                
                print upper_name
                
        再看一个，计算数组平均值的代码：
        
            #计算数组中正数的平均值
            num = [2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]
            positive_num_cnt = 0
            positive_num_sum = 0
            for i in range(len(num)):
                if num[i] > 0:
                    positive_num_cnt += 1
                    positive_num_sum += num[i]
                    
            if posivite_num_cnt > 0:
                average = positive_num_sum /positive_num_cnt
                
            print average
            
        函数式，使用 filter/reduce 函数：
        
            #计算数组中帧数的平均值：
            positive_num = filter(lambda x: x>0, num)
            average = reduce(lambda x, y: x + y, positive_num) / len(positive_num) 
            
        函数式编程，只是描述问题怎么干，不关心业务要干什么
        
     7、函数式的 pipeline 模式：
     
        pipeline(管道) 借鉴于 Unix  shell 的管道操作--把若干命令串联起来，前面命令的输出成为
        后面命令的输入，如此完成一个流式计算。
        
        比如我们的 shell 命令：
            
            ps auwwx | awk '{print $2}' | sort -n | xargs echo
            
        抽象成函数的样子，我们可以反过来，一层套一层：
        
            xargs(echo, sort(n, awk('print $2', ps(auwwx))))
            
        我们也可以把函数放进数组里面，然后顺序执行一下：
        
            pids = for_each(reuslt, [ps_auwwx, awk_p2, sort_n, xargs_echo])
            
        如果我们把函数比作微服务，那么管道这个是其实就是在做服务的编排。
        一个好的分布式架构师，通常都是对这些传统的微观上的经典技术有非常深刻的认识，
        因为这些东西在方法论上都是相通的。
        
        看一下如何实现 pipeline, 这个程序的 process() 有三个步骤：找出偶数、乘以3、转成字符串返回。
        
            传统非函数式的实现：
            
                def process(num):
                    if num%2 != 0:
                        return
                    num = num*3
                    num = 'The Number: %s' % num
                    return num
                    
                nums = [1,2,3,4,5,6,7,8,9,10]
                
                for num in nums:
                    print process(num)
                    
            我们来看一下pipeline 该怎么写：
            
                第一步，先把三个字需要写成函数：
                
                def even_filter(nums):
                    for num in nums:
                        if num % 2 == 0:
                            yield num
                            
                def multiply_by_three(nums):
                    for num in nums:
                        yield num * 3
                
                def convert_to_string(nums):
                    for num in nums:
                        yield 'The Number:%s' % num
            
            然后，我们把这个三个函数串起来：
            
                nums = [1,2,3,4,5,6,7,8,9,10]
                
                pipeline = convert_to_string(multiply_by_three(even_filter(nums)))
                for num in pipeline:
                    print num
                    
            我们使用 Map & Reduce, 不要使用循环：
            
                def even_filter(nums):
                    return filter(lambda x: x%2 == 0, nums)
                    
                def multiply_by_three(nums):
                    retirn map(lambda x: x*3, nums)
                    
                def convert_to_string(nums):
                    return map(lambda x: 'The Number:%s' % x, nums)
                    
                nums = [1,2,3,4,5,6,7,8,9,10]
                pipeline = convert_to_string(
                        multiply_by_three(
                            even_filter(nums)
                        )
                )
                
                for num in pipeline:
                    print num
                    
            第二种方式：
                
                pipeline_func(nums, [even_filter, multiply_by_three, convert_to_string])
                                             
            其实，就是一堆函数做一个 reduce, 于是， pipeline 函数可以实现成下面这样：
            
                def pipeline_finc(data, fns):
                    return reduce(lambda a, x: x(a), fns, data)
                    
            当然，使用 Python 的 force 函数以及 decorator 模式可以把上面的代码写的更像管道：
            
                class Pipe(object):
                    def __init__(self, func):
                        self.func = func
                        
                    def __ror__(self, other):
                        def generator():
                            for obj in other:
                                if obj is not None:
                                    yield.self.func(obj)
                        return generator()
                
                @Pipe
                def even_filter(num):
                    return num if num % 2 == 0 else None
                    
                @Pipe
                def multiply_by_three(num):
                    return num*3
                        
                @Pipe
                def conver_to_string(num):
                    return 'The Number: '%s' % num
                    
                @Pipe
                def echo(item):
                    print item
                    return item
                    
                def force(sqs):
                    for item in sqs: pass
                    
                nums = [1,2,3,4,5,6,7,8,9,10]
                force(nums | even_filter | multiply_by_three | convert_to_string | echo)
                
     8、小结：
     
        相对于计算机发展史，函数式编程是个非常古老的概念，它的核心思想是将运算过程尽量写一些列的嵌套
        的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。
        以 Stateless (无状态) 和 Immutable(不可变)为主要特点，代码简洁、易于理解、能便于进行并行
        执行，易于做代码重构，函数执行没有顺序的问题，支持惰性求值，具有函数的确定性。
        
        本文结合递归、map 和 reduce, 以及 pipeline 等技术，对比了非函数式编程和函数式编程在解决
        相同问题时的不同处理思路，让你对函数式编程范式有明确的认知。           
                                     
                       
"""34| 编程范式游记(5) - 修饰器模式"""                      
    
    在上一篇我们介绍了函数式编程，主要讲了函数式编程的主要技术：递归、Map、Reduce、Filter 等。
    并利用 Python 的 Decorator 和 Generator 功能，将多个函数组成了管道。
    
    本文主要讲述 “Decorator 模式”，又叫 “修饰器模式” 或是“装饰器模式”
    
    1、 Python 的 Decorator:
        
        Python Decorator 完全是语言层面的玩法：一种函数式编程技巧。
            
        看一个 Python 修饰器的 Hello World 代码：
        
            def hello(fn):
                def wrapper():
                    print "hello, %s" % fn.__name__
                    fn()
                    print "goodbye, %s" % fn.__name__
                return wrapper
            
            @hello
            def Hao():
                print "I am Hao Chen"
                
            Hao()
            
        我们看一个带参数的玩法：
        
        def makeHtmlTag(tag, *args, **kwds):
            
            def real_decorator(fn):
                css_class = " class='{0}'".format(kwds["css_class"]) if "css_class" in kwds else ""
                
                def wrapped(*args, **kwds):
       
                    return "<"+tag+css_class+">"
                
                return wrapped
            return real_decorator
            
        @makeHtmlTag(tag="b", css_class = "bold_css")
        @makeHtmlTag(tag="i", css_class = "italic_css")
        def hello():
            return "hello world"
            
        print hello()
        
    2、小结：
    
        a. 表面上看，装饰器模式就是扩展现有的一个函数的功能，让它可以干一些其他的事情，
            或是现有的函数功能上再附加上一些别的功能。
            
        b. 除了我们可以感受到函数式编程下的代码扩展能力，我们还能感受到函数的互相和随意
            拼装带来的好处
            
        c. Decorator 这个函数其实是可以修饰几乎多有的函数的，于是，这种可以通用与其他函数的编程方式
            可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来。

"""35| 编程范式游记（6）- 面向对象编程 """
    
    函数式编程总结起来就是把一些功能或逻辑代码通过函数拼装方式来组织的玩法。
    这其中涉及最多的是函数，也就是编程中的代码逻辑。
    我们知道，代码中还需要处理数据的，这些就是所谓的“状态”。
    函数式编程需要我们写出无状态的代码，对于状态和数据的处理，我们需要“面向对象的编程”（Object-oriented programming,缩写为 OOP）
    
    面向对象编程的三大特性：封装、继承、多态
    
    面向对象编程是一种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。
    它可能包含数据、属性、代码和方法。对象则指的是类的实例。
    它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性，灵活性和可扩展性，
    对象里的程序可以访问及修改对象相关联的数据。
    在面向对象编程里，计算机程序会被设计成彼此相关的对象。
    
    面向对象程序设计可以看做一种在程序中包含各种独立而又相互调用的对象的思想，这与传统的思想刚好相反：
    传统的程序设计主张将程序看作一些列函数的集合，或者直接就是一系列对计算机下达指令。
    面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其他对象，
    因此它们都可以被看作一个小型的“机器”即对象。
       
    1. 面向对象的核心理念：
        
        a. Program to an interface, not an implementation
        
            使用者不需要知道数据类型、结构、算法的细节。
            
            使用者不需要知道实现的细节，只需要知道提供的接口。
            
            利于抽象、封装、动态绑定、多态。
            
            符合面向对象的特质和理念。
            
        b. Favor object composition over class inheritance
        
            继承需要给子类暴露一些父类的设计和实现细节。
            
            父类实现的改变会造成子类也需要改变。
            
            我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。
            
            继承更多的应该是为了多态。
           （多态（Polymorphism）按字面的意思就是“多种状态”。
            在面向对象语言中，接口的多种不同的实现方式即为多态。）
             
        和函数式编程来比较，函数式强调动词，而面向对象强调名词，面向对象更多的关注接口间的关系
        而通过多态来适配不同的具体实现。
        
        下面几个面向对象的事情：
        
            a. 我们使用接口抽象了具体的实现类
            
            b. 然后其他类耦合的是接口而不是实现类，这就是多态，其增加了程序的可扩展性
            
            c. 这就是接口编程，所谓接口也就是一种“协议”，就像 HTTP 协议一样，而不是具体实现。
            
            d. 这就是面向对象编程范式的精髓，同样也是 IoC/DIP（控制反转/依赖倒置）的本质。
            
            
    2. IoC 控制反转：
        
        IoC 的概念提出来很多年了，其被用于一种面向对象的设计。
        
        我们发现这个开关可能还要控制别的不单单是灯泡的东西，就会发现这个开关耦合了灯泡这种类别
        非常不利于扩展，于是反转控制出现了。
        
        就像现实世界一样，造开关的工厂根本不需要关心控制的东西是什么，它只做一个开关应该做好的事，
        就是把电接通，把电断开。而造灯泡的工厂也不关心你用在什么开关，反正我只管把灯的电源接口给做出来。
        然后，开关厂和电灯厂依赖一个标准的通电和断电的接口。于是产生了 IoC 控制反转。
        
        所谓控制反转的意思是，开关从以前设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来
        依赖于开关厂声明的电源连接接口。只要符合开发厂定义的电源连接接口，这个开发可以控制这个电源连接
        接口的设备。也就是说，开关从依赖设备这种情况，变成了，设备反过来依赖于开关所定义的接口。
        
        我们每天都在标准化和定制化中纠结，我们痛苦于那些应该是平台要做的，那些应该要甩出去的。
        这里面会出现大量的与业务无关的软件或中间件，包括协议、数据、接口...
        通过面向对象的这些方式，我们可以通过抽象来解耦，通过中间件来解耦，这样可以降低软件的复杂度。
        总而言之，我们就是想通过一种标准来让业务更为规范。
        
    3. 面向对象的优缺点：
    
        a. 优点
        
            能和真实的世界交相辉映，符合人的直觉
            
            面向对象和数据库模型设计类型，更多地关注对象间的模型设计
            
            强调与“名词”而不是“动词”，更多的关注对象和对象间的接口
            
            根据业务的特征形成了一个个高内聚的对象，有效地分离了抽象和具体实现
            增强了可重用性和可扩展性。
            
            拥有大量非常优秀的设计原则和设计模式
            
            S.O.L.I.D(单一功能、开闭原则、里氏替换、接口隔离以及依赖反转、是面向对象设计的5个基本原则)
            
        b. 缺点
        
            代码都需要依附着在一个类上，从一个侧面上说，其鼓励了类型
            
            代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”
            
            因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。
               
               
"""36| 编程范式游记（7）- 基于原型的编程范式 """ 

    基于原型（prototype）的编程其实也是面向对象编程的一种方式。
    没有 class 化的，直接使用对象。又叫，基于实例的编程。
    其主流的语言是 JavaScript，与传统的面向对象编程的比较如下：
    
    a. 在基于类的编程当中，对象总共有两种类型。
        类定义了对象的基本布局和函数特性，而接口是“可以使用的”对象，它基于特定类的样式。
        在此模型当中，类表现为行为和结构的集合，对所有接口来说这些类的行为和结构都是相同的。
        因而，区分规则首先是基于行为和结构，而后才是状态。
        
    b. 原型编程的主张者经常争论说，基于类的语言提倡使用一个关注分类和类之间关系的开发模型。
        而原型编程看起来提倡程序员关注一些列对象实例的行为，而之后才关心如何将这些对象划分
        到最近的使用方式相似的原型对象，而不是分成类。
        
    因此，很多基于原型的系统提倡运行时原型的修改，而只有极少基于类的面向对象系统允许在程序运行时被修改。
    
    c. 基于类的语言中，一个新的实例通过类构造器和构造器可选的参数来构造，结果实例由类选定的行为和布局创造模型。
    
    d. 在基于原型的系统中构造对象有两种方法，通过复制已有的对象或者通过扩展空对象创建。
            
    1、JavaScript 的原型概念：
    
       var foo = {name:"foo",one:1, two:2};
       
       var bar = {three:3}
       
       每个对象都有一个 __proto__ 的属性，这个就是“原型”。对于上面的两个对象，
       如果我们把 foo 赋值给 bar.__proto__, 那就意味着，bar 的原型就成了 foo 的。
       
       bar.__proto__ = foo
       
       于是，我们可以在 bar 里面访问 foo 的属性了。
       
       bar.one // 1
       bar.three //3
       bar.name = "bar"
       foo.name //"foo"
       bar.name //"bar"
       
       需要说明一下JavaScript 的两个东西，一个是__proto__, 另一个是 prototype：
       
       a. __proto__ 主要是安放在一个实际的对象中，用它来产生一个链接，一个原型链接，用于寻找方法名或属性，等等。
       
       b. prototype 是用于 new 来创建一个对象时构造 __proto__ 用的。它是构造函数的一个属性。
       
       我们可以简单的认为，__proto__ 是所有对象用于链接原型的一个指针，而 prototype 则是 Function 对象的一个属性
       其主要是用来当需要 new 一个对象时让 __proto__ 指针所指针的地方。
       对于超级对象 Function 而言， Function.__proto__ 就是 Function.prototype。
        
       var a = {
            x: 10
            calculate: function(z){
                return this.x + this.y + z;
            }
       };
       
       var b = {
            y:20
            __proto__: a
       };
       
       var c = {
            c:30,
            __proto__:a
       }      
       
       b.calculate(30); // 60
       c.calculate(40); // 80
        
       再看另一段代码：
       
       // 一种构造函数写法
       function Foo(y){
           this.y = y
       }   
       
       // 修改 Foo 的 prototype, 加入一个成员变量 x
       Foo.prototype.x = 10
       
       // 修改 Foo 的 prototype, 加入一个成员函数 calculate
       Foo.prototype.caculate = function(z){
            return this.x + this.y + z;
       }
       
       // 现在，我们用 Foo 这个原型来创建 b 和 c
       var b = new Foo(20);
       var c = new Foo(30);
       
       // 调用原型中的方法，可以得到正确的值
       b.calculate(30); //60
       c.calculate(40); //80
       
       Foo.prototype 自动创建了一个属性
       constructor 这是一个指向函数自己的一个 reference。这样一来，对于实例 b 或 c 来说
       就能访问到这个继承的 constructor 了。
       
    2、 JavaScript 原型编程的面向对象
    
        function Person(){}
        var p = new Person();
        
        Person.prototype.name = "Hao Chen";
        Person.prototype.sayHello = function(){
            console.log("Hi, I am" + this.name)
        }   
        
        console.log(p.name); // "Hao Chen"
        p.sayHello(); // "Hi, I am Hao Chen"
        
        在上面的例子中：
        
        a. 我们先生成了一个空的函数对象 Person();
        
        b. 然后将这个空的函数对象 new 出另一个对象， 存在 p 中；
        
        c. 这时再改变 Person.prototype, 让其有一个 name 的属性和一个 sayHello() 的方法；
        
        d. 我们发现，另外那个 p 的对象也跟着一起改变了。
        
        注意一下：
        
        a. 当创建 function Person(){} 时，Person.__proto__ 指向 Function.prototype;
        
        b. 当创建 var p = new Person() 时，p.__proto__ 指向 Person.Prototype;
        
        c. 当修改了 Person.prototype 的内容后，p.__proto__的内容也被改变了。
        
        
    3、在“原型编程”中面向对象的编程玩法:
    
        首先，定义一个 Person 类
        
        // Define human class
        var Person = function(fullName, email){
            this.fullName = fullName;
            this.email = email;
            
            this.speak = function(){
                console.log("I Speak English");
            };
            
            this.introduction = function(){
                console.log("Hi, I am" + this.fullName);   
            };
        }
        
        上面的对象中，包含了：
            属性：fullName 和 email
            方法：speak() 和 introduction()
            
        其实，方法也是属性
        
        然后，我们定义一个 Student 对象
        
        // Define Student class
        var Student = function(fullName, email, school, course){
            
            Person.call(this, fullName, email);
            
            //Initiallize our Student Propertites
            this.school = school;
            this.courses = courses;
            
            //override the "introduction" method
            this.introduction = function(){
                console.log("Hi, I am" + this.fullName + "I am study of" + this.school + this.courses)
                
            };
            
            //Add a "exams" method
            this.takeExams = function(){
              console.log("This is my exams time")  
            };
    
        }
        
        在上面的代码中：
        
            a. 使用了 Person.call(this, fullName, email)，call() 或 apply() 都是为了动态
                改变 this 所指向的对象的内容而出现的。这里的 this 就是 Student.
                
            b. 我们重载了introduction()方法，并新增了一个 takeExams() 的方法。
            
            虽然，我们这样定义了 Student, 但是它还没有和 Person 发送继承关系。为了让
            它们发生关系，我们需要修改 Student 的原型。
            
            我们可以简单粗暴的赋值： Student.__proto__=Person.prototype.
            我们还可以使用比较规范的方式：
            
            先用 Object.create() 来将 Person.prototype 和 Student.prototype 关联上。
            然后，修改一下构造函数 Student.prototype.constructor = Student;
            
            //Create a Student.prototype object that inherits
            //from Person.prototype
            Student.prototype = Object.create(Person.prototype);
            
            //set the "constructor" property to refer to Student
            Student.prototype.constructor = Student;
            
            这样，我们就可以使用了
            var student = new Student("Hao chen","aa@tom.com","xyz","ddd")
            student.intorduction();
            student.speak();
            studnet.takeExams();
            
    4、小结：
    
        上述就是基于原型的面向对象编程的玩法，
        这种玩法就是基于委托的方式。在使用委托的基于原型的语言中，
        运行时语言可以“仅仅通过序列的指针找到匹配”这样的方式来定位属性或者寻找正确的数据。
        所有这些创建行为共享的行为需要的是委托指针。


"""37|编程范式游记（8）- Go 语言的委托模式"""        
                    
                



"""38|编程范式游记（9）- 编程的本质"""           
        
    程序 = 数据结构 + 算法
    算法 = 逻辑 + 控制
    
    任何一个算法都会有两个部分，一个是 Logic 部分，这是用来解决实际问题的。
    另一个是 Control 部分，这是用来决定用什么策略来解决问题。
    Logic 部分是真正意义上的解决问题的算法，而Control 部分只是影响解决这个问题的效率。
    程序的效率问题和程序的逻辑其实是没有关系的。我们认为，如果将Logic 和 Control 部分
    有效的分开，那么代码就会变的更容易改进和维护。
    
    1、编程的本质：
    
        Programs = Algorithms + Data Structures
        Algorithm = Logic + Control
        
        第一个表达式倾向于数据结构和算法，它是想把这两个拆分，早期都是走这条路。
        他们认为，如果数据机构设计得好，算法也会变的简单，而且一个好的通用
        的算法应该可以用在不同的数据结构上。
        
        第二个表达式则想表达的是数据结构不复杂，复杂的是算法，也就是我们的业务逻辑是复杂的。
        我们的算法由两个逻辑组成，一个是真正的业务逻辑，另一个是控制逻辑。
        程序中的两种代码，一种是真正的业务逻辑代码，另一种代码是控制我们程序的代码，叫控制代码，
        这根本不是业务逻辑，业务逻辑不关心这个事情。
        算法的效率往往可以通过提高控制部分的效率来实现，而无须改变算法的意义。

        总之，通过两个表达式，我们可以得出：
    
        Program = Logical + Control + Data Structures
        
        前面讲的编程范式或程序设计方法，其实都是围绕这三件事来做的。
        
        a. 就像函数式编程中的 Map/Reduce/Filter，它们都是一种控制。
            而传给这些控制模块的那个 Lambda 表达式才是我们要解决的问题的逻辑。
            他们共同组成了一个算法，最后，我们再把数据放在数据结构里进行处理，最终成为了我们的程序。
            
        b. 就像我们面向对象中依赖于接口而不是实现一样，接口是对逻辑的抽象，真正的逻辑放在不同
            的具现类中，通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理。
            
        c. Control 是可以标准化的，比如：遍历数据、查找数据、多线程、并发、异步等，都是可以标准化的。
        
        d. 因为 Control 需要处理数据，所以标准化 Control, 需要标准化 Data Structure 
            我们可以通过泛型编程来解决这个事。
  
        e. 而 Control 还要处理用户的业务逻辑，即 Logic. 所以，我们可以通过标准化接口/协议来实现，
            我们的 Control 模式可以适配与任何 Logic。
            
        总上所述，就是编程范式的本质：
        
        有效的分离 Logic、Control 和 Data 是写出好程序的关键所在。
        
        Logic 它是程序复杂度的下限，然后，我们为了控制程序，需要再搞出很多控制代码，
        于是 Logic + Control 的相互交织成为了最终程序的复杂度。
        
    2、把逻辑和控制混淆的示例：
    
        给两个字符串匹配，需求如下：
        
            isMath("aa","a") -> false
            isMath("aa","aa") -> true
            isMath("aaa","aa") -> false
            isMath("aa","*") -> true
            isMath("aa","a*") -> true
            isMath("ab","?*") -> true
            isMath("aab","c*b*a") -> false
            
        代码如下：
        
            bool isMatch(const char *s, const char *p){
                const char *last_s = NULL;
                const char *last_p = NULL;
                
                while (*s != '\0'){
                    if(*p == "*"){
                        p++;
                        if(*p == '\0') return true;
                        last_s = s;
                        last_p = p;
                    }else if(*p == '?' || *s == *p){
                        s++;
                        p++;
                    }else if(last_s != NULL){
                        p = last_p;
                        s = ++last_s;
                    }else{
                        return false;
                    }
                }
                while (*p == '*')p++;
                return *p == '\0'
            }                     
        
        上面的代码都不是业务逻辑，是用控制程序的逻辑。
        怎么把上面的diam写得更好一些呢？
        
            a. 首先，我们需要一个比较通用的状态机（NFA,非确定有限自动机，DFA,确定性有限自动机）
                来维护匹配的开始和结束的状态，这属于 Control。
                
            b. 还可以抽像出一个像程序的文法分析一样的东西，也就是 Control。
            
            c. 然后，我们把匹配"*" 和 "?" 的算法形成不同的匹配策略。
            
        程序的本质是 Logic + Control + Data，而其中 Logic 和 Control 是关键。
        注意，这个和系统架构也有相通的地方，逻辑是你的业务逻辑，逻辑过程的抽象，
        加上一个由术语表示的数据结构的定义。
        控制逻辑跟你的业务逻辑是没有关系的，你控制它执行。控制一个程序流转的方式，即程序执行的方式，
        并行还是串行，同步还是异步，以及调度不同执行路径或模块，数据之间的存储关系，这些和业务逻辑没有关系。
        
        如果你看到混乱不堪的代码，你会发现其中最大的问题是 Logic 和 Control 纠缠在一起，导致
        代码很混乱，难以维护，Bug很多。
        
    3、小结：
    
        业务逻辑的复杂度决定了代码的复杂度
        控制逻辑的复杂度 + 业务逻辑的复杂度 ==> 程序代码的混乱不堪
        绝大多数程序复制混乱的根本原因：业务逻辑与控制逻辑的耦合。
        
        State Machine:
        
            状态定义
            状态变迁条件
            状态的 action
            
        编程范式：
        
            面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC...
            
            函数式编程：修饰、管道、拼接
            
            逻辑推导式编程：Prolog
            
        编程的本质：
        
            Logic 部分才是真正有意义的（what）
            
            Control 部分只是影响 Logic 部分的效率（How）
            
            
"""39|编程范式游记（10） - 逻辑编程范式"""                
            
    1、Prolog 语言：
        Prolog（Programming in Logic的缩写）是一种逻辑编程语言。
        它建立在逻辑学的理论基础之上， 最初被运用于自然语言等研究领域。
        现已广泛的应用在人工智能的研究中，可以用来建造专家系统、自然语言理解、智能知识库等。
        同时对一些通常的应用程序的编写也很有帮助，能够比其他的语言更快速地开发程序，
        因为它的编程方法更像是使用逻辑的语言来描述程序。
                   
    2、下面是逻辑编程范式的几个特征：
    
        a. 逻辑编程的要点是将正规的逻辑风格带入计算机程序设计中。
        
        b. 逻辑编程建立了描述一个问题的世界的逻辑模型。
        
        c. 逻辑编程的目标是对它的模型建立新的陈述。
        
        d. 通过陈述事实 -- 因果关系。
        
        e. 程序自动推导出相关的逻辑。
           
    3、小结：
    
        Prolog 这种逻辑编程，把业务逻辑或是算法抽象成只关系规则，事实和问题的推导
        这样的标准方式，不需要关系程序控制，也不需要关系具体的实现算法。
        只需要给出可以推导的规则和相关的事实，问题就可以被通过逻辑推导来解决掉。
        
        
"""40|编程范式游记（11） - 程序世界里的编程范式"""

                    
        
   
        
        
        
    
              
    
        
            
                         
                
                
    
































