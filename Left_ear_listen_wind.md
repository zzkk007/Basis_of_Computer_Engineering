"----------------------------------------------------------------------"

                本篇是学习极客时间陈皓专栏<左耳听风>学习笔记

"----------------------------------------------------------------------"

"""01: 程序员如何用技术实现变现(上) """

    1、写程序是一门"手艺活"，要不断锤炼自己的本领。
       要去经历大多数人经历不到的，要把学习时间花在那些比较困难的地方

    2、写文章就要写没有人写过的，或是别人写过，但我能写的更好的。

    3、更重要的是，技术和知识完全是可以变现的。

    4、25 ~ 35 是每个人最宝贵的时光，应该用在刀刃上。

    5、技术和技能保持领先，对技术本质和趋势保持敏感度。

"""02: 程序员如何实现技术变现（下）"""

    1、千里之行，积于跬步，功夫下在平时，时刻积累。

    2、关注有价值的东西，关注市场需求(每三个月更新一下简历)，
        关注技术趋势（一年学习一门新语言，将老技术本质吃透）
        学习技术的过程中一定问自己两个问题：
         （1） 这个技术解决什么问题？为什么同类技术做不到。
         （2） 为什么是这样解决问题，有没有更好的方式。
    3、找到能体现自己价值的地方。高速发展的公司或部门

    4、加强动手能力，不要光看，要去动手去实现，去体会其中的奥妙

    5、关注技术付费点：
        （1）一个是，能帮助别人"挣钱"的地方。
        （2）另一个是，能帮助别人"省钱"的地方。

    6、提升自己的能力和经历

    7、找到有价值的信息源
        向比自己高两级的人学习

    8、输出观点和价值观

    9、朋友圈很重要

    会挣钱的人一定是会投资的人，最宝贵的财富不是钱，而是你的时间，时间比钱
    跟宝贵，因为钱不用还在那里，而时间不用就浪费掉了。把你的时间投资在那些
    地方，意味着你未来会走什么样的路。所以，利用好你的时间，做有意义的事情。

"""03、04: 从 Equifax 信息泄露看数据安全 """

    1、数据库泄露攻击：

         (1)利用程序框架或库的已知漏洞，比如这次 Equifax 被攻击，就是通过
         Apache Struts 的已知漏洞。RSA 被攻击，也是利用 Adobe Flash 漏洞。

         (2)暴力破解密码。利用密码字典或已经泄露的密码来"撞库"

         (3)代码注入。通过程序员代码的安全性问题，如 SQL 注入， XSS 攻击，
             CSRF 攻击等取得用户的权限。

         (4) 利用程序日志不小心泄露的信息。

         (5) 社会工程学，员工的安全意识。

    2、数据管理上的问题

        （1）只有一层安全。Equifax 被黑客攻破了管理面板和数据库就造成泄露。

        （2）弱密码，不应该让用户设置如此简单的密码，而且要定期更换，最好
            通过数字证书、
            VPN（Virtual Private Network虛拟私人网络
            是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。
            虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内部网的网络讯息。
            它利用已加密的隧道协议（Tunneling Protocol）来达到保密、发送端认证、
            消息准确性等私人消息安全效果。）

            双因子验证的方式登录（双因子认证（2FA）是指结合密码以及实物（信用卡、SMS手机、令牌或指纹等生物标志）
            两种条件对用户进行认证的方法。）。

        （3）向公网暴露了内部系统。（公司网络管理出现问题）

        （4）对系统及时打安全补丁，监控业内的安全漏洞事件，及时做出响应。

        （5）安全日志被暴露。

        （6）保存了不必要保存的用户数据。（用户的信用卡、有效期、姓名和CVV码
             这些信息足矣让人在网上盗刷信用卡。其实对于临时支付来说，这些信息
             完全不必保存在磁盘上，临时在内存中处理完毕立刻销毁）

        （7） 密码没有合理的散列。散列目前公认为最安全的算法（SHA-2 256）
              二是加一个安全随机数作为盐（salt）

    3、专家建议：

        （1）理解你的软件产品中使用了那些支持性框架和库，它们的版本号，时刻
             跟踪这些产品的版本和安全声明。

        （2）建立一个流程，来快速地部署带有安全补丁的软件产品发布版，这样一旦需要
            因为安全方面的原因更新支持性框架或库，就可以快速发布。
            系统自动化测试机制

        （3）所有复杂的软件都有漏洞。不要基于"支持性软件产品没有安全性漏洞"
            的假设来建立安全策略。

        （4）建立多个安全层。在一个面向公网的表示层后面建立多级安全防护的层次，
            是一种良好的软件工程实践。及时表示层被攻破，后台资源也没有访问权。

        （5）针对公网资源，建立异常访问模式的监控机制。

    4、技术上安全做法：

        一个系统最好安全防范到自己内部员工都能防，把重要数据隔离出来，
        隔离到一个安全级别高的地方，这个地方需要各种安全审计、安全监控、
        安全访问。提供特殊接口，这能在区域操作能操作数据，而并不能把数据
        传出去。

        例如，用户手机号信息，如有外部系统需要手机号，一般是想发个短信，
        那么，这个掌管手机号数据系统就对外提供发短信功能，而外部通过
        UID或是被的抽象字段来调用这个系统的发短信API,信用卡也一样，
        提供信用卡的扣款 API,而不是把卡号返给外部系统。

        如果外部系统必须返回数据，一般来说，最终用户可能需要读取自己的数据
        那么像信用卡这样的安全数据死也不能返回，只能返回一个被"马赛克"的
        数据。

        而用户的加密算法一定采用非对称加密的方式，还要加上秘钥的自动更换。
        如，外部系统调用100次或是一个小时后自动更换秘钥。

        最后关键信息传到外部需要做通知，最后通知用户和管理员，并限制外部系统
        访问数量，超过需要报警或限制访问。

        安全还在于"风控"，把风险限制在一个很小的范围内，如果出现一些数据泄露
        可以通过"风险基金"来做业务补偿。

"""05: 何为技术领导力"""

    1、技术重要吗？

        一个公司或国家基本上可以总结为几个发展阶段
        （1）第一阶段：野蛮开采。资源太多，重业务，轻技术
        （2）第二阶段：资源整合。资源已经被不同的人占据，需要对资源整合优化
             提高利用率，这时通过管理手段就可以实现，重管理。
        （3）第三阶段：精耕自作。对第二阶段的精细化运作，并且通过科技手段达到
        （4）第四阶段：发明创造。资源匮乏，寻找替代资源，采用高科技手段实现。

        尊重技术的公司和不尊重技术的公司在初期还不能显现，而长期来看，差距就
        很明显。

    2、什么是技术领导力？

        技术领导力不仅仅是呈现出来的技术，而是一种可以获得绝对优势的技术能力。

        （1）尊重技术，追求核心基础技术。
        （2）追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。
        （3）解放生产力，追逐人效提高。
        （4）开发抽象和高质量的可以重用的技术组件。
        （4）坚持高于社会主流的技术标准和要求。

    3、如何拥有技术领导力？

        （1）能够发现问题。发现现有方案的问题。
        （2）能够提供解决问题的思路和方案，并能比较这些方案的优缺点
        （3）能够做出正确的技术决定。用什么样的技术，什么解决方案，怎样实现完成一个项目
        （4）能够用更优雅、更简单、更容易的方式来解决问题。
        （5）能够提高代码或软件的扩展性、重用性和可维护性。
        （6）能够用正确的方式管理团队。
        （7）创新能力

        在很多团队中，大多数人是提问题的，只有很少数人在回答这些问题，或提供解决
        问题的思路和方案。
        一句话，总是在提供解决问题的思路和方案的人才是有技术领导力的人。

    4、作为软件工程师，怎么让自己拥有技术领导力，4个方面：

        （1）扎实的基础技术。
        （2）非同一般的学习能力。
        （3）坚持做正确的事。
        （4）不断提高对自己的要求标准。

"""06: 如何才能拥有技术领导力 """

    1、吃透基础技术。基础技术是各种上层技术共同的基础。

       （1）基础知识越扎实，走的越远
       （2）计算机技术太多，你会发现只是表现形式太多，基础技术并不多，
            学好基础技术能让你一通百通。
       （3）很多分布式架构、高可用、高并发的解决方案都基本上都可以在基础
            技术上找到他们的身影，基础技术让你更好掌握高维度的技术。

       那些才是基础技术：具体来说分成两个部分：编程和系统
       很枯燥乏味，一定要克服人性的软点，努力啃完。

       编程部分：
            （1） C 语言：

                更好了解计算机怎么控制底层资源

            （2）编程范式：

                各种编程语言都有他们各自的编程范式，拥有解决各种问题，
                比如面向对象的编程（c++, java）、泛型编程
                （c++, Go, C#）、函数式编程（JavaScript、Python
                Lisp、Haskell、Erlang）

                学好编程范式，有助于你提高抽象思维，同时可以提高编程效率，
                提高程序的结构合理性、可读性和可维护性、降低代码冗余度
                提高代码运行效率。了解各种程序设计语言的功能特性。

            （3）算法和数据结构：

                算法（以及相关的数据结构）是程序设计的有力支撑，适当地应用
                算法，可以有效地抽象问题，提高程序合理性和执行效率。
                算法是编程中最重要的东西，也是计算机科学中最重要的基础。

       系统部分：

            （1）计算机系统原理：

                CPU 的系统结构（指令集[CISC/RISC]、分支预测、缓存结构、总线、
                DMA、中断、陷阱、多任务、虚拟内存、虚拟化等），内存的原理与
                性能特点（SRAM, DRAM, DDR-SDRAM等），磁盘原理（机械硬盘
                [盘面、磁头臂、磁头、启停区、寻道等]、固态硬盘[也映射、块的
                合并和回收算法，TRIM指令等]），GPU的原理等。

                书籍《深入理解计算机系统》（Randal E.Rryant）

            (2) 操作系统原理和基础：

                进程、进程管理、线程、线程调度、多核的缓存一致性、信号量、
                物理内存管理、虚拟内存管理、内存分配、文件系统、磁盘管理等。

                学习操作系统的价值在于理解程序是怎样被管理的，操作系统对应用
                程序提供了怎样的支持，抽象出怎样的编程接口（比如POSIX/Win32 API）
                性能如何，怎样进行进程间通信（如管道、套接字、内存映射等）

                要学习操作系统知识，一是要仔细观察和探索当前使用的操作系统，
                二是要阅读操作系统原理相关图书，三是要阅读API文档（如 man pages
                和 MSDN Library）并编写调用操作系统功能的程序。

                书籍《UNIX 环境高级编程》、《UNIX 网络编程》和《Windows 核心编程》

                学习操作系统基础原理的好处是，这是所有程序运行的物理世界，
                物理是上层像 c/c++ 这样编译成机器码的语言，还是像 Java 这样
                有 JVM 做中间层的语言，或者 Python/PHP/Perl/Node.js这样
                直接在运行时解释的语言，其在底层都逃离不了操作系统这个物理世界
                的"物理定律"

            (3) 网络基础：

                计算机网络是现代计算机不可或缺的一部分。需要了解基本的网络层次
                结构（ISO/OSI模型，TCP/IP协议栈），

                书籍 《TCP/IP 详解》

            (4) 数据库原理：

                数据库管理系统是管理书籍库的利器

                要学习数据库，可以阅读各类数据库图书，并多做数据库操作以及
                数据库编程，多观察数据库运行时的性能。

            (5) 分布式技术架构：

                数据库和应用程序服务器对互联网上数以万计的访问量的时候，需要
                能进行横向扩展，这样才能提高足够高的性能。

                要学习分布式技术架构，包括负载均衡、DNS解析、多子域名、无状态
                应用层、缓存层、数据库分片、容错和恢复机制、Paxos、Map/Reduce操作。
                分布式 SQL 数据库一致性等知识点。

                学习分布式技术的有效途径是参与到分布式项目开发中，并阅读相关论文。

       这些基础知识不可速成，需要在平时不断地体会学习，用一生来实践。

    2、 提高学习能力，所谓的学习能力，就是能够很快地学习新技术，又能在关键技术
        上深入的能力。

        下面是提升学习能力的一些做法：

         （1） 学习的信息源：

            好的信息源就可以更快地获取有价值的信息，提升学习效率。
            Google、Stack Overflow、Quora等社区，图书、API文档、论文、博客。

         （2） 与高手交流

         （3） 举一反三的思考

         （4） 不怕困难的态度

                如果你不怕困难，并可以找到解决困难的方法和路径，时间一长
                你就能够拥有别人不能拥有的能力。

         （4） 开发的心态

                带有开发的心态，不拘泥于一个平台，一种语言，往往能带来更多思考
                也能得到更爱好的结果。

    3、 坚持做正确的事，做正确的事，比用正确的方法做事更重要，因为这样才能始终向
        目的地靠拢。

        那些是正确的事：

        (1) 提高效率的事。

            管理好自己的时间

        (2) 自动化的事。

            编写程序来自动化操作

        (3) 掌握前沿技术的事，

            学习一门技术需要花费不少时间，要根据自己的选择，有的放矢的学习。

        (4) 知识密集型的事。

            知识密集型是相对于劳动密集型来说的

        (5) 技术驱动的事

    4、 高标准要求自己。

        只有不断地高标准，你才可能越走越高，要高标准要求自己，不断反思，
        不断总结和审视自己，提高自己。

        （1）Google 的自我评分卡。

        （2）敏锐的技术嗅觉。

        （3）强调实践，学以致用。

        （4） Lead by Example。

            永远在编程。

"""07：推荐阅读，每个程序员都该知道的知识"""

    1、每个程序员都应该读的书：

        （1） 代码大全

        （2） 程序员修炼之道

        （3） 计算机程序的构造和解释

        （4） 算法导论

        （5）设计模式

        （6）重构

        （7）人月神话

        （8）代码整洁之道

        （9）Effective c++/ More Effective c++

        （10） Unix 编程艺术、Unix 高级编程环境

    2、每个搞计算机专业的学生应有的知识

        （1）要获得一份好工作，学生需要知道什么
        （2）为了一辈子都有工作干，学生需要知道什么
        （3）学生知道什么，才能进入研究生院
        （4）学生需要之道什么，才能对社会有益

        计算机专业人士所需的硬技能：

            工程类数学、Unix哲学和实践、系统管理、程序设计语言、离散数学
            数据结构和算法、计算机体系结构、操作系统、网络、安全、密码学
            软件测试、用户体验、可视化、并行计算、软件工程、形式化方法、
            图形学、机器人、人工智能、机器学习、数据库等。

    3、 LinkedIn 高效的代码复查技巧：

        Code Review 很重要。

        LinkedIn 要求代码签入版本管理系统前，就对其做清晰的说明，以便于复查者
        了解其目的，促进 Review 的进行。
        对提交代码写说明文档。

    4、编程语言和代码质量的研究报告：

        （1） 从查看 bug fix 的 commits 的次数情况来看，C、C++、
              Objective-C、PHP、Python 中的很多很多的 commits 都是
              和 bug fix 相关的。

        （2）函数式编程语言的 bug 明显比大多数其他语言要好很多。

        （3）bug 数和软件的领域没有关系。

        （4）bug 的类型和语言是强相关性


    5、电子书：

        《C++ 软件性能优化》


"""08: Go 语言，Docker 和新技术"""

    1、 问题

        为什么Go 语言和 Docker 会是新一代云计算技术
        作为技术人员，如何识别什么样的新技术会是未来的趋势

    2、go 语言的体会

        （1） 语言简单，上手快

        （2）并行和异步编程几乎无痛点

        （3）Go 语言的lib 库，麻雀虽小，五脏俱全

        （4）C 原因的理念和Python的姿态

            C 原因的理念是信息信任程序员，保持语言的小巧，不屏蔽底层且对底层友好
            关注语言的执行效率和性能
            Python 的姿态是用尽量少的代码完成尽量多的事。

    3、一个技术能不能发展起来，关键看三点：

        （1） 有没有一个比较好的社区

        （2）有没有工业化的标准

        （3）有没有一个或多个杀手级应用

         还有一些影响因素：

         （4） 学习难度是否底，上手是否快

         （5） 有没有一个不错的提高开发效率的开发框架

         （6）是否有一个或多个巨型的技术型公司作为后盾

         （7）有没有解决软件开发中的痛点

    4、用这些标准来衡量 Go 语言

        Go 语言容易上手
        Go 语言解决了并行编程和底层应用开发效率的痛点
        Go 语言有Google 这个世界一流的技术公司在后面
        Go 语言的杀手级应用是 Docker 容器。

        Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到上层如 Java
        业务层的项目。Go语言会吞食一定是 PaaS 上的项目，比如一些消息缓存中间件
        服务发现、服务代理、控制系统、Agent、日志收集等，他们没有复杂的业务场景
        也到不了特别底层（操作系统）的软件项目或工具。而 C 和 C++ 会被打倒
        更底层，Java会被打倒更上的业务层。


    5、Docker：

        Docker 一定会是未来的就技术，Kubernetes 作为服务和容器调度器的关键技术
        一定会是未来的赢家。

    6、PaaS：

        PaaS是Platform-as-a-Service的缩写，
        意思是平台即服务。 把服务器平台作为一种服务提供的商业模式。
        是一个被世界或是被产业严重低估的平台。

        PaaS 层的技术主要能解决下面问题：

        （1）软件生成线问题:
            持续集成和持续发布，以及 DevOps 中的技术必须通过 PaaS

        （2）分布式服务化的问题。

         (3) 提高服务的可用性 SLA

         (4) 软件能力的复用

    这些关键新技术，可以让你提前抢占技术的先机。


"""09: 答疑解惑 渴望、热情和选择"""

    1、三个问题：
        （1） 加班太严重完全没有时间学习，怎么办？
        （2） 为什么你能写出那么多东西？
        （3） 怎么选择自己的人生和职业发展？

    2、没有时间学习的问题

        关键看你对学习有多少的渴望程度，对学习的东西有多大的热情。
        学习是一件反人性的事，反人性的事要付出很多，还要坚持很久。

    3、为什么能够写那么多东西

        第一个阶段，是学习阶段

        第二个阶段，是有利益驱动的阶段

        第三个阶段，是记录自己观点打自己脸的阶段

        第四个阶段，是与他人交换的阶段

    4、怎么选择自己的人生和直接规划

        （1）20 ~ 30 岁 是打基础的阶段

            开阔眼界，把基础打牢固，努力学习和成长

        （2）30 ~ 40 人生的发展阶段

            明确自己的奋斗目标，干有挑战的事，提升自己技术领导力

    5、一些建议：

        （1） 客观的审视自己
              如果你超过身边大多数人，不妨选择的激进一些，否则，还是按部就班的来

        （2） 确定自己想要什么

            所谓"极端"，就是自己不会受到其他东西或其他人的 影响，不会因为这条路上
            有人退出你就开始疑惑或者迷茫，也不会因为别人成功你就羡慕。

        （3） 注重长期的可能性，而不是短期的功利。

        （4） 尽量关注自己会得到的东西，而不是自己会失去的东西

        （5）不要和大众的思维方式一样。

        很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度
        的受到思考问题的出发点、思维方式、格局观、价值观等因素影响。


"""10: 如何成为一个大家愿意追随的 Leader"""

    1、Leader(技术领导者)

       BOSS:             VS    　　Leader

        驱动员工                    指导员工
        制造畏惧                    制造热情
        面对错误喜欢使用人事惩罚     面对错误喜欢寻找解决问题的技术和管理方法
        知道怎么做                  展示怎么做
        用人                        发展人
        从团队收割成绩              给予团队成绩
        喜欢命令和控制              喜欢沟通和协作
        喜欢说"给我上"              喜欢说"跟我上"

    2、如何成为众人愿意追随的 Leader

        (1) 帮人解决问题

        (2) 被人依赖

        (3) Leader 除了技术领导力之外还有其他素质和人格魅力。

        (4) 赢得他人信任

        (5) 开发的心态和倾向性的价值观

        (6) Lead by Example

        (7) 保持热情和冲动

            正视问题，正视不足、正视错误，不怕困难，迎难而上。

        (8) 能够抓住重点，看透实物的本质。

        (9) 描绘令人激动的方向，提供令人向往的环境

        (10) 甘当铺路石，为他人创造机会

"""11:程序中的错误处理：错误返回码和异常捕捉""""

    1、传统的错误检查：
    
        处理错误最直接的方式是通过错误码，这也是传统方式，在过程式语言中通常都是用
        这样的方式处理错误的。比如 c 语言基本上来说，其通过函数返回值标识是否有错，
        然后通过全局的 errno 变量并配合一个 errstr 的数组来告诉你为什么出错。
        
        为什么是这样的设计？道理很简单，除了可以共用一些错误，更重要的时这其实是一种
        妥协。比如 read()、write()、open()这些函数的返回值其实是返回的有业务逻辑的值。
        也就是说，这些函数的返回值有两种含义，一种是成功的值，比如 open() 返回的文件句柄
        指针 FIFE*，或是错误 NULL。这样会导致调用者并不知道是什么原因出错了，需要去检查
        errno 来获取出错的原因，从而可以正确的处理错误。
        
        使用 返回值 + errno 的错误检查方式会有一些问题:
        
            (1) 程序员不小心就会忘记返回值的检查，从而造成代码的Bug;
            (2) 函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。
            
    2、多返回值：
    
        有一些语言通过多返回值的来解决上面的问题，比如 Go 语言。Go 语言的很多函数都返回
        result，err 两个值。于是：
        
            (1) 参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰。
            
            (2) 而且，Go 语言中的错误参数如果要忽略，需要显示的忽略，用 _ 这样的变量来忽略。
            
            (3) 另外，因为返回的 error 是个接口（其中只有一个方法 Error()）,返回一个 string
                所以你可以扩展自定义的错误处理。
                
            但即使像 Go 这样的语言能让错误处理语义更清楚，而且还有可扩展性，也有问题。
            如果写一段 Go 语言，你就会明白其中的痛苦---if err != nil 这样的语句简直
            是写到吐。
    
    3、资源清理：
    
        程序出错时需要对已分配的一些资源做清理，在传统的玩法下，每一步的错误都要去清理前面
        已经分配好的资源，于是就出现了 go to fail 这样的错误处理模式。
        
            # define FREE(P) if (p){free(p); p=NULL}
            mian()
            {
                char *fname = NULL;
                fname = (char *)calloc(20, sizeof(char));
                if(fname == NULL)
                {
                    goto fail;
                }
             
            fail:
                FREE(fname);   
                ReportError(ERR_NO_MEMORY)
            }
            
        这样的处理方式虽然可以，但是会有潜质的问题，主要的一个问题就是你不能在中间的代码中
        有 return 语句，因为你需要清理资源，在维护这样的代码是需要格外的小心，容易造成内容泄露。
        
        于是， C++ 的 RALL(Resource Acquisition Is Initialization) 机制使用面向对象的特性
        可以容易处理这个事情。RALL 其实使用 C++ 类的机制，在构造函数中分配资源，在析构函数中
        释放资源。
        
        在 Go 语言中，使用 defer 关键字也可以做到这样的效果。
        
    4、异常捕获处理：
    
        上面，我们讲了错误检查和程序出错之后资源的清理着两个事，能把这个事做的比较好的其实是
         try -- catch -- finally 这个编程模式。
         
            try {
                    ... // 正常业务代码
            } catch (Exception1 e ){
                    ... // 处理异常 Exception1 的代码
            } catch (Exception2 e){
                    ... // 处理异常 Exception2 的代码
            } finally{
                ... // 资源清理的代码
            }
        
         
         try - catch - finally 这样的异常处理方式有如下的好处：
         
            （1） 函数接口在 input(参数) 和 output(返回值) 以及错误处理的语义是比较清楚的。
            
            （2） 正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。
            
            （3） 异常不能被忽略（如何要忽略也需要 catch 住，这是显示忽略） 
            
            （4） 在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。
            
            （5） 与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。
                            
            当然，你可能觉得异常捕捉对性能有影响，这句话对也不多，原因是这样的。
            
            （1） 异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着 return 了。
                 而程序在执行时需要处理函数栈的上下文，这会导致性能变得很慢，尤其是函数栈比较
                 深的时候。
                 
            （2） 但从另一个方面来说，异常的抛出基本上情况表明程序的错误，程序在绝大多数情况下，应该是
                 在没有异常的情况下运行的，所以，有异常的情况应该是少数情况，不会影响正常处理的性能问题。
            
            总体而言，我还是觉得 try -- catch -- finally 这样的方式很不错，而且比返回错误码有诸多好处。
            但是，它有一个致命的问题，那就是在异步运行的世界里的问题。try 语句块里的函数运行在另外一个
            线程中，其中抛出的异常无法在调用者这个线程中被捕捉。这个问题就比较大。
            
    5、 错误返回码 VS 异常捕获
    
        前面也比较了两者的优缺点，总体而言，似乎异常捕捉的优势更多一些，但是，我觉得应该从场景
        上来讨论这个事才是正确的姿态。
        
        要讨论场景，我们需要把错误分好类别，错误可以分为三个大类：
        
        （1） 资源错误： 
        
            当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的问题，写文件时出现错误，
            发送文件到网络端发现网络故障错误，等等。这一类错误属于程序运行环境的问题。对于这类错误
            有些我们能处理，有些我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源
            不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。 
            
        （2） 程序的错误：
        
            比如：空指针、非法参数等。这类是我们自己程序的错误，我们要记录下来，写入日志，最好
            触发监控系统报警。
            
        （3） 用户的错误：
        
            比如：Bad Request、Bad Format 等这类由用户的API层上出现的问题，比如，解析一个xml或
            Json 文件，或是用户输入的字段不合法之类的。
            
            对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常
            执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。
        
        我们可以看到，这三类错误，有些是我们希望杜绝发生的，比如程序中的 Bug, 有则是我们杜绝不了的
        比如用户输入。而对于程序运行环境的错误，我们希望可以恢复。也就是说，我们希望可以通过重试或者
        妥协的方式来解决这些环境问题，比如重建网络连接，重新打开一个新的文件。
            
            所以，是不是我们可以这样来在逻辑上分类：
            （1）对于我们并不期望会发生的事，我们可以使用异常捕捉。
            （2）对于我们觉得可能会发生的事，使用返回码。
            
            比如，如果你的函数参数输入的对象不应该是一个 null 对象，那么一旦传入 null 对象后，
            函数就可以抛异常，因为我们不期望发生这样的事。
            
            而对于需要检查用户输入信息是否正确的事，比如：电子邮箱的格式，我们用返回码可能比较好一些。
            除了用错误分类来判断是否是使用返回码还是用异常捕捉之外，我们还要从程序设计的角度来考虑
            那种情况下使用异常捕捉更好，那种情况下使用返回码更好。
            
            在某些情况下，你只能使用其中的一个，比如：
            
                （1）在 C++ 重载操作符的情况下，你就很难使用错误返回码，只能抛异常。
                
                （2）异常捕捉只能在同步的情况下使用，在异步模式下，抛异常这事就不行，需要通过检查
                    子进程的退出码或是回调函数来解决。
                    
                （3）在分布式的情况下，调用远程服务只能看错误返回码，比如 HTTP 的返回码。
            
    总之，"报错类型" 和 "错误处理" 是紧密相连的，错误处理方法多种多样，而且会在不同的层面上处理错误。
    使用错误码还是异常捕捉主要还是看我们的错误处理流程以及代码组织怎样写会更清楚。
    
    
"""12: 程序中的错误处理：异常编程以及我的最佳实践"""      

    1、异步编程世界里的错误处理：
        
        在异步编程的世界里，因为被调用的函数是被放到了另外一个线程里运行，这将导致：
            
            （1）无法使用返回码。
                因为函数在"被"异步运行中，所谓的返回只是把处理权交给下一条指令，而是不是
                把函数运行完的结果返回，所以，函数返回的语义完全变了，返回码也没有什么用。
                
            （2）无法使用抛异常的方式。
            
                不同线程中的栈是完全不一样的，所以主线程中的 catch 完全看不到另外一个线程的异常。
                
        对此，在异步编程的世界里，我们也会有好几种处理错误的方法。最常用的就是 callback 方式，
        在做异步请求的时候，注册几个 OnSuccess()、OnFailure() 这样的函数，让另一个线程中运行
        的异步代码来回调过来。
        
    2、 JavaScript 异步编程的处理错误: 
    
        function successCallback(result){
            console.log("It successed with" + result);  
        }
        
        function failureCalllback(error){
        
            console.log("It failed with" + error);
        }
        
        doSomething(successCallback, failureCallback);
        
        通过注册错误处理的回调函数，让异步执行的函数在出错的时候，调用被注册进来的错误处理函数，
        这样的方式比较好地解决了程序的错误处理。而出错的语义从返回码，异常捕捉到了之间耦合错误
        处理函数的样子。
        
        但是，如果我们需要把几个异步函数执行顺序的话，就会出现所谓的 Callback Hell 的问题：
        
            doSomething(function(result)){
                doSomethingEls(result, function(newResult)){
                    doThridThing(newresult,function(finalResult)){
                        console.log('Got the final result:' + finalResult);
                    },failureCallback);
                },failureCallback);
            },failureCallback);
        
        这样层层嵌套中需要注册的错误处理函数也有可能完全不一样，导致代码混乱，难理解，难阅读。
        
    3、一般来说，在异步编程的实践里，我们会用 Promise 模式来处理。如下（箭头表达式）
    
        doSomething()
        .then(result => doSomethingElse(result))
        .then(newResult => doThreadThing(newResult))
        .then(finalResult => {
            console.log(`Got the final result: ${fianlResult}`);
        }).catch(failureCallback);
        
        上面代码中的 then() 和 catch() 方法就是 Promise 对象的方法， then() 方法可以
        把各个异步的函数给串联起来，而catch() 方法则是出错的处理。
        
        上面是级联式的调用方式，这就要我们的doSomething() 函数返回Promise 对象，下面这个
        函数相关代码示例：
        
            function doSomethin(){
                let promise = new Promise();
                let xhr = new XMLHttpRequest();
                xhr.open('GET','http:..',true);
                
                xhr.onload = function(e){
                if (this.status === 200){
                    results = JSON.parse(this.responseText);
                    promise.resolve(result); //成功时，调用 resolve() 方法
                }
                }；
                
                xhr.onerror = function(e){
                    promise.reject(e); //失败时，调用 reject() 方法。
                }; 
                
                xhr.send();
                return promise;
            }    
        
    
    4、错误处理的最佳实践：
    
        （1）统一分类的错误字典：
            无论你是使用错误码，还是异常捕捉，都需要认证统一做好错误分类。如HTTP的4XX表示客户端，5XX表示服务器。
        
        （2）同类的定义最好是可以扩展的。
            方便代码重用
         
        （3）定义错误的严重程度：
            Fatal: 重大错误
            Error: 资源或需求不满足
            Warning: 不一定是错误但是要注意
            Info: 不是错误只是一个信息
            Debug: 内存开发人员用于调试程序的。
            
        （4）错误日志的输出最好使用错误码，而不是错误信息
            打印错误日志的时候，应该使用统一的格式。这样有利于日志分析软件进行监控。
            
        （5）忽略错误最好有日志
        
        （6）对于同一个地方不停的报错，最好不要都打到日志里。
            这样导致其他日志被淹没，也会导致日志文件太大，最好实践是，打出一个错误以及出现的次数。
            
        （7）不要用错误处理逻辑来处理业务逻辑：
            也就是说，不要用异常捕捉这样的方式来处理业务逻辑，而应该用条件判断。
            异常捕捉用来处理不期望发生的事情，而错误码则用来处理可能会发生的事情。
            
        （8）对于同类的错误处理，用一样的模式。
        
        （9）尽可能在错误发生的地方处理错误
        
        （10）向上尽可能地返回原始的错误。
        
        （11）处理错误时，总是要清理已分配的资源
        
        （12）不推荐在循环体里处理错误
                try..catch 放在循环体外
                
        （13）不要把大量的代码放在同一个 try 语句块内
        
        （14）为你的错误定义提供清楚的文档以及每种错误的代码示例
        
        （15）对于异步的方式，推荐使用 Promise 模式处理错误。
        
        （16）对于分布式的系统，推荐使用 APM 相关的软件。
            
           
"""魔数 0x5f3759df"""

    《神雷之锤 3 竞技场》 源代码的一个函数(已经剥离了 C 语言预处理器的指令)
    
        float Q_rsqrt(float number)
        {
            long i;
            float x2, y;
            const float threehalfs = 1.5F;
            
            x2 = number * 0.5F;
            y = number;
            i = *(long *) &y; //evil floating point bit level hacking
            i = 0x5f3759df - (i >> 1); //what the fuck
            y = *(float *) &i;
            y = y *(threehalfs - ( x2 * y * y));
            return y; 
            
        
        }


"""14 推荐阅读：机器学习 101"""

    机器学习分两种方法，监督式学习（Supervised Learning）和非监督（Unsupervised Learning）.
    
    1、监督式学习：
    
        
    2、非监督式学习：
    
    
"""15 时间管理：同扭曲时间的事抗争"""

    1、主动管理：
    
        化被动为主动，你要主动管理的不是你的时间，而是管理你的同事，管理你的信息。
        
        
    2、学会说“不”：
        
        （1）当你面对做不到的需求时，你不能说这个需求做不到，要给出另一个你可以做到的方案，
            而不是把对方的方案直接回绝掉。
        
        （2）当你面对一个过于复杂的需求时，我不说不能完成满足你，但我说我可以部分满足你。
        
        （3）当你面对时间不够的需求时，也不要说不，你可以有三个选择：
            a. 我可以加班加点完成，我不保证质量。
            b. 我可以加班加点完成，保证质量，但需求能不能减少点。
            c. 我可以保质保量完成，但时间能不能多给2周。
            
            我不能说不，但是我要有条件的说，而且，我还有把压力再反过去给你。
            要积极主动的对不合理的事情讨价还价。
            
    3、加班和开会：
    
        开会不要讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。
        
"""16 时间管理：如何利用好自己的时间"""

    1、投资自己的时间：
    
        a. 花时间学习基础知识，花时间读文档。
        
        b. 花时间解放自己生产力的事情上。
        
        c. 花时间在让自己成长的事上。
        
        d. 花时间在建立高效的环境上。
        
    2、规划自己时间：
    
        a. 定义好优先级
        
        b. 最短作业优先
        
        c. 想清楚再做
        
        d. 关注长期利益规划
        
    3、用好自己的时间：
    
        a. 将军赶路不追小兔子
        
        b. 形成习惯
        
        c. 形成正反馈
        
        d. 反思和举一反三
        
"""17: 故障处理最佳实践 应对故障"""

    1、故障源团队通常会有一下几个手段来恢复系统：
    
        a. 重启和限流：
            
            重启和限流主要解决可用性的问题，而不是功能性的问题。
            
        b. 回滚操作：
        
            回滚操作一般说是解决新代码的bug.
            
        c. 降级操作：
        
            需要挂一个停服务的故障公告，主要是不把事态扩大。
            
        d. 紧急更新：
        
        出故障时，最重要的不是 debug 故障，而是尽可能地减少故障影响范围，并尽可能修复问题。
        
    2、故障前的准备工作：
    
        a. 以用户功能为索引的服务和资源的全视图。
        
        b. 为地图中的各个服务指定关键指标，以及一套运维流程和工具，包括应急方案。
        
        c. 设定故障等级
        
        d. 故障演练
        
        e. 灰度发布系统
        
"""18 故障处理最佳实践： 故障改进"""

    1、故障复盘过程：
    
        a. 故障处理的整个过程。
        
            就像log一样，需要详细记录几点几分干了什么事，把故障从发生到解决所有细节记录下来。
        
        b. 故障原因分析。
               
        c. Ask 5 Whys。
        
            需要反思并反问至少 5 个为什么
        
        d. 故障后续整改计划。
            
            需要针对上述的“Ask 5 Why”说明后续如何举一反三从根本解决所有问题。
            
    2、故障整改方法：
    
        a. 优化故障获知和故障定位的时间:
        
            从故障发生到我们知道的时间是否可以优化的更短？
            定位故障的时间是否可以更短？
            有哪些地方可以做到自动化？
            
        b. 优化故障的处理方式:
             
            故障处理时的判断和章法是否科学，是否正确？
            故障处理时的信息是否全透明？
            故障处理时人员是否安排得当？
                        
        c. 优化开发过程中的问题：
        
            Code Review 和测试中的问题和优化点
            软件架构和设计是否可以更好
            对于技术欠债或是相关的隐患问题是否被记录下来，是否有风险计划
        
        d. 优化团队能力：     
        
            如何提高团队的技术能力。
            如果让团队有严谨的工程意识。
            
    3、根除问题的本质：
    
        一个技术问题，后面隐藏的是工程能力问题，工程能力问题的后面隐藏的是管理问题，
        管理问题的后面隐藏的是一个公司文化的问题，公司文化问题后面隐藏的着创始人的问题...
        
        a. 举一反三解决当下的故障。为字节赢得更多的时间。
        
        b. 简化复杂、不合理的技术架构、流程和组织。
            你不可能在一个复杂的环境下根据地解决问题。
            
        c. 全面改善和优化整个系统、包括组织。
            解决问题的根本方法是改善和调整整个结构。而只有简单优雅的东西才有被改善和优化的可能。
            
            
"""19 答疑解惑：我们应该能够识别的表象和本质"""

    1、 关于兴趣和投入：
    
        兴趣是学习的助燃剂，对一件事有兴趣是是否愿意对这件事投入更多时间或者资源的前提条件。
        a. 一方面，兴趣是需要保持的
        b. 另一方面，兴趣其实也是可以培养出来的。
        
        兴趣只是开始，而能让人不断投入时间和精力的则是正反馈，是成就感。
        
        你需要找到让自己能够更有成就感的事情，兴趣总是可以培养出来的。
        
    2、关于学习和工作：
    
        本质上来说，并不是只有找到了相应的工作我们才可以学好一项技术，而是，我们在通过解决实际问题
        在与他人讨论，获得高手帮助的环境中，才能更快更有效的学习和成长。工作不过是提供了一个能够解决
        实际问题、能够与人讨论，有高手帮助的环境。
        
        总之，找到学习的方法，提升自己对新事物学习的能力，才是学习和成长的关键。
        
    3、关于技术和价值：
    
        要用技术解决什么样的问题，场景非常重要；
        如何降低技术的学习成本，提高易用性，从而可以让技术更普及。
        
        基础技术总是枯燥和有价值的。数学、算法、网络和存储等基础知识吃得越透，就越容易服务上层的各种衍生技术或产品。
        支持规模化的技术也是有价值的，在软件行业中，也就是 PaaS 的相关技术。
        
        
"""20 Git 协同工作流，你该怎么选"""

    1、Git:
  
        Git 是一个分布式版本管理工具，而且可以是单机版的，Git 衍生出来的 GitHub/GitLab 可以
        帮助你很好的管理编程工作。GitHub/GitLab 这样工具的出现，让我们的工作可以呈现在一个工作
        平台上，并以此来规范整个团队的工作。
        
        注意：Git 是一个分布式的代码管理器，所以，是分布式就会出现数据不一致的情况，因此，我们需要
        一个协同工作流来让工作变得高效，同时可以有效的让代码具有更好的一致性。
        
    2、中心式协同工作流：
    
        首先，Git 是可以像 SVN 这样的中心工作流一样工作的。这个过程一般是下面这个样子：
        
            a. 从服务器上做 git pull origin master 把代码同步下来。
            
            b. 改完之后，git commit 到本地仓库中。
            
            c. 然后 git push origin master 到远程仓库中，这样其他同学就可以得到你的代码了。
            
        如果 push 失败，发现别人已经提交了，那么你需要先把服务器上的代码 pull 下来，为了避免
        有 merge 动作，你可以使用 Git pull --rebase。 这样就可以把服务器上的提交直接合并到
        你的代码中，对此，Git 的操作是这样的：
        
            a. 先把你本地提交的代码放到一边。
            
            b. 然后把服务器上的改动下载下来。
            
            c. 然后在本地把你之前的改动再从新一个一个地做commit,直到全部成功。
                
    3、功能分支协同工作流：
    
        上面那种方式有一个问题，就是大家都在一个主干上开发程序，对于小团队或是小项目可以这么做，
        但是较大的项目或是人比较多的团队，这样做就会有很多问题。
        
        最大的问题就是代码可能干扰太严重，这时，我们不想让各功能开发人员都在 Master 分支上共享
        他们的代码。我们就需要协调这种方式：同时开发一个功能的开发人员可以分享各自的代码，但是不能
        把代码分享给开发其他功能的开发人员，直到整个功能开发完毕后，才会分享给其他的开发人员（也就是进入主干分支）。
        
        因此，我们引入“功能分支”。这个协调工作流的开发过程如下：
        
            a. 首先使用 git checkout -b new-featrure 创建 “new-feature”分支。
            
            b. 然后共同开发这个功能的程序员在这个分支上工作，进行 add、commit 等操作。
            
            c. 然后通过 git push -u origin new-feature 把分支代码 push 到服务器上。
            
            d. 其他程序员可以通过 git pull --rebase 来拿到最新的这个分支的代码。
            
            e. 最后通过 Pull Request 的方式做完 Code Review 后合并到 Master 分支上。
            
        其实，这种开发也是以服务器未中心的开发，还不是 Git 分布式开发，它只不过是用分支来完成代码改动的隔离。
        
        为什么叫“功能分支”，而不是“项目分支”，因为 git 的最佳实践希望大家在开发过程中，快速提交，快速合并，
        快速完成。这样可以减少很多冲突的事，所以叫功能分支。
        
    4、GitFlow 协同工作流：
    
        在真实的生成过程中，前面的协同工作流还是不能满足工作的要求，主要是因为我们的生产过程是比较复杂的，
        软件生成中会有各式各样的问题，并面对不同的环境，我们要不停的开发新代码的同时，维护线上代码，于是，
        就有了下面这些需求：
        
            a. 希望有一个分支是非常干净的，上面的可以发布的代码，上面的改动永远都是可以发布到生产
                环境中的。这个分支不能有中间开发过程中不可以上生产线的代码提交。
                
            b. 希望当代码达到可以上线的状态时，也就是在 alpha/beta release 时，在测试和交付的过程中，
                依然可以开发下一个版本的代码。
                
            c. 最后，对于已经发布的代码，也会有一些 bug-fix 改动，不会将正在开发的代码提交到生产线上去。
            
        为了解决这个问题，GitFlow 协同工作流就出来了，这个协同工作流的核心思想如下：    
        整个代码库中一共有五种分支：
            
            a. Master 分支，也就是主干分支，用作发布环境，上面的每一次提交都是可以发布的。
            
            b. Feature 分支， 也就是功能分支，用于开发功能，对应的是开发环境。
            
            c. Developer 分支，一旦功能开发完成，就像 Developer 分支合并，合并完成之后，
                删除功能分支，这个分支对应的是集成测试环境。
                
            d. Release 分支，当 Developer 分支测试达到可以发布的状态时，开出一个 Release 分支来，
                然后做发布前的准备工作。这个分支对应的是预发布环境。之所以需要这个 Release 分支，是
                我们的开发可以继续向前，不会因为要发布而被 block 住而不能提交。
                
                一旦 Release 分支上的代码达到可以上线的状态，那么需要把 Release 分支向 Master 分支和
                Developer 分支同时合并，以保证代码的一致性。然后再把 Release 分支删除。
                
            e. Hotfix 分支。是用于处理生产线上代码的 Bug-fix，每个线上的代码的 Bug- fix 都需要开一个Hotfix分支
                完成后，向Developer 分支和 Master 分支上合并，合并完成之后，删除 Hotfix 分支。
                
        这样就是整个 GitFlow 协同工作流的工作过程，我们可以看到：
        
            a. 我们需要长期维护 Master 和 Developer 两个分支。
            
            b. 这其中的方式还是有一定的复杂度的，尤其是 Release 和 Hotfix 分支需要同时向两个分支做合并。
                如果没有好的工具来支撑，我们可能会忘记了一些操作而导致代码不一致。
                
            c. GitFlow 协同虽然工作比较重，但是它几乎可以应对所有公司的各种开发流程，包括瀑布模型和快速迭代模型。
            
        对于 Gitflow 工作流来说，虽然可以解决问题，但是也有很多问题，其中有个问题就是因为分支太多，出现
        git log 混乱局面。具体来说，主要是gitflow 使用了git merge --no-ff 来合并分支，在git-flow 这样
        多分支的环境下让你的分支管理的log 边得很难看。
        
        所谓的 --no-ff 参数意思是--no fast forward 的意思。也就是说，合并的方法不要把这个分支的提交
        以前置合并的方式，而是留下一个 merge 的提交。
        
    5、GitHub Flow:
    
        所谓的 GitHub Flow, 其实也叫 Forking flow， 也就是 GitHub 上的那个开发方式。 
            
            a. 所有的开发人员都把 “官方库” 的代码 fork 到自己代码创库中。
            
            b. 然后，开发人员在自己的代码仓库中做开发，想干啥干啥。
            
            c. 因此，开发人员的代码库中，需要配两个远程创库，一个是自己的库，一个是官方库
                （用户的库用于提交代码改动，官方库用于同步代码）。
                
            d. 然后在本机建 “功能分支”，在这个分支上做代码开发。
            
            e. 这个功能分支被 push 到开发人员自己的代码创库中。
            
            f. 然后，向“官方库”发起 pull request，并做 Code Reivew.
            
            g. 一旦通过，就向官方库进行合并。
           
        这就是 GitHub 的工作流程。
       
    6、GitLab Flow：
        
        GitHub Flow 这种玩法依然有很多问题，因为其虽然变得很简单，但是没有把我们的代码和我们
        的运行环境给联系在一起。所以，GitLab 提出了几点优化点。
        
        其中一个是引入环境分支，其包含了预发布（Pre-Production）和生产（Production）分支。
        而又时候，我们还会有不同版本的发布，所以还需要有各种 release 的分支。
        
        这样也就解决了两个问题：
        
            环境和代码分支对应的问题
            版本和代码分支对应的问题        
    
    7、协同工作流的本质：
        
        团队协同工作的本质不外乎几个事：
            
            a. 不同的团队能够尽可能地并行开发。
            
            b. 不同软件版本和代码的一致性
            
            c. 不同环境和代码的一致性
            
            d. 代码总是会在稳定和不稳定间交替，我们希望生产线上的代码总是能对应到稳定的代码上来。
            
        协同的工作本质并不是怎样玩好创库的分支策略，而是玩好我们软件架构和软件开发流程。
        
        与其花时间在 Git 协同工作流上，还不如把时间花在调整软件架构和自动化软件生成和运维流程上来，
        这才是真正简化协同工作流程的根本。
        
                
    
           
                  
            
            
            
            
            
            
            
            
            
            
            
               
                
                
            
                
            
                
            
        
            
    
                           
    
      
    
                   
                           
        
        
































