"-------------------------------------------------------------------"
            
            学习极客时间王争老师《数据结构和算法之美》学习笔记   
            
"--------------------------------------------------------------------"

"""01: 为什么要学习数据结构和算法 """

    程序员所谓的瓶颈期其实是你自己是不是跟着行业在发展，还是每个项目都在重复
    的堆砌业务逻辑，没有难度递进，没有任何提升，十年和一年也没有什么区别。
    
    我们学习数据结构和算法，并不是为了死记硬背几个知识点，我们的目的是建立时间复杂度、
    空间复杂度意识、写出高质量的代码、能够设计基础架构、提升编程技能，训练逻辑思维。


"""02: 如何抓住重点，系统高效地学习数据结构和算法 """
    
    1、什么是数据结构和算法：
    
        从广义上讲：
        
            数据结构就是指一组数据的存储结构，算法就是操作数据的一组方法。
        
        从狭义上讲：
            
            指某些著名的数据结构和算法，比如，队列、栈、队、二分查找、动态规划等。
            
    2、数据结构和算法什么关系：
    
        数据结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。
        
    3、学习的重点在什么地方：
    
        学习数据结构和算法，首先要掌握一个数据结构和算法中最重要的概念--- 复杂度分析。
        
        10 个数据结构：
        
            数组、链表、栈、队列、三列表、二叉树、堆、跳表、图、Trie 树
            
        10 中算法：
        
            递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符匹配算法。
            
    4、小结：
    
        知识需要沉淀、不要试图一下子掌握所有。
        学习知识的过程是反复迭代，不断沉淀的过程。
        边学边练、多闻多思
        
        
"""03:  复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗"""

    数据结构和算法本身解决的是 "快" 和 "省" 的问题，及如何让代码运行得更快，如何让代码更省存储空间。
    所以，执行效率是算法一个非常重要的考量指标。
    
    复杂度分析是整个算法学习的精髓，只要掌握它，数据结构和算法的内容就基本上掌握了一半。
    
    1、为什么需要复杂度分析:
        
        摆脱一些客观因素的影响，我们需要一个不用具体的测试数据来测试，就可以粗略的估计算法
        的执行效率的方法。就是我们今天要讲的时间、空间复杂度分析方法。
        
    2、大 O 复杂度表示法：

        所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。
        
        我们可以把这个规律总结成一个公式：
         
            T(n) = O(f(n))
        
            其中： T(n) : 是代码执行的时间
                   n   : 表示数据规模的大小
                  f(n) : 表示每行代码执行的次数总和。
                  O    : 表示代码执行时间 T(n) 与 f(n) 表达式成正比。
            
            大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随
            数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称"时间复杂度"。
   
    3、 时间复杂度分析：
           
        （1） 只关注循环执行次数最多的一段代码
            大 O 这种复杂度表示方法只是一种变化趋势，我们通常会忽略掉公式中的常量、低阶和系数
            只需要记录一个最大阶的量级就可以了，所以，我们在分析一个算法、一段代码的时间复杂度的时候
            也只关注循环执行次数最多的那段代码就可以了。
            
        （2） 加法法则：总复杂度等于量级最大的那段代码的复杂度。
       
        （3） 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
        
    4、几种常见时间复杂度实例分析：
    
        常量阶： O(1)
            
            O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。
            比如：下面代码有三行，他的时间复杂度为O(1) 而不是O(3)
                int i = 8
                int j = 6
                int sum = i + j
            
            只要代码执行时间不随 n 的增大而增大，这样的时间复杂度都记作 O(1).
            或者，一般情况下，只要算法中不存在循环语句、递归语句、即使有上千万行的代码
            其中的时间复杂度也是O(1)。
       
        对数阶： O(logN)、O(nlogn):
            
            如下面一段代码片段：
            
                i = 1;
                while (i <= n){
                    i = 2 * i
                }
                
            第三行代码是循环执行次数最多的，所以，我们只要计算出这行代码被执行了多少次，就能知道
            整段代码的时间复杂度。
            从代码可以看出，变量 i 的值从 1 开始取，每循环一次乘以 2。当大于 n 时，结束循环。
            2^x = n 求解 x 的值就是这段代码执行的次数。 x = log2n，所以代码的时间复杂度是O(log2n)
                
                i = 1
                while (i <= n){
                    i = i * 3
                }    
            上面这段代码的时间复杂度是 O(log3N)
           
            实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们都可以记为 O(logn)
                log3N = log32 * log2N,所以 O(log3N)=O(C * log2N) 其中 c = log32 是个常量。
            因此在对数阶时间复杂度的表示法我们忽略"底"，统一为 O(logN)
            
            如果一段代码的时间复杂度是 O(logN),我们循环执行 n 遍，时间复杂度就是 O(nlogN)了。
            快速排序和归并排序时间复杂度都是 O(nlogN)
               
        3、O(m + n)、O(m*n)
            
            有两个数据规模的复杂度。
            
            int cal(int m, int n){
                
                int sum_1 = 0;
                int i = 1;
                for(; i < m; ++i){
                    sum_1 = sum1 + i
                }
                int sum_2 = 0;
                int j = 1;
                for(; j < n; ++j){
                    sum_2 = sum_2 + j;
                }
                return sum_1 + sum_2;    
            }
            
            从代码看出，m 和 n 是代表两个数据规模，我们无法先评估 m 和 n 谁的量级大，所以我们
            表示复杂度的时候，就不能简单地利用加法法则，省略其中的一个。
            上面代码的时间复杂度是 O(m + n)
    
        线性阶： O(n)
        平方阶、立方阶、。。K次方阶：O(n^2)、O(n^3)、O(n^K)
        指数阶：O(2^n)
        阶乘阶：O(n!)
        
    5、 空间复杂度分析：
    
        时间复杂度的全称是：渐进时间复杂度，表示算法的执行时间与数据规之一个之间的增长关系。
        空间复杂度的全称是：渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。
        
        void print(int n){
            int i = 0;
            int [] a = new int[n];
            for(i; i<n;i++){
                a[i] = i * i
            }
            
            for(i = n-1; i>=0; --i){
                print out a[i]
            }
        }
        
        跟时间复杂度一样，第二行代码中，我们申请了一个空间存储变量 i,但是它是常量阶的，跟数据规模 n 没有关系。
        所以我们可以忽略。第三行申请一个大小为 n 的 int 类型数组，除此之外，剩下的代码里没有占用更多空间，
        多以整段代码的空间复杂度是 O(n)
        我们常见的空间复杂度是 O(1), O(n), O(n^2), 像 O(logN),O(nlogN)这样对数阶的复杂度平时用不到。
        
    6、小结：
    
        复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系。
        
        
"""04: 复杂度分析（下）： 浅析最坏、最好、平均、均摊时间复杂度"""        
        
    1、最好、最坏情况时间复杂度：（best/worst case time complexity）
        
        # n 表示数组 array 的长度
        int find(int [] array, int n, int x){
            int i = 0;
            int pos = -1;
            for(; i<n; ++i){
                if (array[i] == x) pos = i;
            }
            return pos;
        }
        
        # n 表示数组 array 的长度
        
        int find(int[] arrar, int n, int x){
            int i = 0;
            int pos = -1;
            for(; i < n; ++i){
                if (array[i] == x){
                    pos = i;
                    break;
                }
            }
            return pos;
        }       
            
        因为，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查询的变量 x
        那么就不需要遍历剩下的 n - 1 个数据了，那时间复杂度就是O(1), 如果数组中不存在，就需要
        把整个数组遍历一遍，时间复杂度就是 O(n)。不同情况，时间复杂度不同。
        
        为了表示代码在不同情况下不同时间复杂度，我们需要引起三个概念：最好情况时间复杂度、最坏情况时间复杂度和
        平均情况时间复杂度。
        
        平均情况时间复杂度:
            最好情况和最坏情况时间复杂度都是极端情况下的代码复杂度，发生的概率并不大。为了更好的表示
            平均情况下的复杂度，我们引入了另一个概念：平均情况复杂度，简称平均复杂度。
            
            要查找变量 x 在数组中的位置， 有 n + 1 种情况：在数组的 0 ~ n-1 位置中和不在数组中。
            我们把每种情况，查找需要遍历的元素个数累加起来，然后再除以 n + 1，就可以得到需要的元素个数
            的平均值 (1+2+3+...+n+n)/(n+1) = n(n+3)/2(n+1) 时间复杂度的大 O 标记法中，可以省略掉系数
            低级和常量，因此得到的时间复杂度是 O(n)
    
    2、均摊时间复杂度：
    
        # array 表示一个长度为 n 的数组
        # 代码中的 array.length 就等于 n
        
        int[] array = new int[n];
        int count = 0;
        void insert(int val){
            if (count == array.length){
                int sum = 0;
                for(int i=0; i< array.length; ++i){
                    sum = sum + array[i];
                }
                array[0] = sum;
                count = 1;
            }
            array[count]= val;
            ++count;
        }
        
        均摊时间复杂度就是一种特殊的平均时间复杂度。

""""""
        

                 
   
        
        
                  
        
        
       
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        