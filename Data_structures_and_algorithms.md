"-------------------------------------------------------------------"
            
            学习极客时间王争老师《数据结构和算法之美》学习笔记   
            
"--------------------------------------------------------------------"

"""01: 为什么要学习数据结构和算法 """

    程序员所谓的瓶颈期其实是你自己是不是跟着行业在发展，还是每个项目都在重复
    的堆砌业务逻辑，没有难度递进，没有任何提升，十年和一年也没有什么区别。
    
    我们学习数据结构和算法，并不是为了死记硬背几个知识点，我们的目的是建立时间复杂度、
    空间复杂度意识、写出高质量的代码、能够设计基础架构、提升编程技能，训练逻辑思维。


"""02: 如何抓住重点，系统高效地学习数据结构和算法 """
    
    1、什么是数据结构和算法：
    
        从广义上讲：
        
            数据结构就是指一组数据的存储结构，算法就是操作数据的一组方法。
        
        从狭义上讲：
            
            指某些著名的数据结构和算法，比如，队列、栈、队、二分查找、动态规划等。
            
    2、数据结构和算法什么关系：
    
        数据结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。
        
    3、学习的重点在什么地方：
    
        学习数据结构和算法，首先要掌握一个数据结构和算法中最重要的概念--- 复杂度分析。
        
        10 个数据结构：
        
            数组、链表、栈、队列、三列表、二叉树、堆、跳表、图、Trie 树
            
        10 中算法：
        
            递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符匹配算法。
            
    4、小结：
    
        知识需要沉淀、不要试图一下子掌握所有。
        学习知识的过程是反复迭代，不断沉淀的过程。
        边学边练、多闻多思
        
        
"""03:  复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗"""

    数据结构和算法本身解决的是 "快" 和 "省" 的问题，及如何让代码运行得更快，如何让代码更省存储空间。
    所以，执行效率是算法一个非常重要的考量指标。
    
    复杂度分析是整个算法学习的精髓，只要掌握它，数据结构和算法的内容就基本上掌握了一半。
    
    1、为什么需要复杂度分析:
        
        摆脱一些客观因素的影响，我们需要一个不用具体的测试数据来测试，就可以粗略的估计算法
        的执行效率的方法。就是我们今天要讲的时间、空间复杂度分析方法。
        
    2、大 O 复杂度表示法：

        所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。
        
        我们可以把这个规律总结成一个公式：
         
            T(n) = O(f(n))
        
            其中： T(n) : 是代码执行的时间
                   n   : 表示数据规模的大小
                  f(n) : 表示每行代码执行的次数总和。
                  O    : 表示代码执行时间 T(n) 与 f(n) 表达式成正比。
            
            大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随
            数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称"时间复杂度"。
   
    3、 时间复杂度分析：
           
        （1） 只关注循环执行次数最多的一段代码
            大 O 这种复杂度表示方法只是一种变化趋势，我们通常会忽略掉公式中的常量、低阶和系数
            只需要记录一个最大阶的量级就可以了，所以，我们在分析一个算法、一段代码的时间复杂度的时候
            也只关注循环执行次数最多的那段代码就可以了。
            
        （2） 加法法则：总复杂度等于量级最大的那段代码的复杂度。
       
        （3） 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
        
    4、几种常见时间复杂度实例分析：
    
        常量阶： O(1)
            
            O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。
            比如：下面代码有三行，他的时间复杂度为O(1) 而不是O(3)
                int i = 8
                int j = 6
                int sum = i + j
            
            只要代码执行时间不随 n 的增大而增大，这样的时间复杂度都记作 O(1).
            或者，一般情况下，只要算法中不存在循环语句、递归语句、即使有上千万行的代码
            其中的时间复杂度也是O(1)。
       
        对数阶： O(logN)、O(nlogn):
            
            如下面一段代码片段：
            
                i = 1;
                while (i <= n){
                    i = 2 * i
                }
                
            第三行代码是循环执行次数最多的，所以，我们只要计算出这行代码被执行了多少次，就能知道
            整段代码的时间复杂度。
            从代码可以看出，变量 i 的值从 1 开始取，每循环一次乘以 2。当大于 n 时，结束循环。
            2^x = n 求解 x 的值就是这段代码执行的次数。 x = log2n，所以代码的时间复杂度是O(log2n)
                
                i = 1
                while (i <= n){
                    i = i * 3
                }    
            上面这段代码的时间复杂度是 O(log3N)
           
            实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们都可以记为 O(logn)
                log3N = log32 * log2N,所以 O(log3N)=O(C * log2N) 其中 c = log32 是个常量。
            因此在对数阶时间复杂度的表示法我们忽略"底"，统一为 O(logN)
            
            如果一段代码的时间复杂度是 O(logN),我们循环执行 n 遍，时间复杂度就是 O(nlogN)了。
            快速排序和归并排序时间复杂度都是 O(nlogN)
               
        3、O(m + n)、O(m*n)
            
            有两个数据规模的复杂度。
            
            int cal(int m, int n){
                
                int sum_1 = 0;
                int i = 1;
                for(; i < m; ++i){
                    sum_1 = sum1 + i
                }
                int sum_2 = 0;
                int j = 1;
                for(; j < n; ++j){
                    sum_2 = sum_2 + j;
                }
                return sum_1 + sum_2;    
            }
            
            从代码看出，m 和 n 是代表两个数据规模，我们无法先评估 m 和 n 谁的量级大，所以我们
            表示复杂度的时候，就不能简单地利用加法法则，省略其中的一个。
            上面代码的时间复杂度是 O(m + n)
    
        线性阶： O(n)
        平方阶、立方阶、。。K次方阶：O(n^2)、O(n^3)、O(n^K)
        指数阶：O(2^n)
        阶乘阶：O(n!)
        
    5、 空间复杂度分析：
    
        时间复杂度的全称是：渐进时间复杂度，表示算法的执行时间与数据规之一个之间的增长关系。
        空间复杂度的全称是：渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。
        
        void print(int n){
            int i = 0;
            int [] a = new int[n];
            for(i; i<n;i++){
                a[i] = i * i
            }
            
            for(i = n-1; i>=0; --i){
                print out a[i]
            }
        }
        
        跟时间复杂度一样，第二行代码中，我们申请了一个空间存储变量 i,但是它是常量阶的，跟数据规模 n 没有关系。
        所以我们可以忽略。第三行申请一个大小为 n 的 int 类型数组，除此之外，剩下的代码里没有占用更多空间，
        多以整段代码的空间复杂度是 O(n)
        我们常见的空间复杂度是 O(1), O(n), O(n^2), 像 O(logN),O(nlogN)这样对数阶的复杂度平时用不到。
        
    6、小结：
    
        复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系。
        
        
"""04: 复杂度分析（下）： 浅析最坏、最好、平均、均摊时间复杂度"""        
        
    1、最好、最坏情况时间复杂度：（best/worst case time complexity）
        
        # n 表示数组 array 的长度
        int find(int [] array, int n, int x){
            int i = 0;
            int pos = -1;
            for(; i<n; ++i){
                if (array[i] == x) pos = i;
            }
            return pos;
        }
        
        # n 表示数组 array 的长度
        
        int find(int[] arrar, int n, int x){
            int i = 0;
            int pos = -1;
            for(; i < n; ++i){
                if (array[i] == x){
                    pos = i;
                    break;
                }
            }
            return pos;
        }       
            
        因为，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查询的变量 x
        那么就不需要遍历剩下的 n - 1 个数据了，那时间复杂度就是O(1), 如果数组中不存在，就需要
        把整个数组遍历一遍，时间复杂度就是 O(n)。不同情况，时间复杂度不同。
        
        为了表示代码在不同情况下不同时间复杂度，我们需要引起三个概念：最好情况时间复杂度、最坏情况时间复杂度和
        平均情况时间复杂度。
        
        平均情况时间复杂度:
            最好情况和最坏情况时间复杂度都是极端情况下的代码复杂度，发生的概率并不大。为了更好的表示
            平均情况下的复杂度，我们引入了另一个概念：平均情况复杂度，简称平均复杂度。
            
            要查找变量 x 在数组中的位置， 有 n + 1 种情况：在数组的 0 ~ n-1 位置中和不在数组中。
            我们把每种情况，查找需要遍历的元素个数累加起来，然后再除以 n + 1，就可以得到需要的元素个数
            的平均值 (1+2+3+...+n+n)/(n+1) = n(n+3)/2(n+1) 时间复杂度的大 O 标记法中，可以省略掉系数
            低级和常量，因此得到的时间复杂度是 O(n)
    
    2、均摊时间复杂度：
    
        # array 表示一个长度为 n 的数组
        # 代码中的 array.length 就等于 n
        
        int[] array = new int[n];
        int count = 0;
        void insert(int val){
            if (count == array.length){
                int sum = 0;
                for(int i=0; i< array.length; ++i){
                    sum = sum + array[i];
                }
                array[0] = sum;
                count = 1;
            }
            array[count]= val;
            ++count;
        }
        
        均摊时间复杂度就是一种特殊的平均时间复杂度。

"""数组：为什么很多编程语言中数组都是从0开始编号"""

    1、如何实现随机访问？
        
        数组（array）：是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。
        线性表：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。
                除了数组，链表、队列、栈等也是线性表结构。
                而与线性表对立的概念是非线性表，比如二叉树、堆、图等，在非线性表中，数据之间并不是简单的前后关系。
        
        连续的内存空间和相同类型的数据，正是因为这两个限制，它才有一个“杀手锏”的特性：“随机访问”。
        但是有利有弊，这两个限制也让数组的很多操作变得低效，比如插入和删除。
        
        计算机给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问
        数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素的内存地址：
        
                a[i]_address = base_address + i * date_type_size
                
                其中：base_address 内存块首地址
                     data_type_size 存储数据类型的大小
                     i  数组中的第几个数据
        
        数组是适合查找操作，但是查找的时间复杂度并不为 O(1)，即便是排好序的数组，采用二分法
        时间复杂度也是 O(logn),数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。
        
    2、低效的插入和删除：
    
        插入操作：
        
            假设数组的长度为 n , 如果数组在末尾插入时间复杂度为 O(1),
            在数组的开头插入时间复杂度为O(n),平均时间复杂度为 O(n).
            如果数组是有序的，我们在某个位置插入一个新的元素，就必须
            搬移 k 之后的数据。但是如果数组中的数据并没有任何规律，数组只是被当做一个存储
            数据的集合，在这种情况下，我们可以避免搬迁数据，直接将第 k 位的数据搬迁到数组
            末尾，将新的元素放入到第k个位置。
        
        删除操作：
        
            如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬迁数据，不然中间
            会出现空洞，内存就不连续了。
            和插入类似，末尾删除最好情况时间复杂度O(1),删除头数据时间复杂度为O(n),平均也是O(n)。
            
    3、警惕数组的访问越界问题：
        在 c 语言中只要不是访问受限的内存，所有的内存空间都是可以访问的。
        
    4、容器能否完全替代数组：
    
        对于业务开发，直接使用容器就足够，省时省力，毕竟损耗一丢丢性能，完全不会影响到整个系统整体性能，
        但是，如果做非常底层的开发，比如网络框架，性能的优化需要做到极致，这个时候数组优于容器。
 
    5、为什么数组从 0 开始编号，而不是从 1 开始呢：
    
        从数组的存储的内存模型上看，“下标”最确切的定义应该是“偏移（offset）”
        如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，
        a[k] 就表示偏移为 k 个type_size 的位置，所以计算a[k]的内存地址只需要
        用给这个公式：
            a[k]_address = base_address + k * type_size
            
        如果从 1 开始编号，计算数组元素 a[k]的内存地址会变为：
            a[k]_address = base_address + (k - 1)*type_size
            
        对比两个公式，从 1 开始编号，你每次随机访问数组元素都会多了一次减法运算，
        对于 CPU来说，就是多了一次减法指令。
        
        数组作为分成基础的数据机构，通过下标随机访问数组又是非常基础的编程操作，
        效率的优化要做到极致，所以数组选择从 0 开始编号。
        
        二维数组的内存寻址方式：
        
            对于 m * n 的数组，a[i][j](i<m, j<n)的地址为：
            
             address = base_address + (i*n + j) * type_size
           
           
"""06 链表（上）：如何实现LRU缓存淘汰算法"""        
    
    缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有广泛的应用，比如 cpu 缓存、数据库缓存、浏览器缓存等。
    
    缓存的大小有限、当缓存被用满时，那些数据应该被清理出去，那些数据应该被保留？这需要缓存淘汰策略来决定。
    常见的三种策略：先进先出策略 FIFO(First In, First Out)、最少使用策略 LFU(Least Frequently Used)
    最近最少使用策略 LRU(Least Recently Used)。
    
    1、数组和链表：
    
        数组：一块连续的内存空间来存储，对内存要求比较高。
             数组的删除和插入操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)
             
            
        
        链表：通过“指针”将一组零散的内存块串联起来使用，我们把内存块称为“结点”。为了将所有的结点串联起来，
              每个结点上除了保持数据之外还有保持下一个结点的地址，我们把下一个记录下一个结点的地址的指针
              叫作后继指针 next。
              链表的插入和删除操作，只需要考虑相邻结点的指针改变，多对应的时间复杂度是O(1)
              链表要访问第 k 个元素，就没有数组那么高效，因为链表中的数据并非连续存储的，
              所以无法像数组那样，通过指针和下标，通过寻址公式就能计算出对于的内存地址，
              而链表需要一个结点一个结点地依次遍历，直到找到相应的结点。时间复杂度O(n)
              
        循环链表：
    
            循环链表的优点是从链尾到链头比较方便，当要处理的数据具有环形结构特点时，就特别适合采用循环链表。
        
        双向链表：          
              
            双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。双向链表比单向链表占用更大的内存空间。
            但是支持双向遍历，操作更灵活。
    
    2、单向链表和双向链表
            
        双向链表适合解决那些问题？
            
            从结构上看，双向链表可以支持 O(1)的时间复杂度的情况下找到前驱结点，这是这样的特点，也使得
            双向链表在某些情况下的插入、删除操作都比单链表简单、高效。
            单链表的插入和删除操作时间复杂度已经是 O(1)了，双向链表还能再怎么高效呢？
                
            删除操作：
                在实际的开发中，从链表中删除一个数据无外乎两种情况：
                    （1）删除结点中“值等于某个给定值”的结点
                    （2）删除给定指针执向的结点。
                        
                对于第一种情况，无论是单链表还是双链表，为了查找值等于给定的结点，都需要从头结点开始
                一个一个依次遍历对比，直到直到的值等于给定的值的结点，然后通过指针操作将其删除。
                尽管单纯的删除操作时间复杂度是 O(1),单遍历查找的时间是主要的耗时点，对应的时间复杂度是O(n)。
                    
                对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表
                不支持直接获取前驱结点，所以要找到前驱结点需要从头开始遍历，直到 p->next = q,说明 p 是 q 的前驱结点。
                但是对于双向链表这是明显的优势。
                第二种情况单链表删除的时间复杂度是 O(n),双向链表是 O(1)
                
            插入操作：    
                             
                同理，希望在链表的某个结点的某个指定结点前面插入一个结点，双向链表的时间复杂度是O(1)，单向链表是O(n)。    
                  
            查询操作：
                    
                对于一个有序的链表，双向链表的按值查询的效率也要比单链表更加高一些，因为，我们可以记录上一次查询的位置 p,
                每次查询时，根据要查找的值与 p 的大小，决定是往前查找还是往后查找。
                    
        在实际的开发中虽然双向链表更费内存，但是比单向链表应用更广泛，java 中的 LinkedHashMap 容器就是用的双向链表。
                    
    3、用空间换时间的设计思想：
    
        当内存空间充足的时候，如果我们更加追求代码的执行速度，我们可以选择空间复杂度相对较高，
        时间复杂度相对比较低的算法或数据结构，相反，如果内存比较紧缺，比如代码在手机或者单片机上
        这个时候，反过来要从时间换空间的设计思想。
        
        缓存实际上就会说利用空间换时间的设计思想，如果把数据存储在硬盘上，回比较节省内存，单每次查查比较
        慢，如果用缓存技术，事先把数据加载到内存中，虽然会比较消耗内存空间，但是每次数据查询的速度就大大提高。
        
        内存充足（时间换空间），内存不足（空间换时间）
        
    4、链表 VS 数组：
        
        数组和内存是两种截然不同的内存组织方式，正是因为内存存储的区别，他们插入、删除、随机访问操作的时间复杂度正好相反。
        
        不过数组和链表对比，并不能局限于时间复杂度。在实际开发中，不能仅仅利用时间复杂度分析来决定使用哪个数据结构。
        数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。
        链表在内存中不是连续存储所以对 CPU 不友好，没办法有效预读。
        
        数组的确定是大小固定，一经声明就要占用整块连续内存空间。如果声明数组过大，系统可能没有足够的内存空间分配给它，
        导致“内存不足（out of memory）”。声明过小，则可能出现不够用的情况，这时只能申请一个更大的内存空间，把原来数据
        拷贝进去，非常费时。
        链表本身没有大小的限制，天然支持动态扩容。
        
        如果你的代码对内存使用很苛刻，那数组更适合你，因为链表中的每个结点都需要消耗额外的存储空间去存储一份执向下一个结点
        的指针，所以内存消耗会翻倍，而且，对链表进行频繁的插入、删除操作，导致频繁的内存申请和释放，容易造成内存碎片
        如果是java 语言，就可能导致频繁的GC。
        
        实际开发中要根据具体情况，权衡究竟是选择数组还是链表。
        
    5、如何基于链表实现 LRU 缓存淘汰算法。
    
        我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，
        我们从链表头开始顺序遍历链表。
        （1）如果此数据已经被缓存在链表中了。我们遍历得到这个数据对于的结点，并将其从原来的位置删除，然后插入到表头。
        （2）如果此数据没有在缓存链表中，又可以分为两种情况：
            如果此时缓存未满，则将此节点直接插入到链表头。
            如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
                
        现在缓存访问的时间复杂度为 O(n).
        可以引入散列表来记录每个数据的位置，将缓存的访问时间复杂度降到 O(1).
        
        
"""07 链表（下）：如何轻松的写出正确的链表代码"""   
    
    1、理解指针或引用的含义：
    
        将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针存储了
        这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
        
    2、警惕指针丢失和内存泄露：
    
        如一个单链表，--->a--->b--->c--->d , 我们希望在结点 a 和相邻的结点 b 之间插入结点 x,
        假设当前指针 p 指向结点 a, 如果我们将代码实现成下面这个样子，就会发生指针丢失和内存泄露。
        
            （1）p->next = x; //将 p 的 next 指针指向 x 结点。
            （2）x->next = p->next; // 将 x 的结点的 next 指针指向 b 结点。
            
            p->next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x .
            第二行代码相当于将 x 赋值给 x ->next,自己指向自己，因此，整个链表就断成两半。
            从结点 b 往后的多有结点都无法访问到。
            
        对于 c 语言，内存管理是由程序员负责，如果没有手动释放对应的内对应存空间，就会产生内存泄露。
        所以，我们插入结点时，一定要注意操作的顺序，同理，删除链表结点时，也一定要记得手动释放内存空间。
        
    3、利用哨兵简化实现难度：
    
        插入一个新结点:  
            new_node->next = p->next;
            p->next = new_node;
            
            如果是空链表上面的逻辑就不能用：
                if(head == null){
                    head = new_node
                }
            
        删除一个结点：
        
            p->next = p->next->next;
            
            如果我们删除的是最好一个结点，上面代码就不能使用：
                if(head->next == null){
                    head = null
                }
                
        针对链表的插入和删除操作，需要对插入第一个结点和删除的最后一个结点的情况进行特殊处理。
        
        还记得如何表示一个空链表吗？ head = null 表示链表中没有结点了，其中 head 表示头结点指针，指向链表的第一个结点。
        
        如果们引入哨兵结点，在任何时候不管链表是不是空，head 指针都会一直指向这个哨兵结点。
        我们也把也把有哨兵结点的链表叫作带头链表，相反，没有哨兵结点的链表叫作不带头链表。
        
        哨兵结点时不存储数据的，因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和
        删除其他结点，都可以统一为相同的代码实现逻辑。
                          
        代码一：
        
            //在数组 a 中，查找 key, 返回 key 所在是位置
            // 其中， n 表示数组 a 的长度。
            
            int find(char *a, int n, char key){
                
                // 边界处理，如果 a 为空，或者 n <=0,说明数组中没有数据，就不用进行下面的循环了。
                if(a == null || n <= 0){
                    return -1;
                }
                
                int i = 0;
                //这里有两个比较操作：i < n 和 a[i] = key
                while(i < n){
                    if(a[i] == key){
                        return i;
                    }
                    ++i;
                }
                return -1;
            }
            
            
        代码二：
        
            int find(char *a, int n, char key){
                if(a == null || n<=0){
                    return -1;
                }
                
                if(a[n-1] == key){
                    return n-1;
                }
                
                char tmp = a[n-1];
                a[n-1] =  key;
                int i = 0;
                while(a[i] ! = key){
                    ++i;
                }
                
                a[n-1] = temp;
                
                if(i == n-1){
                    return -1;
                }else{
                    return i;
                }
            }    
            
       对比两段代码，在字符串 a 很长的时候，比如 几十万，代码二执行更快，因为两段代码执行次数最多的是
       while 循环中的部分，第二段我们通过一个哨兵 a[n-1] = key,成功省略掉一个比较语句 i < n,
       不要小看这一条语句，当累计万次时，积累的时间很明显了。
       
    4、重点留意边界条件处理：
    
        用来检查链表代码是否正确的边界条件有这样几个：
        
            （1）如果链表为空时，代码是否能正常工作？
            （2）如果链表只包含一个结点时，代码是否能正常工作？
            （3）如果链表只包含两个结点时，代码是否能正常工作？
            （4）代码逻辑在处理头结点和尾结点时候，是否能正常工作。
            
    5、举例画图，辅助思考：
    
    6、多写多练，没有捷径：
    
        5个常见的链表操作
            单链表翻转
            链表中环的检测
            两个有序的链表合并
            删除链表倒数第n 个结点
            求链表的中间结点
       
        
    7、小结：
        
        写链表代码最考验逻辑思维能力。
     
    

                 
   
        
        
                  
        
        
       
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        