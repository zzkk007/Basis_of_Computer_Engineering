"-----------------------------------------------------------------"

       本篇笔记是学习极客学院黄申老师《程序员的数学基础课》学习笔记
        
"-----------------------------------------------------------------"


"""01 二进制：不了解计算机的源头， 你学什么编程"""

    1、什么是二进制计数法？

        数位，指一个数中每一个数字所占的位置。
        二进制就是使用2作为基数，类比过来，二进制的数位就是 2^n 的形式。

    2、计算机为什么使用二进制？

        计算机使用二进制和现代计算机系统的硬件实现有关，组成计算机系统
        的逻辑电路通常只有两种状态，即开关的接通和断开。
        断开状态我们用 "0" 表示，接通状态我们用 "1" 表示。
        在具体的实现中，二进制数据表达具有抗干扰能力强，可靠性高的优点。
        如果用十进制设计具有10中状态的电路，情况会非常复杂，判断状态出错
        的几率大大提高。
        
        另外，二进制也非常适合逻辑运算。逻辑运算中的真和假对应二进制中的 "1" 和 "0"。
        逻辑运算中的加法("或"运算)、乘法("与"运算)以及否定（"非"运算）都可以通过
        "0"或"1" 的加法、减法和乘法来实现。
        
        二进制的四则运算:
        
            加法运算： 0 + 0 = 0， 1 + 0 = 1， 0 + 1 = 1， 1 + 1 = 10，逢二进 1 
            
            减法运算： 1 - 1 = 0， 1 - 0 = 1， 0 - 0 = 0， 0 - 1 = 1，向高位借1当2
            
            乘法运算： 0 * 0 = 0， 0 * 1 = 0， 1 * 0 = 0， 1 * 1 = 1，同时为1 结果才是1
            
            除法运算： 二进制数只有两个数，因此它的商是1 或 0 。
        
        示例：
                   
            1101 （13） + 1010 （10） = 10111 （23）
            
            1101 （13） - 1010 （10） = 011 （3）
            
            1101 （13） *  1010 （10）= 10000010 （130）
                
                        1  1  0  1
                        1  0  1  0
                    ----------------
                        0  0  0  0
                     1  1  0  1 
                  0  0  0  0
               1  1  0  1      
            -------------------------
            1  0  0  0  0  0  1  0        
        
            1010 （10） / 10 = 0101 (5)
                
              
                         
    3、二进制的位操作:
        
        计算语言中针对二进制的为操作，这里的位操作也叫位运算，就是直接对内存中
        的二进制进行操作。常见左移位和右移位的移位操作，以及"或" 与 "异或" 的逻辑操作。
        
        二进制数：110101 向左移一位，就是在末尾添加一位 0，因此 110101 就变成了 1101010。
        这里没有考虑数字溢出的情况，所谓的数字溢出，就是二进制数的位数超过了系统所指定的位数。
        目前主流的系统都支持至少32位的整型数字，110101不会溢出。如果进行左移操作的二进制数
        已经超过了 32 位，左移后数字就会溢出，需要将溢出的位数去除。
        
        二进制左移一位，其实就是将数字翻倍
        二进制右移一位，就是将数字除以 2 并求整数商的操作。
        
        1101 （13, 右移一位） ----> 110 （6, 13 // 2 = 6）
        
        因为有符号为的存在，在 python 中，右移可以分为
        逻辑右移： 右移一位，左边补 0, 使用符号 ">>>" 表示
        算术右移： 右移一位，保持符号位不变，右移一位并补符号位 1,补的 1 仍然是符号位之后。
        
        在 C 或 C++ 中，逻辑右移和算术右移共有一个 >> 符号，通过判断运算数类型，采用不同右移
        
        
        与 ： 同 1 为 1, 不同为 0 
        或 ： 有 1 为 1, 同 0 为 0 
        异或：不同为 1 , 相同为 0
        
        "异或"操作本质其实就是，所有数值和自身进行按位"异或"操作之后都为 0.
        而且要通过"异或"操作得当 0 ，也必须通过两个相同的数值进行按位"异或"。
        这表明了两个数值按位"异或"结果为 0 ，是这两个数值相等的必要充分条件，
        可以最为判断两个变量是否相等的条件。
        
    4、作业题，用位移和位运算实现 10 进制转换为 2 进制
    
        def binary2(num):
        if num == 0:
            return '0'
        else:
    
            return binary2(num >> 1) + str(num & 1)
    
    
        if __name__ == '__main__':
        
            num  = int(input("please a decimal:"))
        
            print((binary2(num)))    
    
    
      
"""02 02 余数：原来取余操作本身就是个哈希函数"""
    
    1、同余定理：
    
        余数总是在一个固定的范围内，比如你拿任何一个整数除以 7 ，那么得到的余数肯定在
        0 ~ 6 之间的某一个数。所以我们知道 1900 年的 1 月 1 日是星期几，那么我们就
        可以推算出这一天之后的第 1 万天， 10 万天是星期几。
    
        整数是没有边界的，可以是正无穷，也可能是负无穷，但是余数却可以通过某种关系
        让整数处于一个确定的范围内。
        
        简单的来说，就是两个整数 a 和 b , 如果他们除以正整数 m 得到的余数相等，
        我们就可以说 a 和 b 对于模 m 同余。
    
        我们经常提到的奇数和偶数，其实也就是同余定理的一个应用。当然这个应用模就是 2 ，
        除以 2 余数为 0 的是偶数， 余数为 1 的是奇数。
    
        同余定理的作用：
    
            同余定理其实就是用来分类的。
        
            我们有无穷多个整数，那么怎么能够全面，多维度的管理这些整数，
            同余定理就提供了一种思路。
                  
    2、哈希函数（Hash） 也称为散列函数:
        
        简单的来说，它就是将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出。
        
        举个例子：假如你想要快速读写 100 万条数据记录， 要达到高速的存取，最理想的
        情况当然是开辟一个连续的内存空间存放这些数据，这样就会减少寻址的时间。但是
        由于条件的限制，我们并没有能够容纳 100 万条记录的连续地址空间，这个时候该
        怎么办？
        
        我们可以考察一下，看看系统中是够可以提供若个较小的连续空间，而每个空间又能
        存放一定数量的记录。比如我们找到了 100 个较小的连续空间，也就是说，这些
        空间彼此之间是被分隔开来的，但是内部是连续的，并足够容纳 1 万条连续存放。
        那么我们可以使用余数和同余定理来设计一个散列函数，并实现哈希表的结构。
        
        一种方法：
        
                f(x) = x mod size
                
                x : 等待被转换的值
                mod : 取余操作
                size : 表示有限存储空间的大小
                
                通过余数，你就能将任何数值，转换为有限范围内的一个数值，然后
                根据这个新的数值，来确定将数据存放在何处。
        
            具体来说，我们可以通过记录标号模 100 的余数，指定某条记录存放在那个空间，
            这个时候，我们的公式变成了这样：
        
                f(x) = x mod 100
                
            假设有两条记录，他们记录标号分别是 1 和 101 。我们把这些模 100 之后
            的余数都是 1 的，存放到第 1 个可用的空间里。依次类推，将余数为 2 的
            2 、 102、202 存放在 2 个可用的空间里，将 100 、 200、300 等存放
            到第 100 个可用空间里。
            
            这样，我们就可以根据求余的快速数字变化，对数据进行分组，并且把他们存放
            到不同的地址空间里。而求余操作本身非常简单，因此几乎不会增加寻找时间。
            
            除此之外，为了增加数据散列的随机程度，我们还可以在公式中加入一个较大
            的随机数 MAX, 于是， 上面的公式就可以写成下面这样:
            
                f(x) = (x + MAX) mod size
                
            我们假设随机数 MAX 是 590199，那么我们针对标号为 1 的记录重新进行计算
            最后的计算结果是 0 ，而针对标号是 101 的记录，如果随机数 MAX 取 627901
            对应的结果应该是 2 。 这样之前被分配到空间 1 的两条记录，在新的公式下
            被分配到不同的可用空间中。
            这样更适合需要将数据重新洗牌的应用场景，比如加密算法、 MapReduce 中的数据分析
            记录的高速查询和定位等等。
            
            让我们以加密算法为例， 在这里引入 MAX 随机数就可以增强加密算法的保密程度，
            比如说，我们要加密一组三位数，那我们设定一个这样的加密规则：
            
                1、先对每个三位数的个、十和百位数，都加上一个较大的随机数。
                
                2、然后将每位上的数都除以 7 ，用所得的余数代替原有的个、十、百位数。
                
                3、最后将第一位和第三位交换
                
             假如，我们加密 625 ，根据刚才的规则，我们来试试，假设随机数选择 590127，
             那么。百，十，个 分别加上这个随机数，就变成了 590133,590129,590132。
             然后分别除以 7 求余后等到 5， 1， 4. 最终我们的加密后得到数据是 415。         
 
                       
"""03 迭代法：不用编程语言的自带函数，你会如何计算平方根"""

    1、到底什么是迭代法？
    
        迭代法，简单的来说，其实就是不断地用旧的变量值，递推计算新的变量值。
        
        迭代法的思想很容易通过计算机语言中的循环语言来实现。
        
        迭代法的思想很容易通过计算机语言中的循环语言来实现，我们可以通过循环语句
        让计算机重复执行迭代中的递推步骤，推到出变量的最终值。
        
    2、迭代法的基本步骤是什么？
        
        确定用于迭代的变量
        建立迭代变量之间的递推关系
        控制迭代过程
        
        
        
    3、迭代法有什么具体应用？
        
        a. 求数值的精确或者近似解。典型方法包括二分法(Bisection method)和牛顿迭代法(Newtin's method)
        
        b. 在一定范围内查找目标值。典型的方法包括二分查找。
        
        c. 机器学习算法中的迭代。（相关算法和模型很多，比如 K-均值算法, PageRank 的马尔科夫链， 梯度下降法）
            很多时候机器学习的过程，就是根据已知的数据和一定的假设，求一个局部最优解，而迭代法
            可以帮助学习算法逐步搜索，直至发现这种解。
            
    4、求数值解和查找匹配记录的两个应用
    
        a. 求方程的精确或者近似解
        
            迭代法在数学和编程中的应用很多，如果只能用来计算庞大的数字，那就太"暴殄天物"了。
            迭代法还可以帮助我们进行无穷次的逼近，求得方程的精确或者近似解。
            
            比如，我们想计算给定某个正整数 n (n > 1) 的平方根，如果不使用编程语言自带的函数
            你会如何实现？
                
            假设有正整数 n , 这个平方根一定小于 n 本身，并且 大于 1。 那么这个问题就转换成
            在 1 到 n 之间，找一个数字等于 n 的平方根。
            
            我这里采用迭代中常见的二分法，每次查看区间内的中间值，检验它是否符合标准。
            
            举个例子，假如我们要找到 10 的平方根，我们需要在看 1 到 10 的中间数值，也就是
            11 / 2 = 5.5 , 5.5 的平方大于 10，所以我们取一个更小的数值，就看 5.5 和 1 之间
            的 3.25， 3.25 的平方也大于 10， 我们查看 3.25 和 1 之间的数值，也就是 2.125。
            如此这样一直下去，直到发现某个数的平方正好是 10 。
            
            代码如下：
            
            def getSqureRoot(n, deltaThreshold, maxTry):

                if n <= 1:
                    return  1.0
            
                min = 1.0
                max = float(n)
            
                for i in range(maxTry):
            
                    middle = float((min + max) / 2)
                    square = float(middle * middle)
                    delta = float(abs((square / n) - 1))
            
                    if delta <= deltaThreshold:
                        return  middle
                    else:
                        if square > n:
                            max = middle
                        else:
                            min = middle
                return 2.0
            
            if __name__ == '__main__':
            
                number = int(input("pelase input a number:"))
            
                squareRoot = getSqureRoot(number, 0.000001, 10000)
                if squareRoot == -1.0:
                    print("please input greather than 1 number")
                elif squareRoot == -2.0:
                    print("No solution found !")
                else:
                    print("number :{0}, square root :{1}".format(number, squareRoot))
    
                
                上面的代码中，使用了 deltaThreshold 来控制解的精度。
                虽然理论上二分法可以无限迭代求得精确解，但是考虑到使用中消耗的问题，
                很多时候，我们求近似解。
                
                使用了 maxTry 来控制循环次数，没有使用 while(True) 循环，避免死循环，
                虽然使用了 deltaThreshold ，理论上不会陷入死循环，但是出于良好的代码
                的编程习惯，我们尽量避免产生的可能性。
        
        
        b. 查找匹配记录:         
            
            二分法中的迭代式逼近，不仅可以帮助我们求得近似解，还可以帮助我们查找匹配的记录。
            
            代码如下：
            
            def binary_search(list, world):
            
                """
                Description : 查找某个单词是否在列表中
                :param list: 排序后的列表
                :param world: 待查找的单词
                :return: 是否发现待查找的单词
                """
                if list is None:
                    return False
                elif len(list) == 0:
                    return  False
            
                left = 0
                right = len(list) - 1
            
                while(left <= right):
            
                    middle = left + (right - left) // 2
            
                    if list[middle] == world:
                        return  True
                    else:
            
                        if list[middle] > world:
                            right = middle - 1
                        else:
                            left = middle + 1
            
            if __name__ == '__main__':
            
                list_search = ['i', 'am', 'one', 'of', 'the', 'authors', 'in', 'geekbang']
                list_search.sort()
            
                wordToFind = 'i'
            
                found = binary_search(list_search, wordToFind)
            
                if(found):
                    print("found it")
                else:
                    print("not found it")     
            
    5、小结：
    
        人们并不擅长重复性的劳动，而计算机很适合做这样的事，这也是为什么
        以重复为特点的迭代法在编程中有着广泛的应用，但是现实生活中我们往往
        会忽略迭代法的使用，
        所以，要观察问题的现象，思考其本质，看看不断更新变量值或者缩小搜索
        的区间范围，是否可以获得最终的解，如果是，你可以尝试迭代法。
        
"""04 数学归纳法：如何用数学归纳提升代码的运行效率"""

    1、什么是数学归纳法:

        1 + 2 + 2^2 + 2^3 + 2^4 + ... + 2^63 = 2^64 - 1

        这种假设是否成立，还需要验证，但是对于类似这种无穷的数列问题，
        我们通过可以采用数学归纳法来证明。

        在数论中，数学归纳法用来证明任意一个给定的情形都是正确的
        数学归纳的步骤一般是这样的：

            （1） 证明通常情况(通常是 n = 1 的时候)是否成立

            （2） 假设 n = k -1 成立，再证明 n = k 也时成立的（K 为任意大于 1 的自然数）

        和使用迭代法的计算相比，数学归纳法最大的特点就在于 "归纳" 二字。它已经
        总结出了规律，只有我们能够证明这个规律是正确的，就没有必要进行逐步计算
        可以节省很多时间和资源。

    2、递归调用和数学归纳法的逻辑是一样的？

        下面是数学归纳法的证明过程看看是不是和递归调用一样？

        为了让你更好地理解，我们将原有的命题分为两个子命题来证明

         (1) 第一子命题，第 n 个棋格放的麦粒数为 2^(n-1)

              基本情况：我们已经验证了 n = 1 的时候，第一个格内
              麦粒数为 1 和 2^(1-1) 相等。因此，命题在 k = 1的时候成立。

              假设第 k - 1 格的麦粒数为 2^(k-2)，因为每个格是（2^(k-1)麦粒）。
               那么第 K 格麦粒数为第 k - 1 格的 2 倍（原始条件），也就是
               2^(k - 2) * 2 = 2^(k - 1)。因此如果 k = n - 1 的时候成立
               k = n 的时候成立。

         (2) 第二子命题，请 n 个棋格放的麦粒数总和为 2^n - 1

               基本情况： n = 1 的时候，麦粒总数为 1, 命题在 k = 1 成立。

               假设前 k - 1 格麦粒总数为 2^(k - 1) - 1, 基于这个命题的结论
               第 k 格的麦粒数为 2^(k - 1)。 那么前 k 格的麦粒数总数为：
               (2^(k - 1) - 1) + (2^(k - 1)) = 2*2^(k-1) = 2^k - 1。
               因此，如果命题在 k = n - 1 的时候成立，那么在 k = n 的时候也成立。

        首先，我们把数学归纳法证明，转换成一段伪代码，这个过程需要这样两步：

          (1) 第一步，如果 n 为 1 ，那么我们就判断麦粒总和是否为 2^(1 - 1) = 1
          同时，返回当前棋格的麦粒数，以及从第一格到当前麦粒总数。

          (2) 第二步，如果 n 为 k - 1 的时候成立，那么判断 n 为 k 的时候是否
           也成立，此时判断依赖于前一个格 k - 1 的麦粒数、第 1 格到 k - 1 格
           的麦粒总数。 这也是上一步返回的两个值。

           在数学归纳法的第二种情况， 我们只能假设 n = k - 1 的时候命题成立
           但是，在代码实现中，我们可以将伪代码的第二步转为函数的递归(嵌套)调用，
           直接被调用的函数退回到 n - 1 的情况。然后，被调用的函数逐步返回 k - 1
           时命题是否成立。

        证明程序：

        class Result(object):
            def __init__(self):
                self.wheatNum = 0          # 当前格的麦粒数
                self.wheatTotalNum = 0     # 从 1 格到当前格的麦粒总数

        class Lession4_2(object):
            """
                :Description: 使用函数的递归（嵌套）调用，进行数学归纳证明
                :param k - 放到底几个格， result -保存当前格子的麦粒数和麦粒总数
                :return boolean - 放到第 K 格时是否成立
            """

            def prove(self, k, result):

                #证明 n = 1 时， 命题是否成立
                if k == 1:
                    if (pow(2, 1) - 1) == 1:
                        result.wheatNum = 1
                        result.wheatTotalNum = 1
                        return True
                    else:
                        return False

                # 如果 n = (k - 1) 时命题成立，证明 n = k 时命题是否成立
                else:

                    proveOfPreviousOne = self.prove(k - 1, result)

                    result.wheatNum *= 2
                    result.wheatTotalNum += result.wheatNum

                    proveOfCurrentOne = False

                    if result.wheatTotalNum == pow(2, k) -1:
                        proveOfCurrentOne = True

                    if proveOfPreviousOne and proveOfCurrentOne:
                        return True
                    else:
                        return False

        if __name__ == "__main__":
            grid = 63
            result = Result()
            lesion = Lession4_2()

            print(lesion.prove(grid, result))

        最大测试 grid = 63, 如此测试 64 数据会溢出。
        
        函数从 k = 63 开始调用，然后调用 k - 1，也就是 62，一直 k = 1 时候
        嵌套调用结束， k = 1 的函数开始返回值给 k = 2的函数体，一直到 k = 63 的函数体。
        从 k = 63, 62, ..., 2, 1 的嵌套调用过程，其实就是体现了数学归纳法的核心思想，
        我们把它称为"逆向递推"。而从 k = 1, 2, ....,62,63的值的返回过程和基于循环迭代
        的过程是一致的，我们称为正向递推。
        
        递归过程的函数值返回实现了从 k = 1开始到 k = n 的迭代。说到这里你可能会好奇：
        既然递归最后返回值的过程和基于循环的迭代是一致，那为什么还需要使用递归的方法呢？
        
    3、小结：
    
        数学归纳法和归纳有什么不一样？
        
            平时我们谈的"归纳"是从经验事实中找出普遍特征的认知方法。
            数学归纳法的一般步骤是：证明基本情况是否成立；再假设 n = k - 1成立
            证明 n = k 也是成立的。
            
        数学归纳法和迭代法有什么不一样？
         
            和迭代法相比，数学归纳法最大的特点就在 "归纳" 二字。
            它已经总结出规律，只有证明这个规律正确，就没有比要进行逐步的
            推算，可以节省很多资源。
        
        递归调用和数学归纳法的逻辑是一样的
            
            只有数学归纳证明的逻辑是对的，递归调用的逻辑就是对的。


"""05 递归（上）: 泛化数学归纳，如何将复杂问题简单化"""

    1、 既然递归的函数值返回过程和基于循环的迭代法一致，我们直接用迭代法
        不就好了，为什么还要用递归的数学思想和编程方法呢？

        这是因为，某些场景下，递归的解法比基于循环的迭代法更容易实现。
        这是为什么呢？继续看 舎罕王赏麦的故事

    2、如何在限定总和的情况下，求所有可能的加和方式？

        假设有四种面额的钱币，1元、2元、5元、10元，而您一共给我 10 元。
        你可以给我 1 张 10 元，或者 10 张 1 元或者 5 张 1 元外加 1 张
        5 元，如果考虑每次奖赏的金额和先后顺序，那么最终会有多少种不同的
        奖赏方式？

        这个问题和之前的棋盘上放麦粒的有所不同，它并不是要求你给出最终
        的总数，而是在限定总和的情况下，求所有可能的加和方式。

        虽然问题不一样，但是求和的重复性操作是一样的，因此是否可以使用迭代法
        好，让我们使用迭代法试一下。

        还是使用迭代法中的术语，考虑 k = 1, 2, 3, ...., n　的情况。
        在第一步，也就是当 n = 1 的时候，我们可以取四种面额中的任何一个
        那么当前的奖赏就是 1元、2元、5元和10元。当 n = 2的时候奖赏的总和
        就有很多种可能性。1 + 1 = 2，1 + 2 = 3，1 + 5 = 6，2 + 1 = 3,
        2 + 2 = 4，...，这种可能的情况在快速的“膨胀”。
        虽然迭代法的思想是可行的，但是如果循环来实现，恐怕要保存很多种
        中间状态极其对应的变量。

    3、函数递归：

        在递归种，每次嵌套都会让函数体生成自己的局部变量，正好可以用来保存
        不同状态下的数值，为我们省去大量的操作，极大的方便设计和编程。
        但是这里不是计算一个值，而是列举出所有的可能性，那应该如何使用递归
        来解决，
        递归编程体现了数学归纳法的思想，但是我们把这个思想泛化一下，那么递归
        就会有更多、更广泛的应用。

        如果把复杂的问题简单化？

            如何将数学归纳法的思想泛化成更一般的情况？数学归纳法考虑两种情况
                （1） 初始状态， 也就是 n = 1 的时候，命题是否成立
                （2） 如果 n = k - 1 的时候，命题成立。那么只要证明 n = k
                    的时候，命题也成立，其中 k 为大于 1 的自然数。

            将上述两点顺序更换一下，再抽象化一下，我写出这样的递推关系：

                （1）假设 n = k - 1 的时候，问题已经解决（或者已经找到解）。
                    那么只要求解 n = k 的时候问题如何解决（或者解是多少）
                （2）初始状态，就是 n = 1 的时候，问题如何解决(或者解释多少)。

            我认为这种思想就是将复杂的问题，每次都解决一点点，并将剩下的任务
            转化为更简单的问题等待下次求解，如此反复，直到最简单的形式。

        回到例子，我们将这种思想具体化：

            （1）假设 n = k - 1 的时候，我们已经知道如何去求所有奖赏的组合。
                那么只要求解 n = k 的时候，会有哪些金额的选择，以及每种选择后
                还剩下多少奖金需要支付就可以了。
            （2）初始状态，就是 n = 1 的时候，
            
        代码实现:
            
            import copy
            def get_items(totalReward, result):
            
                rewards = [1, 2, 5, 10]
            
                if totalReward == 0:
                    print(result)
                    return
                elif totalReward < 0:
                    return
                else:
                    for i in range(len(rewards)):
                        newReword = copy.deepcopy(result)
                        newReword.append(rewards[i])
                        get_items(totalReward - rewards[i], newReword)
            
            if __name__ == "__main__":
            
                alist = list()
                get_items(10, alist)
                
        代码需要注意的几个点:
            
            （1）由于一种只有 4 种金额的纸币，所以无论是 n = 1 的时候还是 n = k 的
               时候，我们只需要关系 4 中金额对组合产生的影响，而中间状态和变量的记录
               和跟踪这些繁琐的事都由函数的递归调用负责。
            
            （2）这个案例限制条件的不在是 64 个格，而是奖赏总金额，因此判断嵌套
                调用的是否结束的条件其实不是次数 k ,而是总金额，确保不会死循环
            
            （3）这里从金额的总金额开始，每次嵌套调用时候减去一张纸币的金额，直到
                多有金额 为 0，然后结束循环返回结果，当然也可以从金额 0 开始，
                每次调用增加一张纸币的额度，直到累计金额达到或超过总金额。
    4、小结：
    
        递归和循环其实都是迭代法的实现，而且在某些场合下，他们的实现是可以相互转化的。
        但是，在某些场景，递归很难被循环取代，主要有两点原因：
        
        （1）递归的核心思想和数学归纳法类似，并更具有广泛性。这两者的类似之处在体现在：
            将当前的问题化解为两部分：一个当前所采取的步骤和另一个更简单的问题。
            
            一个当前所采取的步骤：
                这个步骤可能是进行一次运算（例如每个棋格中麦粒数是前一个两倍）
                或者做一个选择（选择不同面额的纸币），或者不同类型操作的结合等等。
            
            另一个等简单的问题：
                这里"简单一点"指计算的结果离目标值更近（例如赏金总额）
                或者是完成了更多的选择（例如纸币的选择）。而"更简单的问题"
                又可以通过嵌套调用，进一步简化和求解，直至到达结束条件。
                
        (2) 递归会使用计算机的函数嵌套调用，而函数的调用本身，就可以保存很多中间状态
            和变量值，因此极大的方便了编程的处理。
            
            
    5、今日学习笔记：
        
        （1）在递归中，每次嵌套调用都会让函数体生产自己的局部变量，正好可以用来
            保存不同状态下的值，为我们省去大量的中间变量操作，极大地方便了设计和编程。
            
        （2）递归就是将复杂问题，每次都解决一点点，并将剩下的任务转换成为更简单的问题
             等待下次求解，如此反复，直到最简单的形式。
             
        （3） 递归和循环都是迭代法的实现，而在某些场合下，可以互相转化。
        
    6、课后习题：
    
        一个整数可以分解为多个整数的乘积，例如， 6 可以分解为 2 * 3，请使用递归
        编程的方法，为给定的 n , 找到所有可能的分解，例如 输入 8 ，输出是可以是
            1 * 8；
            8 * 1；
            2 * 4；
            4 * 2；
            1 * 2 * 2 * 2；
            1 * 2 * 4
            
            
                            
    
            

        









                
            
      
 
  
    
        
    
    

       
        
        
        
        
    
    
    
        
        
              

