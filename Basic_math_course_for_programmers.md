"-----------------------------------------------------------------"

       本篇笔记是学习极客学院黄申老师《程序员的数学基础课》学习笔记
        
"-----------------------------------------------------------------"


"""01 二进制：不了解计算机的源头， 你学什么编程"""

    1、什么是二进制计数法？

        数位，指一个数中每一个数字所占的位置。
        二进制就是使用2作为基数，类比过来，二进制的数位就是 2^n 的形式。

    2、计算机为什么使用二进制？

        计算机使用二进制和现代计算机系统的硬件实现有关，组成计算机系统
        的逻辑电路通常只有两种状态，即开关的接通和断开。
        断开状态我们用 "0" 表示，接通状态我们用 "1" 表示。
        在具体的实现中，二进制数据表达具有抗干扰能力强，可靠性高的优点。
        如果用十进制设计具有10中状态的电路，情况会非常复杂，判断状态出错
        的几率大大提高。
        
        另外，二进制也非常适合逻辑运算。逻辑运算中的真和假对应二进制中的 "1" 和 "0"。
        逻辑运算中的加法("或"运算)、乘法("与"运算)以及否定（"非"运算）都可以通过
        "0"或"1" 的加法、减法和乘法来实现。
        
        二进制的四则运算:
        
            加法运算： 0 + 0 = 0， 1 + 0 = 1， 0 + 1 = 1， 1 + 1 = 10，逢二进 1 
            
            减法运算： 1 - 1 = 0， 1 - 0 = 1， 0 - 0 = 0， 0 - 1 = 1，向高位借1当2
            
            乘法运算： 0 * 0 = 0， 0 * 1 = 0， 1 * 0 = 0， 1 * 1 = 1，同时为1 结果才是1
            
            除法运算： 二进制数只有两个数，因此它的商是1 或 0 。
        
        示例：
                   
            1101 （13） + 1010 （10） = 10111 （23）
            
            1101 （13） - 1010 （10） = 011 （3）
            
            1101 （13） *  1010 （10）= 10000010 （130）
                
                        1  1  0  1
                        1  0  1  0
                    ----------------
                        0  0  0  0
                     1  1  0  1 
                  0  0  0  0
               1  1  0  1      
            -------------------------
            1  0  0  0  0  0  1  0        
        
            1010 （10） / 10 = 0101 (5)
                
              
                         
    3、二进制的位操作:
        
        计算语言中针对二进制的为操作，这里的位操作也叫位运算，就是直接对内存中
        的二进制进行操作。常见左移位和右移位的移位操作，以及"或" 与 "异或" 的逻辑操作。
        
        二进制数：110101 向左移一位，就是在末尾添加一位 0，因此 110101 就变成了 1101010。
        这里没有考虑数字溢出的情况，所谓的数字溢出，就是二进制数的位数超过了系统所指定的位数。
        目前主流的系统都支持至少32位的整型数字，110101不会溢出。如果进行左移操作的二进制数
        已经超过了 32 位，左移后数字就会溢出，需要将溢出的位数去除。
        
        二进制左移一位，其实就是将数字翻倍
        二进制右移一位，就是将数字除以 2 并求整数商的操作。
        
        1101 （13, 右移一位） ----> 110 （6, 13 // 2 = 6）
        
        因为有符号为的存在，在 python 中，右移可以分为
        逻辑右移： 右移一位，左边补 0, 使用符号 ">>>" 表示
        算术右移： 右移一位，保持符号位不变，右移一位并补符号位 1,补的 1 仍然是符号位之后。
        
        在 C 或 C++ 中，逻辑右移和算术右移共有一个 >> 符号，通过判断运算数类型，采用不同右移
        
        
        与 ： 同 1 为 1, 不同为 0 
        或 ： 有 1 为 1, 同 0 为 0 
        异或：不同为 1 , 相同为 0
        
        "异或"操作本质其实就是，所有数值和自身进行按位"异或"操作之后都为 0.
        而且要通过"异或"操作得当 0 ，也必须通过两个相同的数值进行按位"异或"。
        这表明了两个数值按位"异或"结果为 0 ，是这两个数值相等的必要充分条件，
        可以最为判断两个变量是否相等的条件。
        
    4、作业题，用位移和位运算实现 10 进制转换为 2 进制
    
        def binary2(num):
        if num == 0:
            return '0'
        else:
    
            return binary2(num >> 1) + str(num & 1)
    
    
        if __name__ == '__main__':
        
            num  = int(input("please a decimal:"))
        
            print((binary2(num)))    
    
    
      
"""02 02 余数：原来取余操作本身就是个哈希函数"""
    
    1、同余定理：
    
        余数总是在一个固定的范围内，比如你拿任何一个整数除以 7 ，那么得到的余数肯定在
        0 ~ 6 之间的某一个数。所以我们知道 1900 年的 1 月 1 日是星期几，那么我们就
        可以推算出这一天之后的第 1 万天， 10 万天是星期几。
    
        整数是没有边界的，可以是正无穷，也可能是负无穷，但是余数却可以通过某种关系
        让整数处于一个确定的范围内。
        
        简单的来说，就是两个整数 a 和 b , 如果他们除以正整数 m 得到的余数相等，
        我们就可以说 a 和 b 对于模 m 同余。
    
        我们经常提到的奇数和偶数，其实也就是同余定理的一个应用。当然这个应用模就是 2 ，
        除以 2 余数为 0 的是偶数， 余数为 1 的是奇数。
    
        同余定理的作用：
    
            同余定理其实就是用来分类的。
        
            我们有无穷多个整数，那么怎么能够全面，多维度的管理这些整数，
            同余定理就提供了一种思路。
                  
    2、哈希函数（Hash） 也称为散列函数:
        
        简单的来说，它就是将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出。
        
        举个例子：假如你想要快速读写 100 万条数据记录， 要达到高速的存取，最理想的
        情况当然是开辟一个连续的内存空间存放这些数据，这样就会减少寻址的时间。但是
        由于条件的限制，我们并没有能够容纳 100 万条记录的连续地址空间，这个时候该
        怎么办？
        
        我们可以考察一下，看看系统中是够可以提供若个较小的连续空间，而每个空间又能
        存放一定数量的记录。比如我们找到了 100 个较小的连续空间，也就是说，这些
        空间彼此之间是被分隔开来的，但是内部是连续的，并足够容纳 1 万条连续存放。
        那么我们可以使用余数和同余定理来设计一个散列函数，并实现哈希表的结构。
        
        一种方法：
        
                f(x) = x mod size
                
                x : 等待被转换的值
                mod : 取余操作
                size : 表示有限存储空间的大小
                
                通过余数，你就能将任何数值，转换为有限范围内的一个数值，然后
                根据这个新的数值，来确定将数据存放在何处。
        
            具体来说，我们可以通过记录标号模 100 的余数，指定某条记录存放在那个空间，
            这个时候，我们的公式变成了这样：
        
                f(x) = x mod 100
                
            假设有两条记录，他们记录标号分别是 1 和 101 。我们把这些模 100 之后
            的余数都是 1 的，存放到第 1 个可用的空间里。依次类推，将余数为 2 的
            2 、 102、202 存放在 2 个可用的空间里，将 100 、 200、300 等存放
            到第 100 个可用空间里。
            
            这样，我们就可以根据求余的快速数字变化，对数据进行分组，并且把他们存放
            到不同的地址空间里。而求余操作本身非常简单，因此几乎不会增加寻找时间。
            
            除此之外，为了增加数据散列的随机程度，我们还可以在公式中加入一个较大
            的随机数 MAX, 于是， 上面的公式就可以写成下面这样:
            
                f(x) = (x + MAX) mod size
                
            我们假设随机数 MAX 是 590199，那么我们针对标号为 1 的记录重新进行计算
            最后的计算结果是 0 ，而针对标号是 101 的记录，如果随机数 MAX 取 627901
            对应的结果应该是 2 。 这样之前被分配到空间 1 的两条记录，在新的公式下
            被分配到不同的可用空间中。
            这样更适合需要将数据重新洗牌的应用场景，比如加密算法、 MapReduce 中的数据分析
            记录的高速查询和定位等等。
            
            让我们以加密算法为例， 在这里引入 MAX 随机数就可以增强加密算法的保密程度，
            比如说，我们要加密一组三位数，那我们设定一个这样的加密规则：
            
                1、先对每个三位数的个、十和百位数，都加上一个较大的随机数。
                
                2、然后将每位上的数都除以 7 ，用所得的余数代替原有的个、十、百位数。
                
                3、最后将第一位和第三位交换
                
             假如，我们加密 625 ，根据刚才的规则，我们来试试，假设随机数选择 590127，
             那么。百，十，个 分别加上这个随机数，就变成了 590133,590129,590132。
             然后分别除以 7 求余后等到 5， 1， 4. 最终我们的加密后得到数据是 415。         
 
                       
"""03 迭代法：不用编程语言的自带函数，你会如何计算平方根"""

    1、到底什么是迭代法？
    
        迭代法，简单的来说，其实就是不断地用旧的变量值，递推计算新的变量值。
        
        迭代法的思想很容易通过计算机语言中的循环语言来实现。
        
        迭代法的思想很容易通过计算机语言中的循环语言来实现，我们可以通过循环语句
        让计算机重复执行迭代中的递推步骤，推到出变量的最终值。
        
    2、迭代法的基本步骤是什么？
        
        确定用于迭代的变量
        建立迭代变量之间的递推关系
        控制迭代过程
        
        
        
    3、迭代法有什么具体应用？
        
        a. 求数值的精确或者近似解。典型方法包括二分法(Bisection method)和牛顿迭代法(Newtin's method)
        
        b. 在一定范围内查找目标值。典型的方法包括二分查找。
        
        c. 机器学习算法中的迭代。（相关算法和模型很多，比如 K-均值算法, PageRank 的马尔科夫链， 梯度下降法）
            很多时候机器学习的过程，就是根据已知的数据和一定的假设，求一个局部最优解，而迭代法
            可以帮助学习算法逐步搜索，直至发现这种解。
            
    4、求数值解和查找匹配记录的两个应用
    
        a. 求方程的精确或者近似解
        
            迭代法在数学和编程中的应用很多，如果只能用来计算庞大的数字，那就太"暴殄天物"了。
            迭代法还可以帮助我们进行无穷次的逼近，求得方程的精确或者近似解。
            
            比如，我们想计算给定某个正整数 n (n > 1) 的平方根，如果不使用编程语言自带的函数
            你会如何实现？
                
            假设有正整数 n , 这个平方根一定小于 n 本身，并且 大于 1。 那么这个问题就转换成
            在 1 到 n 之间，找一个数字等于 n 的平方根。
            
            我这里采用迭代中常见的二分法，每次查看区间内的中间值，检验它是否符合标准。
            
            举个例子，假如我们要找到 10 的平方根，我们需要在看 1 到 10 的中间数值，也就是
            11 / 2 = 5.5 , 5.5 的平方大于 10，所以我们取一个更小的数值，就看 5.5 和 1 之间
            的 3.25， 3.25 的平方也大于 10， 我们查看 3.25 和 1 之间的数值，也就是 2.125。
            如此这样一直下去，直到发现某个数的平方正好是 10 。
            
            代码如下：
            
            def getSqureRoot(n, deltaThreshold, maxTry):

                if n <= 1:
                    return  1.0
            
                min = 1.0
                max = float(n)
            
                for i in range(maxTry):
            
                    middle = float((min + max) / 2)
                    square = float(middle * middle)
                    delta = float(abs((square / n) - 1))
            
                    if delta <= deltaThreshold:
                        return  middle
                    else:
                        if square > n:
                            max = middle
                        else:
                            min = middle
                return 2.0
            
            if __name__ == '__main__':
            
                number = int(input("pelase input a number:"))
            
                squareRoot = getSqureRoot(number, 0.000001, 10000)
                if squareRoot == -1.0:
                    print("please input greather than 1 number")
                elif squareRoot == -2.0:
                    print("No solution found !")
                else:
                    print("number :{0}, square root :{1}".format(number, squareRoot))
    
                
                上面的代码中，使用了 deltaThreshold 来控制解的精度。
                虽然理论上二分法可以无限迭代求得精确解，但是考虑到使用中消耗的问题，
                很多时候，我们求近似解。
                
                使用了 maxTry 来控制循环次数，没有使用 while(True) 循环，避免死循环，
                虽然使用了 deltaThreshold ，理论上不会陷入死循环，但是出于良好的代码
                的编程习惯，我们尽量避免产生的可能性。
        
        
        b. 查找匹配记录:         
            
            二分法中的迭代式逼近，不仅可以帮助我们求得近似解，还可以帮助我们查找匹配的记录。
            
            代码如下：
            
            def binary_search(list, world):
            
                """
                Description : 查找某个单词是否在列表中
                :param list: 排序后的列表
                :param world: 待查找的单词
                :return: 是否发现待查找的单词
                """
                if list is None:
                    return False
                elif len(list) == 0:
                    return  False
            
                left = 0
                right = len(list) - 1
            
                while(left <= right):
            
                    middle = left + (right - left) // 2
            
                    if list[middle] == world:
                        return  True
                    else:
            
                        if list[middle] > world:
                            right = middle - 1
                        else:
                            left = middle + 1
            
            if __name__ == '__main__':
            
                list_search = ['i', 'am', 'one', 'of', 'the', 'authors', 'in', 'geekbang']
                list_search.sort()
            
                wordToFind = 'i'
            
                found = binary_search(list_search, wordToFind)
            
                if(found):
                    print("found it")
                else:
                    print("not found it")     
            
    5、小结：
    
        人们并不擅长重复性的劳动，而计算机很适合做这样的事，这也是为什么
        以重复为特点的迭代法在编程中有着广泛的应用，但是现实生活中我们往往
        会忽略迭代法的使用，
        所以，要观察问题的现象，思考其本质，看看不断更新变量值或者缩小搜索
        的区间范围，是否可以获得最终的解，如果是，你可以尝试迭代法。
        
"""04 数学归纳法：如何用数学归纳提升代码的运行效率"""

    1、什么是数学归纳法:

        1 + 2 + 2^2 + 2^3 + 2^4 + ... + 2^63 = 2^64 - 1

        这种假设是否成立，还需要验证，但是对于类似这种无穷的数列问题，
        我们通过可以采用数学归纳法来证明。

        在数论中，数学归纳法用来证明任意一个给定的情形都是正确的
        数学归纳的步骤一般是这样的：

            （1） 证明通常情况(通常是 n = 1 的时候)是否成立

            （2） 假设 n = k -1 成立，再证明 n = k 也时成立的（K 为任意大于 1 的自然数）

        和使用迭代法的计算相比，数学归纳法最大的特点就在于 "归纳" 二字。它已经
        总结出了规律，只有我们能够证明这个规律是正确的，就没有必要进行逐步计算
        可以节省很多时间和资源。

    2、递归调用和数学归纳法的逻辑是一样的？

        下面是数学归纳法的证明过程看看是不是和递归调用一样？

        为了让你更好地理解，我们将原有的命题分为两个子命题来证明

         (1) 第一子命题，第 n 个棋格放的麦粒数为 2^(n-1)

              基本情况：我们已经验证了 n = 1 的时候，第一个格内
              麦粒数为 1 和 2^(1-1) 相等。因此，命题在 k = 1的时候成立。

              假设第 k - 1 格的麦粒数为 2^(k-2)，因为每个格是（2^(k-1)麦粒）。
               那么第 K 格麦粒数为第 k - 1 格的 2 倍（原始条件），也就是
               2^(k - 2) * 2 = 2^(k - 1)。因此如果 k = n - 1 的时候成立
               k = n 的时候成立。

         (2) 第二子命题，请 n 个棋格放的麦粒数总和为 2^n - 1

               基本情况： n = 1 的时候，麦粒总数为 1, 命题在 k = 1 成立。

               假设前 k - 1 格麦粒总数为 2^(k - 1) - 1, 基于这个命题的结论
               第 k 格的麦粒数为 2^(k - 1)。 那么前 k 格的麦粒数总数为：
               (2^(k - 1) - 1) + (2^(k - 1)) = 2*2^(k-1) = 2^k - 1。
               因此，如果命题在 k = n - 1 的时候成立，那么在 k = n 的时候也成立。

        首先，我们把数学归纳法证明，转换成一段伪代码，这个过程需要这样两步：

          (1) 第一步，如果 n 为 1 ，那么我们就判断麦粒总和是否为 2^(1 - 1) = 1
          同时，返回当前棋格的麦粒数，以及从第一格到当前麦粒总数。

          (2) 第二步，如果 n 为 k - 1 的时候成立，那么判断 n 为 k 的时候是否
           也成立，此时判断依赖于前一个格 k - 1 的麦粒数、第 1 格到 k - 1 格
           的麦粒总数。 这也是上一步返回的两个值。

           在数学归纳法的第二种情况， 我们只能假设 n = k - 1 的时候命题成立
           但是，在代码实现中，我们可以将伪代码的第二步转为函数的递归(嵌套)调用，
           直接被调用的函数退回到 n - 1 的情况。然后，被调用的函数逐步返回 k - 1
           时命题是否成立。

        证明程序：

        class Result(object):
            def __init__(self):
                self.wheatNum = 0          # 当前格的麦粒数
                self.wheatTotalNum = 0     # 从 1 格到当前格的麦粒总数

        class Lession4_2(object):
            """
                :Description: 使用函数的递归（嵌套）调用，进行数学归纳证明
                :param k - 放到底几个格， result -保存当前格子的麦粒数和麦粒总数
                :return boolean - 放到第 K 格时是否成立
            """

            def prove(self, k, result):

                #证明 n = 1 时， 命题是否成立
                if k == 1:
                    if (pow(2, 1) - 1) == 1:
                        result.wheatNum = 1
                        result.wheatTotalNum = 1
                        return True
                    else:
                        return False

                # 如果 n = (k - 1) 时命题成立，证明 n = k 时命题是否成立
                else:

                    proveOfPreviousOne = self.prove(k - 1, result)

                    result.wheatNum *= 2
                    result.wheatTotalNum += result.wheatNum

                    proveOfCurrentOne = False

                    if result.wheatTotalNum == pow(2, k) -1:
                        proveOfCurrentOne = True

                    if proveOfPreviousOne and proveOfCurrentOne:
                        return True
                    else:
                        return False

        if __name__ == "__main__":
            grid = 63
            result = Result()
            lesion = Lession4_2()

            print(lesion.prove(grid, result))

        最大测试 grid = 63, 如此测试 64 数据会溢出。
        
        函数从 k = 63 开始调用，然后调用 k - 1，也就是 62，一直 k = 1 时候
        嵌套调用结束， k = 1 的函数开始返回值给 k = 2的函数体，一直到 k = 63 的函数体。
        从 k = 63, 62, ..., 2, 1 的嵌套调用过程，其实就是体现了数学归纳法的核心思想，
        我们把它称为"逆向递推"。而从 k = 1, 2, ....,62,63的值的返回过程和基于循环迭代
        的过程是一致的，我们称为正向递推。
        
        递归过程的函数值返回实现了从 k = 1开始到 k = n 的迭代。说到这里你可能会好奇：
        既然递归最后返回值的过程和基于循环的迭代是一致，那为什么还需要使用递归的方法呢？
        
    3、小结：
    
        数学归纳法和归纳有什么不一样？
        
            平时我们谈的"归纳"是从经验事实中找出普遍特征的认知方法。
            数学归纳法的一般步骤是：证明基本情况是否成立；再假设 n = k - 1成立
            证明 n = k 也是成立的。
            
        数学归纳法和迭代法有什么不一样？
         
            和迭代法相比，数学归纳法最大的特点就在 "归纳" 二字。
            它已经总结出规律，只有证明这个规律正确，就没有比要进行逐步的
            推算，可以节省很多资源。
        
        递归调用和数学归纳法的逻辑是一样的
            
            只有数学归纳证明的逻辑是对的，递归调用的逻辑就是对的。


"""05 递归（上）: 泛化数学归纳，如何将复杂问题简单化"""

    1、 既然递归的函数值返回过程和基于循环的迭代法一致，我们直接用迭代法
        不就好了，为什么还要用递归的数学思想和编程方法呢？

        这是因为，某些场景下，递归的解法比基于循环的迭代法更容易实现。
        这是为什么呢？继续看 舎罕王赏麦的故事

    2、如何在限定总和的情况下，求所有可能的加和方式？

        假设有四种面额的钱币，1元、2元、5元、10元，而您一共给我 10 元。
        你可以给我 1 张 10 元，或者 10 张 1 元或者 5 张 1 元外加 1 张
        5 元，如果考虑每次奖赏的金额和先后顺序，那么最终会有多少种不同的
        奖赏方式？

        这个问题和之前的棋盘上放麦粒的有所不同，它并不是要求你给出最终
        的总数，而是在限定总和的情况下，求所有可能的加和方式。

        虽然问题不一样，但是求和的重复性操作是一样的，因此是否可以使用迭代法
        好，让我们使用迭代法试一下。

        还是使用迭代法中的术语，考虑 k = 1, 2, 3, ...., n　的情况。
        在第一步，也就是当 n = 1 的时候，我们可以取四种面额中的任何一个
        那么当前的奖赏就是 1元、2元、5元和10元。当 n = 2的时候奖赏的总和
        就有很多种可能性。1 + 1 = 2，1 + 2 = 3，1 + 5 = 6，2 + 1 = 3,
        2 + 2 = 4，...，这种可能的情况在快速的“膨胀”。
        虽然迭代法的思想是可行的，但是如果循环来实现，恐怕要保存很多种
        中间状态极其对应的变量。

    3、函数递归：

        在递归种，每次嵌套都会让函数体生成自己的局部变量，正好可以用来保存
        不同状态下的数值，为我们省去大量的操作，极大的方便设计和编程。
        但是这里不是计算一个值，而是列举出所有的可能性，那应该如何使用递归
        来解决，
        递归编程体现了数学归纳法的思想，但是我们把这个思想泛化一下，那么递归
        就会有更多、更广泛的应用。

        如果把复杂的问题简单化？

            如何将数学归纳法的思想泛化成更一般的情况？数学归纳法考虑两种情况
                （1） 初始状态， 也就是 n = 1 的时候，命题是否成立
                （2） 如果 n = k - 1 的时候，命题成立。那么只要证明 n = k
                    的时候，命题也成立，其中 k 为大于 1 的自然数。

            将上述两点顺序更换一下，再抽象化一下，我写出这样的递推关系：

                （1）假设 n = k - 1 的时候，问题已经解决（或者已经找到解）。
                    那么只要求解 n = k 的时候问题如何解决（或者解是多少）
                （2）初始状态，就是 n = 1 的时候，问题如何解决(或者解释多少)。

            我认为这种思想就是将复杂的问题，每次都解决一点点，并将剩下的任务
            转化为更简单的问题等待下次求解，如此反复，直到最简单的形式。

        回到例子，我们将这种思想具体化：

            （1）假设 n = k - 1 的时候，我们已经知道如何去求所有奖赏的组合。
                那么只要求解 n = k 的时候，会有哪些金额的选择，以及每种选择后
                还剩下多少奖金需要支付就可以了。
            （2）初始状态，就是 n = 1 的时候，
            
        代码实现:
            
            import copy
            def get_items(totalReward, result):
            
                rewards = [1, 2, 5, 10]
            
                if totalReward == 0:
                    print(result)
                    return
                elif totalReward < 0:
                    return
                else:
                    for i in range(len(rewards)):
                        newReword = copy.deepcopy(result)
                        newReword.append(rewards[i])
                        get_items(totalReward - rewards[i], newReword)
            
            if __name__ == "__main__":
            
                alist = list()
                get_items(10, alist)
                
        代码需要注意的几个点:
            
            （1）由于一种只有 4 种金额的纸币，所以无论是 n = 1 的时候还是 n = k 的
               时候，我们只需要关系 4 中金额对组合产生的影响，而中间状态和变量的记录
               和跟踪这些繁琐的事都由函数的递归调用负责。
            
            （2）这个案例限制条件的不在是 64 个格，而是奖赏总金额，因此判断嵌套
                调用的是否结束的条件其实不是次数 k ,而是总金额，确保不会死循环
            
            （3）这里从金额的总金额开始，每次嵌套调用时候减去一张纸币的金额，直到
                多有金额 为 0，然后结束循环返回结果，当然也可以从金额 0 开始，
                每次调用增加一张纸币的额度，直到累计金额达到或超过总金额。
    4、小结：
    
        递归和循环其实都是迭代法的实现，而且在某些场合下，他们的实现是可以相互转化的。
        但是，在某些场景，递归很难被循环取代，主要有两点原因：
        
        （1）递归的核心思想和数学归纳法类似，并更具有广泛性。这两者的类似之处在体现在：
            将当前的问题化解为两部分：一个当前所采取的步骤和另一个更简单的问题。
            
            一个当前所采取的步骤：
                这个步骤可能是进行一次运算（例如每个棋格中麦粒数是前一个两倍）
                或者做一个选择（选择不同面额的纸币），或者不同类型操作的结合等等。
            
            另一个等简单的问题：
                这里"简单一点"指计算的结果离目标值更近（例如赏金总额）
                或者是完成了更多的选择（例如纸币的选择）。而"更简单的问题"
                又可以通过嵌套调用，进一步简化和求解，直至到达结束条件。
                
        (2) 递归会使用计算机的函数嵌套调用，而函数的调用本身，就可以保存很多中间状态
            和变量值，因此极大的方便了编程的处理。
            
            
    5、今日学习笔记：
        
        （1）在递归中，每次嵌套调用都会让函数体生产自己的局部变量，正好可以用来
            保存不同状态下的值，为我们省去大量的中间变量操作，极大地方便了设计和编程。
            
        （2）递归就是将复杂问题，每次都解决一点点，并将剩下的任务转换成为更简单的问题
             等待下次求解，如此反复，直到最简单的形式。
             
        （3） 递归和循环都是迭代法的实现，而在某些场合下，可以互相转化。
        
    6、课后习题：
    
        一个整数可以分解为多个整数的乘积，例如， 6 可以分解为 2 * 3，请使用递归
        编程的方法，为给定的 n , 找到所有可能的分解，例如 输入 8 ，输出是可以是
            1 * 8；
            8 * 1；
            2 * 4；
            4 * 2；
            1 * 2 * 2 * 2；
            1 * 2 * 4


"""06 递归（下）：分而治之，从归并排序到MapReduce"""   
    
    1、归并排序（merge sort）中的分治思想         
        
        归并排序算法的核心就是"归并" 也就是把两个有序的数列合并起来，形成一个更大的数列。
        假设 A = [1, 2, 3, 8] B = [3, 4, 6]，开辟一段内存 C , 用来存储 A, B合并后的序列。
        首先比较A , B 数列的第一个数，如果数列A 的第一个数小于 B 数列的第一个数，就先把 A 
        中的第一个数放到 C 中并把这个数从 A 数列中删除，从新比较 A, B 数列的第一个数，依次类推
        直到 A 和 B 数列为空，如果到了某一步，一个数列为空，那么把另一个数列依次取出放入 C 中。
        这种操作可以保证，两个有序数列 A 和 B 在合并之后 C 数列依然有序。        
        为了得到有序的 C 数列，我们必须保证参与合并的 A 和 B 也是有序的，如果无法保证这点，那归并
        又有什么意义呢？
        
    2、归并排序中的分治思想
    
        这里就可以用到归并思想，把问题不断简化，也就是把数列不断简化，一直简化到只剩 1 个数。
        一个数本身就是序的。
        
        现在剩下的疑惑就是，每次如何简化问题，最简单的想法是，我们把长度为 n 的数列，
        每次简化为 n - 1 的数列，直至长度为 1. 不过，这样的处理没有并行性，要进行 n - 1 次的
        并归操作，效率会很低。
        
        所以，我们可以在归并排序中引入了分而治之(Divide and Conquer)的思想。
        分而知治之，我们通常称为分治。它的思想就是，将一个复杂的问题，分解成两个甚至多个
        规模相同或类似的子问题，直到最后的子问题变得很简单，很容易就能被求解出来，这样
        这个复杂的问题就求解出来了。
        
        归并排序通过分治的思想，把长度为 n 的数列，每次简化为两个长度为 n/2 的数列。
        这样跟有利于计算机进行归并处理，只需要 Logn2n 次归并。
        
    3、归并排序的过程：
        
        (1) 假设初始数组为{7, 6, 2, 4, 1, 9, 3, 8, 0, 5},对它进行从小到大的排序
        
        (2) 第一次分解后，变成两个数组 {7, 6, 2, 4, 1} 和 {9, 3, 8, 0, 5}
        
        (3) 然后，我们将 {7, 6, 2, 4, 1} 分解为 {7, 6} 和 {2, 4, 1},
            将{9, 3, 8, 0, 5} 分解为 {9, 3} 和 {8, 0, 5}
        
        (4) 如果细分后的组仍然多余一个数字，我们就重复上述分解的步骤，直到每个组只包含一个数字。
            到这里，这些其实就是递归的嵌套调用过程。
        
        (5) 然后，我们开始合并，在合并中进行排序，合并后的结果将返回当前函数的调用者，这就是函数返回的过程。
        
        (6) 重复上述合并的过程，直到完成整个数组的排序，得到排序后的结果。 
                   
        归并排序，分治和递归到底是什么关系？   
            归并排序使用了分治的思想，而这个过程需要使用递归来实现。
        
    4、分治的过程可以通过递归来表达，因此，归并排序最直观的实现方式就是递归。
        所以，我们从递归的步骤出发，来看归并排序如何实现。
        
        我们假设 n = k -1 的时候，我们已经对较小的两组数进行了排序。那么我们只要在 n = k 的时候
        将两个数组合并起来，并且保证合并后的数组仍然是有序的就行了。
        
        所以，在递归的每次嵌套调用中，代码都将一组数分解成更小的两组，然后将两小组的排序
        交给习一次的嵌套调用，而本次调用只需要关心，如何将排序好的两个小组进行合并。
        
        在初始状态，也就是 n = 1 的时候，对于排序的案例而言，只包含单个数字的分组。
        由于分组里只有一个数字，所以已经是排序序的了，之后就可以开始递归调用的返回阶段。

    5、代码实现
            def mergeSort(alist):

                #当分解到列表只有一个值时，返回列表。
                if len(alist) <= 1:
                    return alist

                # 二分分解
                num = len(alist) // 2

                left = mergeSort(alist[:num])
                right = mergeSort(alist[num:])

                # 合并
                return merge(left, right)

            def merge(left, right):

                '''合并操作，将两个有序数列lstf,right 合并成一个更大的有序数组'''
                #left 与 right的下标指针
                l, r = 0, 0
                result = []

                while l < len(left) and r < len(right):
                    if left[l] < right[r]:
                        result.append(left[l])
                        l += 1
                    else:
                        result.append(right[r])
                        r += 1
                result += left[l:]
                result += right[r:]
                return result

            if __name__ == "__main__":

                list1 = [54, 26, 93, 17, 77, 31, 44, 55, 20]
                sortedList = mergeSort(list1)
                print(sortedList)


    6、分布式系列中的分治思想:

        分治更有趣的应用其实在分布式系统中。
        例如：当需要排序是数组很大（1024GB的时候），我们没有办法
        把这些数据都塞入一台普通的计算机的内存里。该怎么办呢？
        有一个办法，我们可以把这个超级大的数据集，分解为多个更
        小的数据集（比如 16GB或者更小），然后分配到多台计算机中，
        让它们并行是处理。

        等所有机器处理完后，中央服务器进行结果合并。由于多个小任务
        间不会相互干扰，可以同时处理，这样会大大的增强处理速度，减少
        等待时间。
        在单台机器上实现归并排序的时候，我们只需要在递归函数内，实现数据
        分组以及合并就行，而多个机器之间分配数据的时候，递归函数处理分组
        以及合并，还要负责吧数据分发到某台机器上。

    7、MapReduce 架构：

        MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。
        概念"Map（映射）"和"Reduce（归纳）"，及他们的主要思想，
        都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。

        当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，
        指定并发的Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组。

    8、小结：

        (1) 我们把归并和分治的思想结合起来，这其实就是归并排序算法。
            这种算法每次把数列进行二等分，直到唯一的数字，也就是
            最基本的有序数列。然后从这些基本数列开始两两合并有序数列，
            直到所有的数字都参与了归并排序。用一句话说就是，归并排序
            使用了分治的思想，而这个过程需要使用递归来完成。

        (2) 单台机器实现归并排序在函数内就可以完成，如果多台机器之间
        分配数据的时候，递归函数内除了分组及合并，还要把数据分发到某台
        机器上。如果分治的时候只进行一次问题切分，那层级型分布式架构
        可以转化为类似于 MapReduce 的架构，其中三个步骤用到了分治，
        分别是数据的分割和映射、归约、合并。


""" 数学专栏课外加餐（一）: 我们为什么需要反码和补码 """

    1、什么是符号位？为什么要有符号位？
    
        符号位是有符号二进制数中的最高位，我们需要它来表示负数。
    
        在实际的硬件系统中，计算机 CPU 的运算器只实现了加法器，而没有实现减法器。
        那么计算计如何做减法的呢？我们可以加上一个负数来达到这个目的。
        比如 3 - 2 可以看做 3 + （-2）。因此，负数的表示对于计算机的二进制减法
        至关重要。
    
    2、如何让计算机理解那些是正数，哪些是负数呢？
    
        为此，人们把二进制数分为有符号数（signed） 和 无符号数 （unsigned）
        
        如果是有符号数，那么最高位就是符号位，当符号位为 0 时，表示该数是正数；
        当符号位为 1 时，表示该数为负数。
        例如一个 8 位的有符号二进制数 10100010，最高为是 1 这就表示一个负数。
        
        
    
    3、什么是溢出?
    
        在数学的理论中，数字可以有无穷大，也有无穷小。可是在计算机系统中，总有一个物理极限。
        （比如晶体管的大小和数量），因此不可能表示无穷大或者无穷小的数字。对于计算机而言
        无论是什么数据类型，都是一个上限或下限
  
        在 java 中，int 型是 32 位，它是最大值也就是上限时2^32 - 1（最高位是符号位，所以
        是 2 的 31 次方而不是 32 次方），最小值也是也就是下限是 -2^31。
        
        对于 n 位的数字类型，符号位是 1, 后面 n - 1位全是 0，我们把这种情形表示为 -2^n,
        而不是 2^n，一旦某个数字超过了这些限定，就会发生溢出，如果超出上限，就叫上溢出（overflow）
        如果超出下限，就叫下溢出（underflow）
        
        那么溢出之后会发生什么呢？
        
            n 位数字的最大的正值，其符号位为 0，剩下的 n - 1 位都为 1，再增大一个就变为了符号位为
            1， 剩下的 n - 1 为都是 0 。而符号位为 1，剩下的 n - 1 位全是 0 ，我们表示为 -2^n
            那么就是说，上溢出之后，又从下限开始，最大的数值加 1，就变成了最小的数值，周而复始
            这不就是余数和取模的概念吗
            
            计算机的数据的溢出，就相当于取模。而用于取模的除数就是数据类型的上限减去下限的值，再加上 1，
            (2^(n-1) - 1) - (-2^(n-1)) + 1 = 2 * 2^(n-1) - 1 + 1 = 2^n - 1 + 1
            
            你可能会好奇，这个除数为啥不直接写成 2^n 呢？这是因为 2^n 已经是 n + 1 位了
            已经超出了 n 位所能表示的范围。
            
    4、二进制的原码、反码以及补码
    
        原码：
        
            就是二进制的原始表示，原码的最高位是有符号位，而其余的位用来表示该数字绝对值的二进制。
            
            例如。 + 2 的原码为 000...010,
                  - 2 的原码为 100...010。
            
            那么我们是不是可以直接使用负数的原码来进行减法计算呢？答案是否定的。
            例如 3 + (-2) 如果使用原码相加，结果是  -5 的原码了，而 3 + (-2) 应该等于 1，两者不符。
            
            如果负数的原码并不适用减法操作，那么改怎么办？
            这个问题的解答还有依赖于计算机的溢出机制，对减法进行变换。
        
        反码：
           
           正数的返码和原码一样
           负数的反码，符号位不变，其余各位取反
        
        补码：
            
            正数的补码和原码一样
            
            如果是负数，补码 = 反码 + 1（相当于将原码数值位取反然后在最低位加1） 
           
        在计算机中加上一个负数，就相当于加上这个负数的补码
    
    5、8位的有符号位二进制数 10100010，对应的那个10进制。
    
        计算中所有的负数采用是是补码形式存在，10100010 最高位为 1 是负数，
        负数的绝对值是其补码取反再加1，为 01011110。十进制为 94，因此，
        10100010 的十进制为 -94
                    
        第二种方案： 补码 = 反码 + 1
                    反码 = 补码 - 1
                    原码 = 反码（取反）

""" 数学专栏课加餐（二）：位操作的三个应用实例"""

    1、验证奇偶数：
        奇偶数其实也是余数的一个应用

        仔细观察你会发现，偶数的二进制最后一个总是 0，而奇数的二进制最后一位总是 1.
        因此给定一个数，我们可以通过这个数和数字 1 按位 "与" 操作，取得数字的最后一位。
        然后进行判断。

        import time
        def lession_append():
            even_cnt = 0
            odd_cnt = 0

            start = time.strftime("%H:%S",time.localtime())

            for i in range(100000000):

                if i & 1 == 0:
                # if i % 2 == 0:
                    even_cnt += 1
                else:
                    odd_cnt += 1

            end = time.strftime("%H:%S", time.localtime())

            print(start)
            print(end)
            print("even number[%d], odd number[%d]" % (even_cnt, odd_cnt))


        if __name__ == "__main__":
            lession_append()

        通过进行比较位运算的效率更好（27秒），余数是（30）秒
   
    2、交换两个数字：

        一般交换两个变量需要一个中间变量，来临时存放中的值，
        不过利用异或的特性可以避免中间变量。

         （1）x = (x ^ y)
         （2）y = x ^ y
         （3）x = x ^ y

        我们把 第一步代入到第二步中，可以得到：

           y = (x ^ y)^ y = x ^(y ^ y) = x ^ 0

        把第一步和第二步的结果代入到第三步中，可以得到：

            x = (x ^ y) ^ x = (x ^ x) ^ y = 0 ^ y

        这里用到了异或的两个特性：
            （1）两个相等的数的异或为 0，例如 x ^ x = 0
            （2）任何一个数与 0 异或，值不变。例如 x ^ 0 = x

    3、集合操作：

        集合操作和逻辑的概念紧密相连的，因此集合操作也可以通过位的逻辑操作来实现。

        假设我们有两个集合{1, 3, 8} 和 {4, 8}. 我们先把这两个集合转为两个 8 为
        二进制数，从右往左以 1 到 8 依次来编号。

        如果某个数字在集合中，相应的位置为 1， 否则为0，那么第一个集合就是
        10000101，第二个集合可以转换为 10001000，那么这两个二进制数按位与
        就是10000000，只有第 8 位是 1，代表这两个集合交为{8}。两个集合的二进制
        数按位或是 10001101，代表两个集合并为{1, 3, 4, 8}

        Elasticsearch（开源的搜索引擎来实现电商的平台搜索）的 Filter 查询的原理：
        它并没有考虑各种文档的相关性得分，它可以把文档匹配关键字的情况，转换成了
        一个 BitSet(想象成一个具大的位数组)。每一位对应着谋篇文档是否和给定的
        关键词匹配，如果匹配，这一位设置为 1，否则就设置为 0. 每个关键词都可以
        拥有一个 BitSet, 用于表示那些文档和关键词匹配。那么要查同时命中多个关键词
        的文档有那些，就对多个 BitSet 求交集。效率相当之高。


"""07: 如何让计算机学会“田忌赛马” """

    1、排列：
        
        从 n 个不同的元素中取出 m (m >= 1 and m <= n) 个不同的元素，按照一定的顺序排成一排，这个过程就叫排列。
        当 m = n 这种情况出现的时候，这就是全排列 （all permutation）
        如果选择出的这个 m 个元素可以有重复的，这样的排列就是为重复排列（permutation with Repetition）
        否则就是不重复排列（permutation without Repetition）
        
        排列的过程其实就是一个树状结构，从树的根结点到叶子结点，每种路径都是一个种排列。
        有多少个叶子结点就有多少中全排列。
     
        对于最终排序的数量，我们推广一下：
        
            (1) 对于 n 个元素的全排列，所有可能的排列数量就是 n(n - 1)*(n - 2)...*2*1也就是 n!。
            
            (2) 对于 n 个元素里取出的 m (m >= 0 and m <= n)个元素的不重复排列数量是
                n *(n - 1)*(n - 2)*...*(n - m + 1), 也就是 n!/(n - m)!。
                
    2、如何让计算机为田忌安排赛马:
    
    
    3、暴力破解密码如何使用排列思想:
    
        暴力破解法：
            列举出各种可能的密码，然后逐个地去尝试密码的正确性，如果某个尝试的密码
            和原先管理员设置的一样，那么密码就被破解了。
            
    4、小结：
    
        排列可以帮助我们生成很多种可能性，由于这种特性，排列最多的用途就是穷举法，也就是
        列出所有可能的情况，一个一个验证，然后看每种情况是否符合条件的解。
        
        排列可以穷举出随机变量取值的所有可能性，所以它在概率中有很大的作用，比如用于生成
        这个变量的概率分布。
        
        很多时候，很多很小的地方都会用到排列，但是因为它看起来不起眼，所以你可能没有注意到它，
        很多数学思想就是这样默默无闻。
    
        
"""08: 组合： 如何让计算机安排世界杯的赛程 """

    1、组合概念：
    
        组合可以说是排列的兄弟，两者类似但又有所不同，组合是不考虑每个元素出现的顺序的。
        
        从定义上来说，组合是指，从 n 个不同的元素中取出 m ( m >= 1 and m <= n) 个不同的元素的一个组合。
        
        对于所有 m 取值的组合称之全集合，我们可以叫作全组合（All Combination）
        
        n 个元素里取出 m 个的组合，可能性数量就是 n 个里取 m 个的排列数量，除以 m 个全排列的数量，
        也就是 （n! / (n - m)!） / m!。
        
        对于全组合而言，可能性为 2^n 种，当 n = 3 的时候，全组合包括了 8 中情况。
        
    2、如何让计算机来组合队伍：
    
        如何使用递归从 3 个元素中选取 2 个元素的组合。
        我们假设有 3 个队伍 t1, t2 和 t3, 那么如何使用代码实现呢？一种最简单粗暴的做法是:
        
        (1) 先实现排序的代码，输出所有的排列。例如{t1, t2},{t2, t1}。
        (2) 针对每种排列，对其中的规则按照一定的规则排序。那么上述两种排列经过排序后，就是{t1,t2},{t1,t2}。
        (3) 对排序后的排列，去掉重复的那些，上述两种排列最后只保留一个{t1, t2}。
        
        这样做效率比较低，显然，还有更好的做法，我们只需要在原有的排列代码中，稍作修改，每次传入嵌套函数的剩余元素
        不再是所有的未选择元素，而是出现在当前被选元素之后的那些。
        
    3、组合的应用：如何高效的处理词组：
    
        组合在计算机领域也有很多应用场景，比如大型比赛中的赛程自动安排，多维的数据分析以及自然语言的处理的优化等等。
        
        处理词组最常见的一种方法是 “多元文法”，其实就是把临近的几个单词合并起来，组合一个新的词组。
        设计多元文法是为了方便计算机处理，而不考虑组合后的词组是不是有正确的语法和语义。
        多词出现时，我们不考虑组内单词出现的顺序，而只关心组合，我们可以对元组内的单词进行某种标准化。
        即使原来的单词出现的顺序不同，经过这个标准化之后，都会变成唯一的顺序。
        
    4、小结：
    
        组合和排列有相似之处，都是从 n 个元素中取出若干个元素。不过，排列需要考虑了取出元素它们之间的顺序，
        而组合无需考虑这种顺序。
        
        具体到编程，组合和排序两者的实现非常类似，区别在于，组合并不考虑选出来是元素之间，是如何排序的。
        所以，在递归的时候，传入下一个嵌套调用函数的剩余元素，只需要包含当前被选元素之后的那些，避免重复组合。



"""09：动态规划（上）如何实现基于编辑距离的查询推荐"""
    
    1、动态规划（Dynamic Programming, 简称DP）:
    
       在递归那一节，我们说过，可以通过不断分解问题，将复杂的任务简单化为最基本的小问题，
       比如基于递归实现的归并排序、排列和组合等。不过有时候，我们并不用处理所有的可能的情况，
       我们需要在各种可能的局部解中，找出那些可能达到最优的局部解，而放弃其他的局部解。这个
       寻找最优解的过程其实就是动态规划。
       
       动态规划需要通过子问题的最优解，推导出最终问题的最优解，因此这种方法特别注重问题之间
       的转移关系。我们通过把这些子问题之间的转移称为状态转移，并把用于刻画这些状态转移的表达式
       称为状态转移方程。很显然，找到合适的状态转移方程，是动态规划的关键。
       
    2、编辑距离:
    
        搜索下拉提示和关键词纠错，这两个功能其实就是查询推荐。查询推荐的核心思想就是，对于
        用户的输入，查找相似的关键词并进行返回。而测量拉丁文的文本相似度，最常用的指标是编辑距离。
        
        由一个字符串转成另一个字符串所需的最少编辑操作次数，我们就叫作编辑距离。
        编辑操作有这三种：把一个字符替换成另一个字符；插入一个字符；删除一个字符。
        比如，我们想把 mouuse 转换成 mouse,有很多种方法可以实现但是，很显然，直接删除'u'是最简单的
        所以这两者的编辑距离就是 1.
        
    3、小结：
    
        （1）什么是动规划：
            通过不断分析问题，可以将复杂的任务简化为最基本的小问题，我们需要在各种可能的局部解中，
            找到可能达到最优的局部解，这个寻找最优解的过程就是动态规划。
            
        （2）动态规划的关键是什么：
            动态规划特别注重子问题之间的转移关系，我们把子问题之间的转移称为状态转移，并把用于刻画
            这些状态的表达式称为状态转移方程，找到合适的状态转移方程，是动态规划的关键。
            
            
"""10: 动态规划（下）：如何求得状态转移方程并进行编程实现"""
    
    1、状态转移方程和编程实现：
    
        和排列组合等穷举的方法相比，动态规划关注发现某种最优解。如果一个问题无需求出所有
        可能的解，而是要找到满足一定条件的最优解，那么你就可以思考一下，是否使用动态规划
        来降低求解的工作量。
        
    2、状态转移方程是什么：
    
        从上一个状态到下一个状态之间可能存在的一些变化，以及基于这些变化的最终决策结果。
        我们把这样的表达式称为状态转移方程。
        


"""11：树的深度优先搜索（上）：如何才能高效率的查字典"""     
        
    1、图论的一些基本概念：
    
        什么是有向树：有向树就是一种树，特殊的就是，它的边是有方向的，而树是没有简单回路的连通图。
        如果一个图里所有的边都是有向边，那么这个图就是有向图。如果一个图里所有的边都是无向边，那么
        这个图就是无向图，既含有有向边，又含无向边的图，称为混合图。
        
        在有向图中，以结点 v 为出发点的边的数量，我们叫作 v 的出度。而以结点 v 为终点的边的数量
        称为 v 的入度。
        
        通路：结点和边的交替序列的组成，所以，通路上的任意两个结点其实就是互为连通的，
        如果一个通路的起始点 v1 和 终止点 vn  相同，这种特殊的通路我们叫作回路。
        从起始点到终止点所经过的边的数量，就是通路的长度。
        
    2、树和有向树：
    
        树是一种特殊的图，它是没有简单回路的连通无向图。
        这里的简单回路，其实是指，除了第一个结点和最后一个结点相同外，其余结点不重复出现的回路。
        
        有向树要满足下面条件：
            （1）有且仅有一个结点的入度为 0，这个结点被称为根结点。
            （2）除根结点外的所有结点，入度都为 1，从根到任意结点有且仅有一条有向通路。
            
    3、前缀树的构建和查询：
    
        前缀树：在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，
               其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，
               而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，
               也就是这个节点对应的字符串，而根节点对应空字符串。
               一般情况下，不是所有的节点都有对应的值，
               只有叶子节点和部分内部节点所对应的键才有相关的值。 
               就是从树顶层的根结点一直遍历到最下层的叶子结点，最终逐步构成单词前缀的过程。
               对应的数据结构就是前缀树，或者叫做字典树。
                
        前缀树的构建和查询这两者在本质上其实是一致的。构建的时候，我们需要根据当前的前缀进行
        查询，然后才能找到合适的位置插入新的结点，而且，这两者都存在一个不断重复迭代的查找过程，
        我们把这种方式称为 深度优先搜索（Depth First Search）
        
        所谓树的深度优先搜索，其实就是从树种的某个结点出发，沿着河这个结点相连的边向前走，
        找到下一个结点，然后以这种方式不断地发现新的结点和边，一直搜索下去，直到访问了所有
        和出发点连通的点、或者满足某个条件后停止。
        
        如果到了某个点，发现和这个点直接相连的所有点都已经被访问过了，那么就退到在这个点的父节点
        继续查看是否有新的点可以访问；如果没有就继续回退，一直到出发点。
        
        由于单棵树中所有的结点都是连通的，所以通过深度优先的策略可以遍历树中的所有结点，
        因此也被称为深度优先遍历。
        
        
"""12: 树的深度优先搜索（下）：如何才能高效率地查字典"""        
    
    从数学思想到最终的编程实现，其实需要一个比较长的流程。我们首先需要把问题转化成数学中的模型，
    然后使用数据结构和算法来刻画数据模型，最终才能落实到编码。
    
    1、如何使用数据结构表达树：
    
        什么样的数据结构可以表达树：
            计算机中最基本的数据结构：数组和链表，数组适合快速地随机访问，而不适合稀疏的数列或者矩阵。
            相对数组，列表的优势是不必事先知道数据的数量，表示稀疏数列或者矩阵，可以更有效第利用存储空间。
            同事也有利于数据动态插入和删除。
            
            我们再看树的特点，树的结点及其之间的边和链表中的结点和链接在本质上一样的，因此我们可以模仿链表
            的结构，用编程中的指针或对象的引用来构建树。
            
            除此之外，还可以使用二维数组，用数组的行或列元素表示树中的结点，而行和列共同确定了两个结点之间是不是存在边。
            可是在树中，这种二维关系通过非常稀疏、非常动态，用二维数组效率低下。
    
    2、构建前缀树结点：
         
        基于上面考虑，我们设计一个 TreeNode 类，表示有向树的结点和边，这个类需要体现前缀树结点的最重要的两个属性。
            
            （1） 这个结点代表的字符，需用 lable 变量表示
            （2） 这个结点有哪些子结点，要用 sons 哈希映射表示。之所以用哈希，是为了便于查找某个子结点(或者说对应字符)是否存在。
    
        另外，我们还可以用变量 prefix 表示当前结点之前的前缀，用变量 explanation 表示某个单词的解释。
            
        public class TreeNode{
            
            public char lable;   //结点的名称，在前缀树里的单个字母
            //使用哈希映射存放子结点，哈希便于确认是否已经添加过某个字母对应的结点。
            public HashMap<Character, TreeNode> sons = null;
            //从根结点到当前结点这条通路上，全部字母所组成的前缀，例如 b->o->y,对于字母 o结点而言，前缀是b,对于字母y来说，前缀是bo
            public String prefix = null; 
            //词条的解释
            public String explanation = null;
            
            //初始化
            public TreeNode(char l, String pre, String exp){
                label = l;
                prefix = pre;
                explanation = exp;
                sons = new HashMap<>();
            }
        }
       
        为什么结点的定义没有边呢？
            实际上，这里的有向边表达的是父子结点之间的关系，这种关系用 sons 变量来存储父结点。
            
        
        需要注意的是，我们需要动态地构建这棵树，每当接收一个新单词时，代码都有扫描这个单词的每一个字母，
        并使用当前的前缀树进行匹配，如果匹配到某个结点，发现相应的字母结点并不存在，那么就建立一个新的树结点。
        看下面的代码，str 表示还未处理的字符串，parent 表示父结点。
        
        
        // 处理当前字符串的第一个字母
        char c = str.toChArray()[0]
        TreeNode found = null;
        
        // 如果字母结点已经存在于当前父结点之下，找到它，否则就新生成一个。
        if (parent.sons.containsKey(c)){
            found = parent.sons,.get(c);
        }else{
            TreeNode son = new TreeNode(c,pre,"");
            parent.sons.put(c,son);
            found = son;
        }
        
        
        
          
        
                
            
            
    
        
        
                    
        
        
    
            
        
        
        
        
    








    
    
       
        









                
            
      
 
  
    
        
    
    

       
        
        
        
        
    
    
    
        
        
              

