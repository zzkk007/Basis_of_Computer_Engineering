"-----------------------------------------------------------------"

       本篇笔记是学习极客学院黄申老师《程序员的数学基础课》学习笔记
        
"-----------------------------------------------------------------"


"""01 二进制：不了解计算机的源头， 你学什么编程"""

    1、什么是二进制计数法？

        数位，指一个数中每一个数字所占的位置。
        二进制就是使用2作为基数，类比过来，二进制的数位就是 2^n 的形式。

    2、计算机为什么使用二进制？

        计算机使用二进制和现代计算机系统的硬件实现有关，组成计算机系统
        的逻辑电路通常只有两种状态，即开关的接通和断开。
        断开状态我们用 "0" 表示，接通状态我们用 "1" 表示。
        在具体的实现中，二进制数据表达具有抗干扰能力强，可靠性高的优点。
        如果用十进制设计具有10中状态的电路，情况会非常复杂，判断状态出错
        的几率大大提高。
        
        另外，二进制也非常适合逻辑运算。逻辑运算中的真和假对应二进制中的 "1" 和 "0"。
        逻辑运算中的加法("或"运算)、乘法("与"运算)以及否定（"非"运算）都可以通过
        "0"或"1" 的加法、减法和乘法来实现。
        
        二进制的四则运算:
        
            加法运算： 0 + 0 = 0， 1 + 0 = 1， 0 + 1 = 1， 1 + 1 = 10，逢二进 1 
            
            减法运算： 1 - 1 = 0， 1 - 0 = 1， 0 - 0 = 0， 0 - 1 = 1，向高位借1当2
            
            乘法运算： 0 * 0 = 0， 0 * 1 = 0， 1 * 0 = 0， 1 * 1 = 1，同时为1 结果才是1
            
            除法运算： 二进制数只有两个数，因此它的商是1 或 0 。
        
        示例：
                   
            1101 （13） + 1010 （10） = 10111 （23）
            
            1101 （13） - 1010 （10） = 011 （3）
            
            1101 （13） *  1010 （10）= 10000010 （130）
                
                        1  1  0  1
                        1  0  1  0
                    ----------------
                        0  0  0  0
                     1  1  0  1 
                  0  0  0  0
               1  1  0  1      
            -------------------------
            1  0  0  0  0  0  1  0        
        
            1010 （10） / 10 = 0101 (5)
                
              
                         
    3、二进制的位操作:
        
        计算语言中针对二进制的为操作，这里的位操作也叫位运算，就是直接对内存中
        的二进制进行操作。常见左移位和右移位的移位操作，以及"或" 与 "异或" 的逻辑操作。
        
        二进制数：110101 向左移一位，就是在末尾添加一位 0，因此 110101 就变成了 1101010。
        这里没有考虑数字溢出的情况，所谓的数字溢出，就是二进制数的位数超过了系统所指定的位数。
        目前主流的系统都支持至少32位的整型数字，110101不会溢出。如果进行左移操作的二进制数
        已经超过了 32 位，左移后数字就会溢出，需要将溢出的位数去除。
        
        二进制左移一位，其实就是将数字翻倍
        二进制右移一位，就是将数字除以 2 并求整数商的操作。
        
        1101 （13, 右移一位） ----> 110 （6, 13 // 2 = 6）
        
        因为有符号为的存在，在 python 中，右移可以分为
        逻辑右移： 右移一位，左边补 0, 使用符号 ">>>" 表示
        算术右移： 右移一位，保持符号位不变，右移一位并补符号位 1,补的 1 仍然是符号位之后。
        
        在 C 或 C++ 中，逻辑右移和算术右移共有一个 >> 符号，通过判断运算数类型，采用不同右移
        
        
        与 ： 同 1 为 1, 不同为 0 
        或 ： 有 1 为 1, 同 0 为 0 
        异或：不同为 1 , 相同为 0
        
        "异或"操作本质其实就是，所有数值和自身进行按位"异或"操作之后都为 0.
        而且要通过"异或"操作得当 0 ，也必须通过两个相同的数值进行按位"异或"。
        这表明了两个数值按位"异或"结果为 0 ，是这两个数值相等的必要充分条件，
        可以最为判断两个变量是否相等的条件。
        
    4、作业题，用位移和位运算实现 10 进制转换为 2 进制
    
        def binary2(num):
        if num == 0:
            return '0'
        else:
    
            return binary2(num >> 1) + str(num & 1)
    
    
        if __name__ == '__main__':
        
            num  = int(input("please a decimal:"))
        
            print((binary2(num)))    
    
    
      
"""02 余数：原来取余操作本身就是个哈希函数"""
    
    1、同余定理：
    
        余数总是在一个固定的范围内，比如你拿任何一个整数除以 7 ，那么得到的余数肯定在
        0 ~ 6 之间的某一个数。所以我们知道 1900 年的 1 月 1 日是星期几，那么我们就
        可以推算出这一天之后的第 1 万天， 10 万天是星期几。
    
        整数是没有边界的，可以是正无穷，也可能是负无穷，但是余数却可以通过某种关系
        让整数处于一个确定的范围内。
        
        简单的来说，就是两个整数 a 和 b , 如果他们除以正整数 m 得到的余数相等，
        我们就可以说 a 和 b 对于模 m 同余。
    
        我们经常提到的奇数和偶数，其实也就是同余定理的一个应用。当然这个应用模就是 2 ，
        除以 2 余数为 0 的是偶数， 余数为 1 的是奇数。
    
        同余定理的作用：
    
            同余定理其实就是用来分类的。
        
            我们有无穷多个整数，那么怎么能够全面，多维度的管理这些整数，
            同余定理就提供了一种思路。
                  
    2、哈希函数（Hash） 也称为散列函数:
        
        简单的来说，它就是将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出。
        
        举个例子：假如你想要快速读写 100 万条数据记录， 要达到高速的存取，最理想的
        情况当然是开辟一个连续的内存空间存放这些数据，这样就会减少寻址的时间。但是
        由于条件的限制，我们并没有能够容纳 100 万条记录的连续地址空间，这个时候该
        怎么办？
        
        我们可以考察一下，看看系统中是够可以提供若个较小的连续空间，而每个空间又能
        存放一定数量的记录。比如我们找到了 100 个较小的连续空间，也就是说，这些
        空间彼此之间是被分隔开来的，但是内部是连续的，并足够容纳 1 万条连续存放。
        那么我们可以使用余数和同余定理来设计一个散列函数，并实现哈希表的结构。
        
        一种方法：
        
                f(x) = x mod size
                
                x : 等待被转换的值
                mod : 取余操作
                size : 表示有限存储空间的大小
                
                通过余数，你就能将任何数值，转换为有限范围内的一个数值，然后
                根据这个新的数值，来确定将数据存放在何处。
        
            具体来说，我们可以通过记录标号模 100 的余数，指定某条记录存放在那个空间，
            这个时候，我们的公式变成了这样：
        
                f(x) = x mod 100
                
            假设有两条记录，他们记录标号分别是 1 和 101 。我们把这些模 100 之后
            的余数都是 1 的，存放到第 1 个可用的空间里。依次类推，将余数为 2 的
            2 、 102、202 存放在 2 个可用的空间里，将 100 、 200、300 等存放
            到第 100 个可用空间里。
            
            这样，我们就可以根据求余的快速数字变化，对数据进行分组，并且把他们存放
            到不同的地址空间里。而求余操作本身非常简单，因此几乎不会增加寻找时间。
            
            除此之外，为了增加数据散列的随机程度，我们还可以在公式中加入一个较大
            的随机数 MAX, 于是， 上面的公式就可以写成下面这样:
            
                f(x) = (x + MAX) mod size
                
            我们假设随机数 MAX 是 590199，那么我们针对标号为 1 的记录重新进行计算
            最后的计算结果是 0 ，而针对标号是 101 的记录，如果随机数 MAX 取 627901
            对应的结果应该是 2 。 这样之前被分配到空间 1 的两条记录，在新的公式下
            被分配到不同的可用空间中。
            这样更适合需要将数据重新洗牌的应用场景，比如加密算法、 MapReduce 中的数据分析
            记录的高速查询和定位等等。
            
            让我们以加密算法为例， 在这里引入 MAX 随机数就可以增强加密算法的保密程度，
            比如说，我们要加密一组三位数，那我们设定一个这样的加密规则：
            
                1、先对每个三位数的个、十和百位数，都加上一个较大的随机数。
                
                2、然后将每位上的数都除以 7 ，用所得的余数代替原有的个、十、百位数。
                
                3、最后将第一位和第三位交换
                
             假如，我们加密 625 ，根据刚才的规则，我们来试试，假设随机数选择 590127，
             那么。百，十，个 分别加上这个随机数，就变成了 590133,590129,590132。
             然后分别除以 7 求余后等到 5， 1， 4. 最终我们的加密后得到数据是 415。
             
             
          
            
                
                
  
    
        
    
    

       
        
        
        
        
    
    
    
        
        
              

