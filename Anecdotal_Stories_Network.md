"-------------------------------------------------"

            极客时间 刘超 《趣谈网络协议》
    
"-------------------------------------------------"

"""第一讲| 为什么要学习网络协议"""

    1、协议三要素：
        
        语法：就是这段内容要符合一定的规则和格式。
                
        语义：就是这段内容要代表某种意义。
        
        顺序：就是先干啥，后干啥。
        
    2、关于域名系统 DNS (Domain Name System)
    
        从域名中解析 ip 地址
        
        DNS 主要由 3 部分组成：
            
            a. 域名解析器(resolver)
            b. 域名空间(domain name space)
            c. 名称服务器(name server)
            
        DNS 服务器获取域名空间的部分信息的方法：
        
            a. 由管理员编辑一个原始区域文件;
            b. 从其他名称服务器哪里复制区域文件;    
            c. 通过向其他DNS服务器查询来获取具有一定时效的缓存信息。
        
        名称服务器的3中主要类型：
        
            a. 主名称服务器：拥有一个区域文件的原始版本的服务器。
            
            b. 次名称服务器：从其他主名称服务器那里复制一个区域文件。是一个只读版本。
                次名称服务器通过区域传输跟随主名称服务器上的区域文件进行变化。
            
            c. 惟高速缓存名称服务器：没有区域文件。它的职责是帮助名称解析器完成名称解析，
                并缓存解析结果，便于以后使用。        
    
    3、域名解析:
    
        TCP/IP 的域名系统是一个有效的、可靠的、通用的、分布式的 名称-地址 映射系统。
        
        域名解析有两种方式：正向解析和反向解析。
            正向解析：根据域名查找对应的IP地址或其他相关信息。
            反向解析：根据主机的IP地址查询其相关信息。    
        
    4、查询域名 && 域名解析：
    
        DNS 查找：
            浏览器查找域名的 IP 地址
            浏览器 DNS 查找顺序一般是这样的：
            浏览器缓存--> 系统缓存 --> 路由器缓存 --> ISP DNS 缓存 --> 递归搜索。
        
        详细过程如下：
                
            a. 浏览器缓存，浏览器会缓存DNS记录一段时间。
                
                操作系统没有设定浏览器存储DNS记录的时间长短，
                不同的浏览器会存储各自的一个固定时间，时长为2~30分钟不等。         
            
            b. 系统缓存。
                
                如果浏览器缓存里面没有找到需要的记录，浏览器会做一个操作系统调用
                (windows 里面是 gethostname),这样就可以获得系统缓存里面的记录。
                
            c. 路由器缓存：
            
                接下来，如果还是没有找到需要的缓存，将前面的查询请求发个路由器，
                它一般会有自己的DNS缓存。
                
            d. 如果还没有，那就去检查 ISP：
                
                每个ISP(网络服务提供商)，都会有自己的本地域名服务器，它会在 URL 第一次
                访问时缓存该域名的指向。下次再访问时，他会从缓存中把这个URL 曾经指向的 IP 调出来。
                
            e. 递归搜索：
            
                如果ISP本地缓存中还没有
                你的ISP的DNS服务器会从根域名开始进行递归查询。        
            
                递归查询：主机向本地域名服务器的查询一般都是采用递归查询。                
                迭代查询：本地域名服务器向根域名服务器的查询通常是采用迭代查询。
                
                举个栗子：假设的主机想知道另一个主机（域名为 my.xxsilence.net)的IP地址。
                具体步骤如下：
                
                    ① 主机先向其本地域名服务器进行递归查询，如果缓存中没有，继续下一步。
                    ② 本地域名服务器采用迭代查询，先向一个根域名服务器查询。           
                    ③ 根域名服务器告诉本地域名服务器，下一次查询的顶级域名服务器 dns.net。                   
                    ④ 本地域名服务器向顶级域名服务器 dns.net。                  
                    ⑤ 顶级域名服务器 dns.net，下一次应查询的权限域名服务器dns.xxsilence.net的IP地址。                    
                    ⑥ 本地域名服务器向权限域名服务器dns.xxsilence.net进行查询。                 
                    ⑦ 权限域名服务器dns.xxsilence.net告诉本地域名服务器，所查询的主机的IP地址。                
                    ⑧ 本地域名服务器最后把查询结果告诉主机。

    5、互联网在世界运行中，都使用了那些协议：
    
        你在浏览器中里面输入 Https://www.kaola.com， 这是个 URL。
        浏览器只知道名字是“www.kaola.com”,但是不知道具体的地点，所以不知道该如何访问。
        于是，它打开地址簿去查找。可以使用一般地址薄协议DNS去查找，还可以使用另一种更
        精准的地址薄去查找协议HTTPDNS。
        
        无论使用哪种方法查找，最终都会得到这个地址：106.114.138.24 这是个地址，是互联网
        世界的“门牌号”。
        
        知道了目标地址，浏览器就开始打包它的请求。对于普通的浏览器请求，往往会使用 HTTP 协议；
        但是对于购物的请求，往往需要进行加密传输，因而会使用 HTTPS 协议。无论是什么协议，里面
        都会写明“你要买什么和买了多少”。
        
                ------------------------------------
                HTTP头:  POST,URL,HTTP 1.1, 
                         正文格式：json, 正文长度: 1234
                -------------------------------------
                         我要买什么，买多少
                -------------------------------------         
                              
        DNS、HTTP、HTTPS 所在的层我们成为应用层。经过应用层封装后，
        浏览器会将应用层的包交给下一层取完成，通过 socket 编程来实现。
        
        下一层是 传输层。传输层有两种协议，一种是无连接的协议 UDP，一种是面向连接的协议 TCP。
        所谓的面向连接就是，TCP 会保证这包能够到达目的地。如果不能到达，就会重新发送，直到到达。
        
        TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商服务器监听的端口。操作系统
        往往通过端口来判断，它得到的包应该给那个进程。
                
                -----------------------------------
                TCP头：   浏览器端口：12345
                          电商应用端口：443
                ------------------------------------
                HTTP头:  POST,URL,HTTP 1.1, 
                         正文格式：json, 正文长度: 1234
                -------------------------------------
                         我要买什么，买多少
                -------------------------------------
                
        传输层封装完毕后，浏览器会将包交给操作系统的网络层。网络层的协议是 IP 协议。
        在 IP 协议里会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即
        电商网站所在服务器的 IP 地址。
        
                ---------------------------------------
                IP 头：   客户端电脑IP: 192.168.1.101
                          电商服务器IP: 106.114.138.24
                ---------------------------------------
                TCP头：   浏览器端口：12345
                          电商应用端口：443
                ---------------------------------------
                HTTP头:  POST,URL,HTTP 1.1, 
                         正文格式：json, 正文长度: 1234
                ---------------------------------------
                         我要买什么，买多少
                ---------------------------------------
                
        操作系统既然知道了目标 IP 地址，就开始想如何根据这个门牌号找到目标机器。
        操作系统往往会判断，这个目标 IP 地址是本地人，还是外地人。从门牌号就可以开出来。
        但是，显然电商网站不是本地，而是在遥远的远方。
        
        操作系统知道要离开本地去远方，虽然不知道远方在何处，但是可以这样类比一下：
        如果去国外要去海关，去外地就要去网关。而操作系统启动的时候，就会被 DHCP 协议
        配置 IP 地址，以及默认的网关的 IP 地址 192.168.1.1
        
        操作系统如何将 IP 地址发给网关呢？在本地通信基本靠吼，于是操作系统会大吼一声，
        谁是 192.168.1.1啊 ?，网关就会答应它，我就是，我的本地地址在村东头。
        这个本地地址就是 MAC 地址，而大吼的那一声是 ARP 协议。
        
                
                MAC 头：  客户端电脑MAC: 192.168.1.101 的MAC
                          网关的MAC: 102.168.1.1 的MAC
                ---------------------------------------
                IP 头：   客户端电脑IP: 192.168.1.101
                          电商服务器IP: 106.114.138.24
                ---------------------------------------
                TCP头：   浏览器端口：12345
                          电商应用端口：443
                ---------------------------------------
                HTTP头:  POST,URL,HTTP 1.1, 
                         正文格式：json, 正文长度: 1234
                ---------------------------------------
                         我要买什么，买多少
                ---------------------------------------
        
        于是操作系统将 IP 包交个了下一层，也就是 MAC 层。网卡
        再将包发出去，由于这个包里面是有 MAC 地址的，因而它能够到达网关。
        
        网关收到包之后，会根据自己的知识，判断下一步应该怎么走，网关往往
        是一个路由器，到某个 IP 地址应该怎么走，这个叫做路由表。
        
        路由器有点像玄奘西行路上的一个个国家的一个个城关。每个城关都连着两个国家，
        每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址 MAC 进行通信。
        
        一旦跨过网关，就需要拿出 IP 头来，里面写着贫僧来自东土大唐（就是源IP地址），
        欲往西天求经(目的IP地址)。路过宝地，借宿一晚，请问接下来该怎么走？
        
        城关往往直到这些“知识的”，因为城关和临近的城关也会经常沟通，到哪里应该怎么走，
        这种沟通的协议就是“路由协议”，常用的有 OSPF 和 BGP。
        
        城关和城关之间是一个国家，当网络包知道了下一步去哪个城关，还是要使用国家内部的 MAC地址。
        通过下一个城关的 MAC 地址，找到下一个城关，然后再问下一步的路怎么走，一直走到最后一个城关。
        
        最后一个城关知道这个网络包要去地方，于是，对着这个国家吼一声，谁是目标 IP 啊？目标服务器
        就会回复一个 MAC 地址，网络包过关后，通过这个 MAC 地址就能找到目标服务器。
        
        目标服务器发现 MAC 地址对上了，取下 MAC 头来，发送给操作系统的网络层。发现 IP 也
        对上了，就取下 IP 头，IP 头里会写上一层封装的 TCP 协议，然后将其交给传输层，即 TCP 层。
        
        在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单
        的结果，仅仅是 TCP 层的一个说明，即收到的回复。这个回复会沿着刚才的方向走回去，报个平安。
        
        因为一旦出了国门，西行路上千难万险，如果在这个过程中，网络包走丢了，因而到了要报个平安，
        如果过一段时间还没有到，发送端的 TCP 层会重新发生这个包，还是上面的过程，直到有一天
        收到平安到达的回复。这个重试绝非你的浏览器重新将下单这个动作重新请求一次。对于浏览器
        来讲，就发送一次下单请求，TCP层不断自己闷头重试。除非 TCP 这一层出了问题，例如连接
        断了，才轮到浏览器的应用层重新发送下单请求。
        
        当网络平安到达了 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站
        的进程正在监听这个端口号，假设一个 Tomcat, 将这个包发给电商网站。
        
        电商网站的进程得到 HTTP 请求内容，知道了要买的内容，往往一个电商网站最初接待请求的这个
        Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。
        例如，这个接待员要告诉专门管理订单的进程，登录买某个商品，买多少，要告诉管理库存的进程，
        库存要减少多少，要告诉支付的进程等等。
        
        如何告诉相关进程呢？往往通过 RPC 调用，即远程过程调用的方式来实现。
        远程过程调用就是当告诉管理订单进程的时候，接待员不用关心中间网络互连问题，
        会由 RPC 框架统一处理。RPC 框架有很多种，有基于 HTTP 协议放在 HTTP 的报文里面的，
        有的直接封装在 TCP 报文里面的。
        
        当接待员发现相应的部分都处理完毕，就回复一个 HTTPS 的包，告知下单成功。
        这个 HTTPS 的包，告知下单成功。这个 HTTPS 的包，就像来的时候一样，经过
        千难万险到达你的个人电脑，最终进入浏览器，显示支付成功。
        
    6、小结：
    
        一个简简单单的过程，中间牵扯到这么多协议。而管理一大片机器，更是一件特别
        有技术含量的事情。
        
        应用层：DHCP、DNS、HTTP、HTTPS、RTMP、P2P、GTP、RPC等等
        
        传输层：UDP、TCP
        
        网络层：IP、ICMP、OSPF、BGF、GRE、IPSec
        
        链路层：ARP、VLAN、STP
        
        物理层：网络跳线
        
    7、问题：
    
        当网络到达一个城关的时候，可以通过路由表得到下一个城关的 IP 地址，
        直接同过 IP 地址找就可以了，为什么还要通过本地的 MAC 地址呢？
        
        ip 是网络层使用的，MAC 是链路层使用的，ip包最终还是要通过物理链路和MAC地址进行交互的。 
            
"""第二讲| 网络分层的真实含义是什么"""

    1、网络为什么要分层？
    
        那么 TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢？
        当然是 TCP 发送每一个消息，都会带着 IP层 和 MAC 层。
        因为，TCP 每发送一个消息， IP 层和 MAC 层的所有机制
        都要运行一遍。
        
        记住一点：只要是在网络上跑的包，都是完整的。可以有下层没有上层，
        绝对不可能有上层没下层。
        所以，对于TCP 协议来说，三层握手也好，重试也好，只要想发出包，
        就要有 IP层和 MAC 层，不然是发不出去的。
        
    2、二层设备和三层设备：
    
        所谓的二层设备和三层设备，都是这些设备上跑的程序不同而已。
        二层设备收进去的是整个网络包，这里面 HTTP、TCP、IP、MAC都有。
        什么叫二层设备呀，就是只把MAC头摘下来，看看到底是丢弃、转发，还是自己留着。
        那什么叫三层设备呢？就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看是
        丢弃、转发、还是自己留着。
    
    3、小结：
    
        理解网络协议工作模式有两个小窍门：
        
            （1） 始终想象自己是一个处理网络包的程序：
                  如何拿到网络包，如何根据规则进行处理，如何发出去。
            
            （2） 始终牢记一个原则：
                  只要是在网络上跑的包，都是完整的。可以有下层没有上层，
                  绝对不可能有上层没有下层。

"""第三讲| ifconfig: 熟悉又陌生的命令行"""
    
    Windows 上是：ipconfig,
    Linux 上是 ifconfig，还有一个是 ip addr。
    
    
    1、无类型域间选路（CIDR）:
    
       为了解决 C 类地址能包含的最大主机数实在太少（254个），而B类地址能包含
       的最大主机数量太多（65534），一般的企业基本达不到规模，闲着地址就是浪费。
       
       于是又一个折中的方式叫作无类型域间选路，简称 CIDR。
       这种方式打破了原来设计的几类地址的做法，将32位的 ip 地址一分为二，前面是网络号，
       后面是主机号。从哪里分呢？如果你注意观察的话可以看到，10.100.122.2/24，这个ip
       的 ip 地址中有一个斜杠，斜杠后面有个数字24，这种地址表示形式，就是 CIDR。后面
       24 的意思是，32中，前 24 位是网络号，后 8 位是主机号。
       
       伴随着 CIDR 存在的，一个是广播地址，10.100.122.255。如果发生这个地址，所有
       10.100.122 网络里面的机器都可以收到，另一个是子网掩码，255.255.255.0
       
       将子网掩码和IP地址进行 AND 计算，得到就是 10.100.122.0,这就是网络号。
       将子网掩码和 IP 地址按位计算 AND，就可以得到网络号。
       
    2、公有 IP 和私有 IP：
    
        公有 IP 地址有组织统一分配，需要去买，私有IP地址可重复。
        
    3、MAC 地址：
    
        MAC 地址是一个网卡的物理地址，用十六进制，6 个 byte表示。
        MAC 地址是一个很容易让人“误解”的地址，因为 MAC 地址号称全局唯一，不会有两个网卡
        有相同的 MAC 地址，而网卡自生产出来，就带着这个地址。很多人想到这里就会想，既然
        这样，整个互联网通信，全部用 MAC 地址好了，只要知道对方的MAC 地址，就可以把信息传过去。
        
        这样当然不行，一个网络包要从一个地方传到另外一个地方，除了要有确定的地址，还需要有定位功能。
        而门牌号码属性 IP 地址，才有远程定位功能的。
        
        例如，你去杭州市网商路599号B楼6层找刘超，你在路上问路，可能不知道B楼在哪里，但是可以指给你
        网商路怎么去，如果你去问一个人，你知道这个身份证号的人在哪里吗？可想而知，没有人知道。
        
        MAC 地址更像是身份证，是一个唯一标识。他的唯一性设计是为了组网的时候，不同的网卡放在一个网络
        里面的时候，可以不用担心冲突。从硬件的角度，保证不同的网卡有不同的标识。
        
        MAC 地址有一定的定位功能，不过范围非常有限，你可以根据 IP 地址，找到州市网商路599号B楼6层，
        但是依然找不到刘超，可以大喊一声身份证xxxx的是谁。
        
        所以，MAC 地址的通讯范围比较小，局限在一个子网里面。例如从 192.168.0.2/24 访问 192.168.0.3/24
        是可以使用 MAC 地址的。一旦跨过子网，即从192.168.0.2/24到 192.168.1.2/24,
        MAC 地址就不行了，需要IP地址起作用。

    4、小结：
    
        IP 地址，有定位功能；MAC 是身份证，无定位功能。
        CIDR 是可以判断是不是本地人。
        IP 分为公有IP 和私有IP。
        
      
"""第四讲| DHCP 与 PXE: IP是怎么来的，又是怎么没的"""



"""第10将| UDP 协议:因性善而简单，难免碰到“城会玩”"""
    
    1、TCP 和 UDP 有哪些区别？
        
        TCP 是面向连接，UDP 是面向无连接的。
        所谓的面向连接，是为了在客户端和服务器端维持连接，而建立一定的数据结构
        来维持双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。
        
        UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。
        
        TCP 是一个有状态的服务，UDP是一个无状态的服务。
        
    2、UDP 包头市什么样的？
    
        -------------------------------------
        源端口号（16位）       目标端口号(16位)
        -------------------------------------
        UDP长度（16位）        UDP校验和(16位)
        ------------------------------------
                       数据
        ------------------------------------
        
    3、UDP 的三大使用场景：
    
        a. 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。
        b. 不需要一对一沟通，建立连接，而是可以广播的应用。
        c. 需要处理速度快，时延低，可以容忍少数丢包。
        
      
"""第11讲| TCP协议(上): 因性恶而复杂，先恶后善反轻松"""
    
    TCP 协议要从算法层面来保证可靠性。 
    
    1、TCP 包头格式：
    
        --------------------------------------------------------------
           源端口(16位)                              目的端口(16位)
        --------------------------------------------------------------
                                序号(32位)
        --------------------------------------------------------------
                                确认序号(32位)
        --------------------------------------------------------------
        首部长度(4位)| 保留(6位)|URG|ACK|PSH|RST|SYN|FIN| 窗口大小(16位)                
        --------------------------------------------------------------
            校验和(16位)                                紧急指针(16位)
        --------------------------------------------------------------
                                选项
        --------------------------------------------------------------
                                 数据
        --------------------------------------------------------------
        
        SYN: 发起一个连接
        ACK: 回复
        RST: 重新连接
        FIN: 结束连接    
        
        TCP 协议，重点关注以下几个问题：
        
            顺序问题，稳重不乱
            丢包问题，承诺靠谱
            连接维护，有始有终
            流量控制，把握分寸
            拥塞控制，知进知退
            
    2、TCP 的三次握手：
    
        TCP 的连接建立，我们常常称为三次握手：
        
        A: 您好，我是 A。
        B: 您好，我是 B。
        A: 您好 B。
        我们也常称为“请求--> 应答 --> 应答之应答” 的三次回合。
        
        三次握手除了双方建立连接外，主要还是为了沟通一件事，就是 TCP 包的序号的问题。
        每个连接都有不同的序号。
        
        一开始，客户端和服务器都处于 CLOSED 状态。
        先是服务器主动监听某个端口，处于 LISTEN 状态，
        然后客户端主动发起 SYN,之后处于 SYN-SENT 状态。
        服务器端收到发起的连接，返回SYN,并且 ACK 客户端的SYN,之后处于 SYN-RCVD 状态。
        客户端收到服务器端发生的SYN和ACK 之后，发生 ACK的ACK,之后状态处于 ESTABLISHED 状态，
        因为它一发一收成功了。服务器端收到ACK的ACK之后，处于 ESTABLISHED 状态，因为它也一发一收成功了。
    
    3、TCP 四次挥手：
    
        A: B 啊，我不想玩了。
        B: 哦，你不想玩了啊，我知道了
        
            这个时候，只是 A 不想玩了，也即 A 不会再发生数据，但是 B 不能在 ACK 的时候直接关闭
            很可能是 A 是发完了最好的数据不准备玩了，但 B 还没有做完自己的事，还是可以发生数据的，
            称为半关闭状态。
            这个时候 A 可以选择不再接收数据了，也可以选择最后再接收一段数据，等待 B 也主动关闭。
            
        B: A 啊， 好吧，我也不玩了，拜拜。
        A: 好的，拜拜。
        
        这样整个连接就关闭了。       
        
          
"""第12将| TCP协议(下):西行必定多妖孽，恒信智慧消磨难"""

 
"""第13将| 套接字 Socket: Talk is cheap, show me you code"""

    Socket 编程进行的是端到端的通信，往往意识不到中间经过多少局域网、多少路由器
    因而能够设置的参数，也只是端到端协议之上网络层和传输层的。
    
    在网络层，Socket 函数需要制定到底是 IPV4 还是 IPV6,分别对应设置 AF_INET 和 AF_INET6。
    还有指定是 TCP 还是 UDP,TCP 协议是基于数据流的设置为 SOCKET_STREAM，
    而UDP 是基于数据报的，因而设置为 SOCK_DGRAM。
    
    1、基于 TCP 协议的 Socket 程序函数调用过程：
    
        TCP 的服务器先监听一个端口，先调用 bind 函数，给这个 Socket 赋予一个IP 和 端口。
        你写的一个应用程序，当网络包来的时候，内核要通过 TCP 头里面的端口，来找到这个
        应用程序，把包给你。为什么要有 IP, 因为，有时一台机器有多个网卡，也就有多个ip地址。
        你可以监听一个网卡，也可以监听所有网卡，知道网卡收到包的时候，才给你。
        
        当服务端有了 IP 和 端口号，就可以调用 listen 函数进行监听，在 TCP 状态图里，
        有个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就
        可以发起连接了。
       
        在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这个时候连接
        三次握手完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候
        三次握手还没有完成，处于 syn-rcvd 的状态。
        
        接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。
        
        在服务器端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接
        ip 和端口，然后开始发起三次握手，内核会给客户端分配一个临时的端口。一旦握手成功，
        服务端的 accept 就会返回另一个 Socket.
        
        监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫做监听 Socket,一个叫做已连接 Socket。
        
        连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。
        
        下面图是基于 TCP 协议的 Socket 程序函数调用过程：
        
            客户端                           服务器
            
            Socket()                       Socket()
                                             bind()
                                             listen()
            connect()                        accept()
            write()                          read()
            read()                           write()
            close()                          close()
            
        TCP 的 Socket 就是一个文件流，是非常准确的，因为，Socket 在 Linux 中就是以文件的形式存在的。
        除此之外，还存在文件描述符中，写入和读出，也是通过文件描述符。
        
    2、基于 UDP 协议的 Socket 程序函数调用过程：
    
        客户端                            服务器
        socket()                         socket()
        bind()                           bind()
        sendto()                         recvfrom()
        recvfrom()                       sendto()
        
    3、服务器如何接更多的项目：
    
        我们先计算一下理论值，也就是做到连接数，系统会用一个四元组来标识一个 TCP 连接。
        {本机 ip, 本机 端口, 对端 ip, 对端端口}
        
        服务端通过固定在某个本地端口上监听，等待客户端的请求。因此，服务器端 TCP 连接
        四元组中只要客户端ip 和 端口是可变的，因此 最大TCP 连接数 = 客户端IP X 客户端端口数。
        
        对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数位 2 的 16 次方，
        也就是数服务器端最大 TCP 连接数，约为 2 的 48 次方。
        
        当然，服务端最大并发 TCP 连接数远不能达到理论上限，首先是文件描述符限制。
        Socket 都是文件，首先要通过 ulimit 配置文件描述符的数目；另一个限制是内存，
        按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。
        
        想要连接更多项目，就需要降低每个项目消耗的资源数目：
        
        方式一：多进程方式：
        
            这就相当于你是一个代理，在那里监听来的请求。一旦建立了一个连接，
            就会有一个连接 Socket,这个时候你可以创建一个子进程，然后将基于
            已经连接 Socket 的交互给这个新的子进程来做。
            
            在 Linux 下，创建子进程使用 fork 函数，通过名字可以看出，这是在
            父进程的基础上完全拷贝一个子进程，在 Linux 内核中，会复制文件描述符的列表，
            也会复制内存空间，还会复制一条记录当前执行到了那一行程序的进程。
            显然，复制的时候在调用 fork, 复制完毕之后，父进程和子进程都会记录当前刚刚执行完fork。
            这两个进程刚复制完的时候，几乎一摸一样，只是根据 fork 的返回值来区分到底是父进程
            还是子进程。如果返回时 0 是子进程，如果返回值是其他整数，则是父进程。
            
            在Linux中主要提供了fork、vfork、clone三个进程创建方法。
                
                a. fork出来的子进程是父进程的一个拷贝,即，子进程从父进程得到了数据段和堆栈段的拷贝，
                    这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；
                    而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样
                    为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。
                
                b. fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用
                   fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；
                   而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，
                   父子进程的执行次序才不再有限制；
                   clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，
                   若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。
                                                        
        方式二：多线程方式：
        
            在 Linux 下，通过 pthread_create 创建一个线程，也是调用do_fork。不同的是，虽然
            先的线程在 task 列表会创建一项，但是很多资源，例如文件描述符列表，进程空间，还是共享的，
            只不过多了一个引用而已。
            
        方式三： I/O 多路复用，一个线程维护多个 SOCKET。
        
            基于进程和线程的模型，还是有问题的，一台机器无法创建更多的进程和线程。有个 C10k,
            它的意思是 1 万个连接，要创建 1 万个进程或线程，那么操作系统无法承受。
            
            由于 Socket 是文件描述符，因而某个线程盯着所有 SOCKET,都放在一个文件描述符集合fd_set中，
            这就相当于一个项目进度墙，然后调用 select 函数来监听文件描述符集合是否有变化。
            一旦有变化，就依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的
            位都设为 1，表示 socket 可读或者可写，从而可以进行读写操作，然后再调用 select
            接着盯着下一轮变化。
            
        方式四：IO 多路复用，从“派人盯着”到“有时通知”：
        
            上面的select 函数还是有问题的，因为每次 Socket 所在的文件描述符发生变化的时候，
            都需要轮询的方式，也就是讲全部都过一遍来查看进度，因而使用 select 能够同时盯着
            的项目数量由 FD_SETSIZE 限制。
            
            如果改为事件通知的方式，情况会好很多，项目不需要轮询盯着，当发生变化的时候，主动通知，
            然后查看情况，做相应的操作。
            
            能够完成这个事情的函数叫 epoll,它在内核中的实现方式不是通过轮询的方式，而是通过
            注册callback 函数的方式，当某个文件描述符发送变化的时候，就会通知。
            
            通过这种方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听
            的Socket 的数目也非常的多了，因而，epoll 被称为解决 C10k 问题的利器。
            
    4、进程和线程的区别：    
        
        进程：
        
            在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到
            了那一行程序的进程。也就是说子进程应该完整地复制父进程的堆，栈以及数据空间。
        
            进程间的通信：
            
                a.  管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，
                    有名管道克服了管道没有名字的限制。
                
                b. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，
                   除了用于进程间通信外，进程还可以发送信号给进程本身。
                   
                c. 消息队列:包括Posix消息队列system V消息队列。
                
                d. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式.
                
                e. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
                
                f. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。
        线程：
        
            线程就是把一个进程分为很多片，每一片都可以是一个独立的流程。
            这已经明显不同于多进程了，进程是一个拷贝的流程，而线程只是把一条河流截成很多条小溪。
            它没有拷贝这些额外的开销，但是仅仅是现存的一条河流，就被多线程技术几乎无开销地转成很多条小流程，
            它的伟大就在于它少之又少的系统开销。    
        
            创建线程：int pthread_create(pthread_t *restrict tidp, 
                                        const pthread_attr_t *restrict attr, 
                                        void *(*start_rtn)(void), void *restrict arg);
                     第一个参数为指向线程标识符的指针。  
                     第二个参数用来设置线程属性。  
                     第三个参数是线程运行函数的起始地址。  
                     最后一个参数是运行函数的参数。
        
            要确保函数线程安全，主要需要考虑的是线程之间的共享变量。
            属于同一进程的不同线程会共享进程内存空间中的全局区和堆，
            而私有的线程空间则主要包括栈和寄存器。
            因此，对于同一进程的不同线程来说，每个线程的局部变量都是私有的，而全局变量、局部静态变量、
            分配于堆的变量都是共享的。在对这些共享变量进行访问时，
            如果要保证线程安全，则必须通过加锁的方式。
        
        
        
      
        
"""第14将| HTTP 协议:看个新闻原来这么麻烦"""

    1、HTTP 请求准备：
    
        例如我们登录 http://www.163.com/index.html
        
        浏览器会将 www.163.net 这个域名发送给 DNS 服务器，让它解析 ip 地址。
        解析为 ip 地址，接下来是建立连接，HTTP 是基于 TCP 协议的，当然要先
        建立 TCP 连接，目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面
        默认开启了 Keep-Alive的，这样建立的 TCP 连接，就可以多次请求中复用。
        
    2、HTTP 请求的构建：
    
        建立连接以后，浏览器就要发送 HTTP 的请求。
        请求的格式就像这样：
        
                 --------------------------------------------------
        请求行    | 方法 | sp | URL | sp | 版本 | cr | if |
                 -----------------------------------------------     
        首部      | 首部字段名:  | sp |  字段值 | cr | if |
                 -----------------------------------------------
                 ...
                 -----------------------------------------------
                 | 首部字段名:   | sp | 字段值  | cr | if |
                 -----------------------------------------------
                 | cr | if |
                 ----------------------------------------------
        实体
                 -----------------------------------------------         
        
        HTTP 的报文大概分为三大部分，第一部分是请求行，第二部分是请求的首部，
        第三部分才是请求的正文实体。
   
   
        
        


"""第15将| HTTPS协议:点外卖的过程原来这么复杂"""

"""第16将| 流媒体协议: 如何在直播里看到美女帅哥"""




